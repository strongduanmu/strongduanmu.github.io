<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1" theme-name="Stellar" theme-version="1.30.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>深入理解 Apache Calcite ValcanoPlanner 优化器 - 端小强的博客</title><meta name="description" content="注意：本文基于 Calcite 1.35.0 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。   前言 在上一篇深入理解 Apache Calcite HepPlanner 优化器一文中，我们介绍了查询优化器的基本概念和用途，并结合 Calcite HepPlanner 深入分析了启发式优化器的实现原理。启发式优化器使用相对简单，它直接对逻辑执行计划进行"><meta property="og:type" content="article"><meta property="og:title" content="深入理解 Apache Calcite ValcanoPlanner 优化器"><meta property="og:url" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner.html"><meta property="og:site_name" content="端小强的博客"><meta property="og:description" content="注意：本文基于 Calcite 1.35.0 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。   前言 在上一篇深入理解 Apache Calcite HepPlanner 优化器一文中，我们介绍了查询优化器的基本概念和用途，并结合 Calcite HepPlanner 深入分析了启发式优化器的实现原理。启发式优化器使用相对简单，它直接对逻辑执行计划进行"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1701996404.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1701996456.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1701996507.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1702118316.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1702769869.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703207948.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703208192.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703298241.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703810657.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703636903.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703810113.jpg"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1703897196.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1704158875.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1704245597.png"><meta property="og:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/202309210909027-20240207092016569.png"><meta property="og:image" content="https://strongduanmu.com/assets/wechat/gongzhonghao.png"><meta property="article:published_time" content="2023-12-06T00:17:59.000Z"><meta property="article:modified_time" content="2023-12-06T00:17:59.000Z"><meta property="article:author" content="端小强"><meta property="article:tag" content="Calcite"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner/1701996404.png"><meta name="twitter:creator" content="@strongduanmu"><meta name="keywords" content="Calcite"><link rel="alternate" href="/atom.xml" title="端小强的博客" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=1.30.1"><link rel="shortcut icon" href="/assets/placeholder/favicon.ico"><meta name="baidu-site-verification" content="codeva-sIRwgTpHve"><link rel="apple-touch-icon" sizes="180x180" href="/assets/placeholder/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/placeholder/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/placeholder/favicon-16x16.png"><link rel="manifest" href="/assets/placeholder/site.webmanifest"><link rel="stylesheet" href="/css/custom.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaimono-bold.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaiscreen.css" media="all" onload='this.media="all"'></head><body><div class="l_body content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container"><header class="header"><div class="logo-wrap"><a class="avatar" href="/more/"><div class="bg" style="opacity:0;background-image:url(/assets/placeholder/rainbow64@3x.webp)"></div><img no-lazy class="avatar" src="/assets/placeholder/avatar.png" onerror="javascript:this.classList.add('error');this.src='/assets/placeholder/image.svg';"></a><a class="title" href="/"><div class="main" ff="title">端小强的博客</div><div class="sub normal cap">不积跬步，无以至千里 🤔</div><div class="sub hover cap" style="opacity:0">不积小流，无以成江海 😃</div></a></div></header><div class="nav-area"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><nav class="menu dis-select"><a class="nav-item active" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="文档" href="/wiki/"><span>文档</span></a><a class="nav-item" title="便笺" href="/notes/"><span>便笺</span></a><a class="nav-item" title="更多" href="/more/"><span>更多</span></a></nav></div><div class="widgets"><widget class="widget-wrapper markdown"><div class="widget-header dis-select"><span class="name">欢迎光临</span></div><div class="widget-body fs14"><p>欢迎访问端小强的博客，本人目前专注于 <a target="_blank" rel="noopener" href="https://github.com/apache/shardingsphere">Apache ShardingSphere</a> 内核模块开发，以及 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite">Apache Calcite</a> 查询优化技术的研究，本站会记录日常工作学习过程中的经验总结和知识梳理，欢迎大家留言交流。</p><div class="linklist center" style="grid-template-columns:repeat(1,1fr)"><a class="link" title="立即前往" href="/more/#comments"><div class="flex"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"></path><path fill="currentColor" d="M7.25 9A.75.75 0 0 1 8 8.25h8a.75.75 0 0 1 0 1.5H8A.75.75 0 0 1 7.25 9m0 3.5a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 0 1.5H8a.75.75 0 0 1-.75-.75"></path></svg><span>立即前往</span></div></a></div></div></widget><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">专栏：Calcite</span></div><div class="widget-body"><a class="item" href="/blog/apache-calcite-catalog-type-system-implementation.html"><span class="title">Apache Calcite Catalog 拾遗之类型系统实现</span></a><a class="item" href="/blog/using-calcite-as-an-example-to-explore-the-common-implementation-of-join-operators.html"><span class="title">以 Calcite 为例探究 Join 算子的常用实现</span></a><a class="item" href="/blog/explore-the-practice-of-apache-calcite-in-mycat2.html"><span class="title">Apache Calcite 在 MyCat2 中的实践探究</span></a><a class="item" href="/blog/calcite-udf-in-action-shardingsphere-sql-federation-adapte-to-mysql-bit-count.html"><span class="title">Calcite UDF 实战之 ShardingSphere 联邦查询适配 MySQL BIT_COUNT</span></a><a class="item" href="/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"><span class="title">Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展</span></a><a class="item" href="/blog/in-depth-exploration-of-implementation-principle-of-apache-calcite-sql-validator.html"><span class="title">深度探究 Apache Calcite SQL 校验器实现原理</span></a><a class="item" href="/blog/cornerstone-of-cbo-optimization-apache-calcite-statistics-and-cost-model.html"><span class="title">CBO 优化的基石——Apache Calcite 统计信息和代价模型详解</span></a><a class="item active" href="/blog/deep-understand-of-apache-calcite-volcano-planner.html"><span class="title">深入理解 Apache Calcite ValcanoPlanner 优化器</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/blog/deep-understand-of-apache-calcite-hep-planner.html"><span class="title">深入理解 Apache Calcite HepPlanner 优化器</span></a><a class="item" href="/blog/explore-apache-calcite-system-catalog-implementation.html"><span class="title">Apache Calcite System Catalog 实现探究</span></a><a class="item" href="/blog/implementation-principle-of-apache-calcite-sql-parser.html"><span class="title">Apache Calcite SQL Parser 原理剖析</span></a><a class="item" href="/blog/apache-calcite-quick-start-guide.html"><span class="title">Apache Calcite 快速入门指南</span></a><a class="item" href="/blog/apache-calcite-learning-materials.html"><span class="title">Apache Calcite 学习资料整理</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="mailto:duanzhengqiang@apache.org" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/email.svg"></a><a class="social" href="https://github.com/strongduanmu" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/github.svg"></a><a class="social" href="/sitemap.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/sitemap.svg"></a><a class="social" href="/atom.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/rss.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/banner/banner_7.jpg"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/blog/apache-calcite-catalog-type-system-implementation.html">Calcite</a></div><div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-12-06T00:17:59.000Z">2023-12-06</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2023-12-06T00:17:59.000Z">2023-12-06</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>深入理解 Apache Calcite ValcanoPlanner 优化器</span></h1></div></div></div></div><article class="md-text content"><blockquote><p>注意：本文基于 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/tree/75750b78b5ac692caa654f506fc1515d4d3991d6">Calcite 1.35.0</a> 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者<strong>请注意版本选择</strong>。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在上一篇<a href="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-hep-planner.html">深入理解 Apache Calcite HepPlanner 优化器</a>一文中，我们介绍了查询优化器的基本概念和用途，并结合 Calcite <code>HepPlanner</code> 深入分析了<code>启发式优化器</code>的实现原理。启发式优化器使用相对简单，它直接对逻辑执行计划进行等价变换从而实现 SQL 优化，常见的启发式优化包含了：<code>列裁剪</code>、<code>谓词下推</code>等。启发式优化器实现简单，自然也存在一些缺陷，例如：它对执行的顺序有要求，不同的执行顺序可能会导致优化规则的失效，使得优化达不到预期的效果。</p><p>正是由于启发式优化器存在这些问题，使得它无法适应所有的 SQL 场景，因此当前主流的数据库系统更多是使用<code>基于代价的优化器</code>，或者将两者结合使用。基于代价的优化器能够为多个等价的执行计划生成代价 <code>Cost</code> 信息，然后选择代价最小的选项作为最终的执行计划，从而达到提升 SQL 执行效率的目的。</p><p>本文将重点为大家介绍 Calcite 中基于代价的优化器 <code>VolcanoPlanner</code>，首先我们会了解 VolcanoPlanner 背后的理论基础——<code>Volcano/Cascades Optimizer</code>，然后会介绍 VolcanoPlanner 的核心概念以及执行流程，最后再深入探究 Calcite VolcanoPlanner 的源码细节，结合一些实际的 SQL 优化案例，期望能够让大家彻底搞懂 VolcanoPlanner 优化器。</p><h2 id="volcanocascades-优化器"><a class="markdownIt-Anchor" href="#volcanocascades-优化器"></a> Volcano/Cascades 优化器</h2><p>Calcite VolcanoPlanner 优化器是基于 <code>Goetz Graefe</code> 的两篇经典优化器论文 <a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2019/papers/22-optimizer1/graefe-icde1993.pdf">The Volcano Optimizer Generator: Extensibility and Efficient Search</a> 和 <a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/15-optimizer1/graefe-ieee1995.pdf">The Cascades Framework for Query Optimization</a> 实现的，因此在探究 VolcanoPlanner 优化器实现细节之前，让我们先来回顾下这两篇论文的核心思想，方便后续的学习和理解。</p><h3 id="volcano-优化器生成器"><a class="markdownIt-Anchor" href="#volcano-优化器生成器"></a> Volcano 优化器生成器</h3><p><code>Volcano Optimizer Generator</code> 的定位是一个优化器的<code>生成器</code>，其核心贡献是提供了一个搜索引擎。论文中提出了数据库查询优化器的基本框架，数据库实现者只需要为自己的 <code>Data Model</code> 实现相应的接口，便可以实现一个查询优化器。本文暂时忽略<code>生成器</code>相关的概念，只介绍论文在<code>优化器</code>方面提出的一些思路：</p><ul><li><p>Volcano Optimizer 使用两阶段优化的方式，它使用 <code>Logical Algebra</code> 来表示各种关系代数算子，而使用 <code>Physical Algebra</code> 来表示各种关系代数算子的实现算法。Logical Algebra 之间使用 <code>Transformation</code> 来完成变换，而 Logical Algebra 到 Physical Algebra 之间的转换则基于代价（<code>Cost-Based</code>）进行选择；</p></li><li><p>Volcano Optimizer 中的变化都使用 <code>Rule</code> 来描述。例如 Logical Algebra 之间的变化使用 <code>Transformation Rule</code>，而 Logical Algebra 到 Physical Algebra 之间的转换使用 <code>Implementation Rule</code>；</p></li><li><p>Volcano Optimizer 中各个算子、表达式的结果使用 <code>Property</code> 来表示。<code>Logical Propery</code> 可以从 Logical Algebra 中提取，主要包括算子的 Schema、统计信息等。<code>Physical Property</code> 可以从 Physical Algebra 中提取，表示算子所产生的数据具有的物理属性，比如按照某个 Key 排序、按照某个 Key 分布在集群中等；</p></li><li><p>Volcano Optimizer 的搜索采用<code>自顶向下的动态规划算法</code>（记忆化搜索）。</p></li></ul><h3 id="cascades-优化器"><a class="markdownIt-Anchor" href="#cascades-优化器"></a> Cascades 优化器</h3><p><code>Cascades Optimizer</code> 是对 <code>Volcano Optimizer</code> 的进一步优化，Cascades Optimizer 提出了 <code>Memo</code>、<code>Rule</code>、<code>Pattern</code> 和 <code>Search Algorithm</code> 等基本概念，下面我们将围绕这些概念一一进行介绍。</p><h4 id="memo-数据结构"><a class="markdownIt-Anchor" href="#memo-数据结构"></a> Memo 数据结构</h4><p>Cascades Optimizer 在搜索的过程中，它的搜索空间是一个关系代数算子树所组成的森林，而保存这个森林的数据结构就是 <code>Memo</code>。Memo 包含了两个最基本的概念：<code>Expression Group</code>（下文简称 <code>Group</code>） 和 <code>Group Expression</code>（对应关系代数算子）。每个 Group 中保存的是逻辑等价的 Group Expression，而 Group Expression 的子节点是由 Group 组成。下图是由五个 Group 组成的 Memo：</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1701996404.png" title="Memo 组成结构"><p>通过上面的 Memo 结构，我们可以提取出以下两棵等价的算子树，使用 Memo 结构存储下面两棵树，可以避免存储冗余的算子（如 <code>Scan A</code> 以及 <code>Scan B</code>）。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1701996456.png" title="等价算子树"><h4 id="rule-的改进"><a class="markdownIt-Anchor" href="#rule-的改进"></a> Rule 的改进</h4><p>在 Volcano Optimizer 中，Rule 被分为了 <code>Transformation Rule</code> 和 <code>Implementation Rule</code> 两种。其中 Transformation Rule 用来在 Memo 中添加等价的关系代数算子。Transformation Rule 具有原子性，只作用于算子树的一个局部小片段，每个 Transformation Rule 都有自己的匹配条件，通过不停的应用匹配上的 Transformation Rule 来扩展搜索空间，寻找可能的最优解。Implementation Rule 则是为 Group Expression 选择物理算子。在 Cascades Optimizer 中，不再区分这两类 Rule。</p><h4 id="pattern-匹配规则"><a class="markdownIt-Anchor" href="#pattern-匹配规则"></a> Pattern 匹配规则</h4><p><code>Pattern</code> 用于描述 Group Expression 的局部特征。每个 Rule 都有自己的 Pattern，只有满足了相应 Pattern 的 Group Expression 才能够应用该 Rule。下图中左侧定义了一个 <code>Selection -&gt; Projection</code> 的 Pattern，并在右侧 Memo 中红色虚线内匹配上了 Group Expression。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1701996507.png" title="Pattern 匹配关系代数算子"><h4 id="searching-algorithm"><a class="markdownIt-Anchor" href="#searching-algorithm"></a> Searching Algorithm</h4><p>Cascades Optimizer 为 Rule 的应用顺序做了细致的设计，例如每个 Rule 都有 <code>promise</code> 和 <code>condition</code> 两个方法，其中 <code>promise</code> 用来表示 Rule 在当前搜索过程中的重要性，<code>promise</code> 值越高，则该规则越可能有用，当 <code>promise</code> 值小于等于 0 时，这个 Rule 就不会被执行。而 <code>condition</code> 直接通过返回一个布尔值决定一个 Rule 是否可以在当前过程中被应用。当一个 Rule 被成功应用之后，会计算下一步有可能会被应用的 Rule 的集合。</p><p>Cascades Optimizer 的搜索算法与 Volcano Optimizer 有所不同，Volcano Optimizer 将搜索分为两个阶段，在第一个阶段枚举所有逻辑等价的 Logical Algebra，而在第二阶段运用动态规划的方法自顶向下地搜索代价最小的 Physical Algebra。Cascades Optimizer 则将这两个阶段融合在一起，通过提供一个 <code>Guidance</code> 来指导 Rule 的执行顺序，<strong>在枚举逻辑等价算子的同时也进行物理算子的生成</strong>，这样做可以避免枚举所有的逻辑执行计划，但是<strong>其弊端就是错误的 Guidance 会导致搜索在局部收敛，因而搜索不到最优的执行计划</strong>。</p><p>Volcano/Cascades Optimzier 都使用了 <code>Branch-And-Bound</code> 方法对搜索空间进行剪枝。由于两者都采用了自顶向下的搜索，在搜索的过程中可以为算子设置其 <code>Cost Upper Bound</code>，如果在向下搜索的过程中还没有搜索到叶子节点就超过了预设的 Cost Upper Bound，就可以对这个搜索分支预先进行剪枝。</p><h2 id="volcanoplanner-基础介绍"><a class="markdownIt-Anchor" href="#volcanoplanner-基础介绍"></a> VolcanoPlanner 基础介绍</h2><p>前面部分我们介绍了 Volcano/Cascades 优化器的理论基础，想必大家已经对优化器的原理有了一些基础的认识。为了避免陷入代码细节，我们学习 VolcanoPlanner 之前，先来了解下 VolcanoPlanner 中涉及到的核心概念，理解这些概念会让我们阅读源码更加轻松。然后我们会从整体角度，再来学习下 VolcanoPlanner 的处理流程，看看 Calcite 逻辑计划是如何优化并转换为物理执行计划的。</p><h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3><h4 id="relnode"><a class="markdownIt-Anchor" href="#relnode"></a> RelNode</h4><p>Caclite 源码中对 RelNode 的定义为 <code>A RelNode is a relational expression</code>，即关系代数表达式，RelNode 继承 RelOptNode 接口，表示可以被优化器优化。关系代数表达式用于处理数据，所以他们通常使用动词命名，例如：<code>Sort</code>、<code>Join</code>、<code>Project</code>、<code>Filter</code>、<code>Scan</code> 等。在 Caclite 中，不建议直接实现 RelNode 接口，而是推荐继承 <code>AbstractRelNode</code> 抽象类。</p><p>AbstractRelNode 抽象类的核心属性和方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRelNode</span> <span class="keyword">implements</span> <span class="title class_">RelNode</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RelTraitSet that describes the traits of this RelNode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> RelTraitSet traitSet;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pure</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Convention <span class="title function_">getConvention</span><span class="params">(<span class="meta">@UnknownInitialization</span> AbstractRelNode <span class="built_in">this</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traitSet == <span class="literal">null</span> ? <span class="literal">null</span> : traitSet.getTrait(ConventionTraitDef.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RelDataType <span class="title function_">getRowType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowType == <span class="literal">null</span>) &#123;</span><br><span class="line">            rowType = deriveRowType();</span><br><span class="line">            <span class="keyword">assert</span> rowType != <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rowType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(RelOptPlanner planner)</span> &#123;</span><br><span class="line">        Util.discard(planner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;RelNode&gt; <span class="title function_">getInputs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">estimateRowCount</span><span class="params">(RelMetadataQuery mq)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">computeSelfCost</span><span class="params">(RelOptPlanner planner, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">        <span class="comment">// by default, assume cost is proportional to number of rows</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">rowCount</span> <span class="operator">=</span> mq.getRowCount(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> planner.getCostFactory().makeCost(rowCount, rowCount, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>traitSet</code> 用于记录当前 RelNode 的物理特征 <code>RelTrait</code>，Calcite 中提供了 <code>Convention</code> 、<code>RelCollation</code> 和 <code>RelDistribution</code> 3 种物理特征，分别表示调用约定（代表某一种数据源，不同数据源上的算子需要使用 Converter 进行转换）、排序和分布特征；</li><li><code>getConvention</code> 方法是用于获取当前 RelNode 中记录的 Convention 特征；</li><li><code>getRowType</code> 用于获取当前数据行的类型信息，RelNode 根节点的 RelDataType 可以代表最终查询结果的行记录类型信息；</li><li><code>getInputs</code> 用于获取当前 RelNode 的子节点，RelNode 通过 inputs 组织成一个树形结构；</li><li><code>estimateRowCount</code> 方法用于估计当前 RelNode 返回的行数，行数信息可以用来计算 RelNode 的代价 Cost；</li><li><code>computeSelfCost</code> 方法用于计算当前 RelNode 的代价 Cost；</li><li><code>register</code> 方法用于注册当前 RelNode 特有的优化规则，例如：<code>InnodbTableScan</code> 实现了 register 方法，注册了和 <code>InnodbTableScan</code> 这类 RelNode 相关的优化规则。</li></ul><h4 id="relset"><a class="markdownIt-Anchor" href="#relset"></a> RelSet</h4><p>Calcite 对 <code>RelSet</code> 的定义为 <code>A RelSet is an equivalence-set of expressions</code>，即一组等价的关系代数集合，同一个 RelSet 中的关系代数具有相同的调用规约（Calling Convention）。RelSet 类中的核心属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RelSet</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 等价的关系代数集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;RelNode&gt; rels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 物理属性相同的等价关系代数集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;RelSubset&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 等价的 RelSet</span></span><br><span class="line">    <span class="meta">@MonotonicNonNull</span> RelSet equivalentSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RelSet 类是等价关系代数的集合类，不是 RelNode；</li><li>等价的关系代数集合存储在 <code>rels</code> 中，他们具有相同的调用规约，但是其他物理属性可能不相同，例如：RelCollation 和 RelDistribution；</li><li>物理属性相同的等价关系代数集合会存储在 <code>subsets</code> 中，<code>RelSubset</code> 对象会根据物理属性对关系代数进行归类，相同物理属性的关系代数会存储在同一个 RelSubset 中。</li></ul><h4 id="relsubset"><a class="markdownIt-Anchor" href="#relsubset"></a> RelSubset</h4><p>Caclite 对 <code>RelSubset</code> 的定义为 <code>Subset of an equivalence class where all relational expressions have the same physical properties.</code>，即 RelSet 等价类的子集，它会按照物理属性将关系代数 RelNode 进行分类，物理属性相同的 RelNode 会在同一个 RelSubSet 中。RelSubset 类中的核心属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelSubset</span> <span class="keyword">extends</span> <span class="title class_">AbstractRelNode</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cost of best known plan (it may have improved since).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RelOptCost bestCost;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set this subset belongs to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> RelSet set;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Best known plan.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span> RelNode best;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the rel nodes in this rel subset.  All rels must have the same</span></span><br><span class="line"><span class="comment">     * traits and are logically equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all the rels in the subset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;RelNode&gt; <span class="title function_">getRels</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; Linq4j.asEnumerable(set.rels).where(v1 -&gt; v1.getTraitSet().satisfies(traitSet)).iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RelSubset 实现了 <code>AbstractRelNode</code>，是一个特殊的关系代数 RelNode；</li><li>RelSubSet 中记录了<strong>物理属性相同的关系代数 RelNode</strong>，并且这些关系代数不是直接存储在 RelSubSet 中，而是通过引用 RelSet 对象并通过 traitSet 过滤得到；</li><li>RelSubSet 会计算内部关系代数的<strong>最优代价 bestCost</strong>，并记录当前<strong>最优的执行计划 best</strong>，bestCost 和 best 会随着优化的执行而不断更新。</li></ul><h3 id="处理流程"><a class="markdownIt-Anchor" href="#处理流程"></a> 处理流程</h3><p>介绍完 VolcanoPlanner 中的核心概念，让我们再来了解下 Calcite 优化器的处理流程，Julain 在 2016 年举办的 Hadoop Summit 大会上分享了 <a target="_blank" rel="noopener" href="https://calcite.apache.org/community/#cost-based-query-optimization-in-apache-phoenix-using-apache-calcite">Cost-based Query Optimization in Apache Phoenix using Apache Calcite</a>，其中介绍了 Caclite 优化器的处理流程，虽然已经过去了很久，但是仍然可以作为 VolcanoPlanner 的参考资料。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1702118316.png" title="Calcite Volcano Planner 处理流程"><p>上图展示了 VolcanoPlanner 的处理流程，可以看到 SQL 语句被解析为 AST 后，通过 SqlToRelConverter 将 AST 转换为 RelNode 和 RexNode。RelNode Tree 就是我们常说的逻辑执行计划。方框内是 VolcanoPlanner 的核心流程，主要包含了如下几个关键步骤：</p><ul><li><p>将匹配的规则 Rule 添加到 <code>RuleQueue</code> 中，Calcite 提供了 <code>IterativeRuleQueue</code> 和 <code>TopDownRuleQueue</code>；</p></li><li><p>应用匹配的规则 Rule，对 RelNode Tree 进行转换；</p></li><li><p>进行相应的迭代，直到 RuleQueue 中的 Rule 全部迭代完成或者代价 Cost 不再变化；</p></li><li><p>基于 RelNode 的代价和深度匹配 <code>Importance</code>，Importance 描述了 RuleMatch 的重要程度，Importance 大的优先处理，每一轮迭代都会实时调整。</p></li></ul><p>除了以上的几个关键步骤外，图中还描述了 VolcanoPlanner 中的重要组成部分：<code>计划树（Plan Tree）</code>、<code>优化规则（Rules）</code>、<code>代价模型（Cost Model）</code> 和 <code>元数据提供器（Metadata Providers）</code>。计划树通过前文介绍的 RelSet 和 RelSubset 维护了优化过程中所需的数据结构，优化规则用于对 RelNode 进行优化，以生成等价且更优的关系代数，代价模型用于计算 RelNode 的代价和累积代价，元数据提供器则提供了代价计算所需的一些统计信息，例如：Filter 选择性、Join 选择性等。这些组成部分在 VolcanoPlanner 中相互配合，共同完成了优化过程，在下面的源码探秘部分，我们将一一进行研究学习。</p><h2 id="volcanoplanner-源码探秘"><a class="markdownIt-Anchor" href="#volcanoplanner-源码探秘"></a> VolcanoPlanner 源码探秘</h2><p>介绍完 VolcanoPlanner 中的核心概念和基础流程，想必大家对 VolcanoPlanner 已经有了初步地认识，但是想要彻底理解 VolcanoPlanner，还需要结合一些案例，对源码进行深入学习理解，才能知其然知其所以然。本小节将以 <code>CsvTest#testSelectSingleProjectGz</code> 测试 Case 为例，和大家一起探秘 VolcanoPlanner 源码。如下展示了测试 Case，使用了 <code>smart</code> 模型，表示使用 <code>TranslatableTable</code> 进行优化处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectSingleProjectGz</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    sql(<span class="string">&quot;smart&quot;</span>, <span class="string">&quot;select * from EMPS where name = &#x27;Alice&#x27;&quot;</span>).ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volcanoplanner-初始化"><a class="markdownIt-Anchor" href="#volcanoplanner-初始化"></a> VolcanoPlanner 初始化</h3><p>首先，我们来跟踪下 VolcanoPlanner 初始化流程，看下在初始化阶段，优化器都做了哪些准备工作。执行示例程序，在 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/967bb5acc5448bc8d6ee9b9f5fa3c5f0d71405c2/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java#L438">CalcitePrepareImpl#createPlanner</a> 方法中，我们可以看到如下初始化逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a query planner and initializes it with a default set of rules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> RelOptPlanner <span class="title function_">createPlanner</span><span class="params">(<span class="keyword">final</span> CalcitePrepare.Context prepareContext, <span class="meta">@Nullable</span> Context externalContext, <span class="meta">@Nullable</span> RelOptCostFactory costFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (externalContext == <span class="literal">null</span>) &#123;</span><br><span class="line">        externalContext = Contexts.of(prepareContext.config());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 初始化 VolcanoPlanner，允许用户传入代价工厂 costFactory，默认使用 VolcanoCost.FACTORY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">VolcanoPlanner</span> <span class="variable">planner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolcanoPlanner</span>(costFactory, externalContext);</span><br><span class="line">  	<span class="comment">// 设置标量表达式 scalar expressions 的执行器</span></span><br><span class="line">    planner.setExecutor(<span class="keyword">new</span> <span class="title class_">RexExecutorImpl</span>(DataContexts.EMPTY));</span><br><span class="line">    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);</span><br><span class="line">    <span class="keyword">if</span> (CalciteSystemProperty.ENABLE_COLLATION_TRAIT.value()) &#123;</span><br><span class="line">        planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 是否开启自顶向下优化，会根据该参数是否开启，初始化不同类型的 RuleDriver 和 RuleQueue</span></span><br><span class="line">    planner.setTopDownOpt(prepareContext.config().topDownOpt());</span><br><span class="line">  	<span class="comment">// 注册默认优化规则</span></span><br><span class="line">    RelOptUtil.registerDefaultRules(planner, prepareContext.config().materializationsEnabled(), enableBindable);</span><br><span class="line">    <span class="keyword">return</span> planner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 VolcanoPlanner 对象时，允许用户传入 <code>costFactory</code> 代价工厂，默认会使用 <code>VolcanoCost.FACTORY</code> 工厂类。初始化优化器时，同时会设置标量表达式（<code>scalar expressions</code>）执行器，负责计算表达式的结果。<code>setTopDownOpt</code> 方法会根据配置判断是否开启自顶向下优化，该配置默认为 false，同时会根据该参数初始化 <code>RuleDriver</code> 和 <code>RuleQueue</code>，本文先关注 Calcite 默认的 <code>IterativeRuleDriver</code> 和 <code>IterativeRuleQueue</code>，后续文章会再探讨 <code>Volcano &amp; Cascades</code> 论文中提出的 <code>TopDownRuleDriver</code> 和 <code>TopDownRuleQueue</code>。</p><p><code>RelOptUtil.registerDefaultRules</code> 方法会注册默认的优化规则，内部调用 <code>planner.addRule</code> 方法，将规则记录在优化器父类 <code>AbstractRelOptPlanner</code> 的 <code>mapDescToRule</code> 属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Experimental</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerDefaultRules</span><span class="params">(RelOptPlanner planner, <span class="type">boolean</span> enableMaterializations, <span class="type">boolean</span> enableBindable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CalciteSystemProperty.ENABLE_COLLATION_TRAIT.value()) &#123;</span><br><span class="line">        registerAbstractRelationalRules(planner);</span><br><span class="line">    &#125;</span><br><span class="line">    registerAbstractRules(planner);</span><br><span class="line">    registerBaseRules(planner);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (enableMaterializations) &#123;</span><br><span class="line">        registerMaterializationRules(planner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (enableBindable) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RelOptRule rule : Bindables.RULES) &#123;</span><br><span class="line">            planner.addRule(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    planner.addRule(Bindables.BINDABLE_TABLE_SCAN_RULE);</span><br><span class="line">    planner.addRule(CoreRules.PROJECT_TABLE_SCAN);</span><br><span class="line">    planner.addRule(CoreRules.PROJECT_INTERPRETER_TABLE_SCAN);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (CalciteSystemProperty.ENABLE_ENUMERABLE.value()) &#123;</span><br><span class="line">        registerEnumerableRules(planner);</span><br><span class="line">        planner.addRule(EnumerableRules.TO_INTERPRETER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (enableBindable &amp;&amp; CalciteSystemProperty.ENABLE_ENUMERABLE.value()) &#123;</span><br><span class="line">        planner.addRule(EnumerableRules.TO_BINDABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (CalciteSystemProperty.ENABLE_STREAM.value()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RelOptRule rule : StreamRules.RULES) &#123;</span><br><span class="line">            planner.addRule(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    planner.addRule(CoreRules.FILTER_REDUCE_EXPRESSIONS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calcite JDBC 默认注册了 101 个优化规则，这些优化规则的作用，我们后续文章会进行分类学习，在实际使用中可以选择自己需要的优化规则去使用。到这里，Calicte 就完成了 VolcanoPlanner 的优化，并默认注册了 101 个优化规则。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1702769869.png" title="Calcite JDBC 默认注册的规则"><h3 id="setroot-流程"><a class="markdownIt-Anchor" href="#setroot-流程"></a> setRoot 流程</h3><p>VolcanoPlanner 初始化完成后，又会调用 SqlParser 进行 SQL 解析，并使用 SqlToRelConverter 将 AST 转换为 RelNode 逻辑执行计划，可以得到如下的 Logical Plan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LogicalProject(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], SLACKER=[$7], MANAGER=[$8], JOINEDAT=[$9])</span><br><span class="line">  LogicalFilter(condition=[=($1, &#x27;Alice&#x27;)])</span><br><span class="line">    CsvTableScan(table=[[SALES, EMPS]], fields=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])</span><br></pre></td></tr></table></figure><p>Calcite JDBC 流程中将优化器的调用封装在了 <code>Program</code> 中，如下示例展示了调用逻辑，最核心的方式是 <code>setRoot</code> 和 <code>findBestExp</code>，本小节先关注 <code>setRoot</code> 方法的实现逻辑，看看示例中的两次 setRoot 都进行了哪些处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the standard program with user metadata provider.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Program <span class="title function_">standard</span><span class="params">(RelMetadataProvider metadataProvider)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Program</span> <span class="variable">program1</span> <span class="operator">=</span> (planner, rel, requiredOutputTraits, materializations, lattices) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (RelOptMaterialization materialization : materializations) &#123;</span><br><span class="line">            planner.addMaterialization(materialization);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RelOptLattice lattice : lattices) &#123;</span><br><span class="line">            planner.addLattice(lattice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// setRoot 设置 RelSubset 根节点        </span></span><br><span class="line">        planner.setRoot(rel);</span><br><span class="line">        <span class="comment">// 变换 trait 属性，将 Convention NONE 变换为 ENUMERABLE</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">rootRel2</span> <span class="operator">=</span> rel.getTraitSet().equals(requiredOutputTraits)</span><br><span class="line">                ? rel : planner.changeTraits(rel, requiredOutputTraits);</span><br><span class="line">        <span class="keyword">assert</span> rootRel2 != <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// setRoot 设置 RelSubset 根节点</span></span><br><span class="line">        planner.setRoot(rootRel2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelOptPlanner</span> <span class="variable">planner2</span> <span class="operator">=</span> planner.chooseDelegate();</span><br><span class="line">        <span class="comment">// 查找最佳执行计划</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">rootRel3</span> <span class="operator">=</span> planner2.findBestExp();</span><br><span class="line">        <span class="keyword">assert</span> rootRel3 != <span class="literal">null</span> : <span class="string">&quot;could not implement exp&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> rootRel3;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sequence(subQuery(metadataProvider), <span class="keyword">new</span> <span class="title class_">Programs</span>.DecorrelateProgram(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Programs</span>.TrimFieldsProgram(), program1, calc(metadataProvider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一轮-setroot"><a class="markdownIt-Anchor" href="#第一轮-setroot"></a> 第一轮 setRoot</h4><p>第一次调用 <code>setRoot</code> 方法，直接传递了原始的 RelNode，未进行 Trait 变换，<code>setRoot</code> 方法负责将 RelNode Tree 转换为 RelSubset Tree，并设置到 VolcanoPlanner 中的 <code>root</code> 属性中。如下是 <code>setRoot</code> 的代码实现，<code>registerImpl</code> 是其核心逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RelSubset 根节点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="meta">@MonotonicNonNull</span> RelSubset root;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(RelNode rel)</span> &#123;</span><br><span class="line">  	<span class="comment">// 核心逻辑</span></span><br><span class="line">    <span class="built_in">this</span>.root = registerImpl(rel, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.originalRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.originalRoot = rel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rootConvention = <span class="built_in">this</span>.root.getConvention();</span><br><span class="line">    ensureRootConverters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerImpl</code> 方法用于注册新的关系代数表达式，并将匹配的规则加入到队列中。如果 <code>set</code>（等价集合） 参数不为 null，则将当前表达式加入到等价集合中，如果已经注册了相同的表达式，则无需将其加入到等价集合以及队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">registerImpl</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelSet set)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 rel 已经是 RelSubset，则直接调用 registerSubset 注册</span></span><br><span class="line">    <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">        <span class="keyword">return</span> registerSubset(set, (RelSubset) rel);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ensure that its sub-expressions are registered.</span></span><br><span class="line">    <span class="comment">// 监听该表达式将要注册的通知</span></span><br><span class="line">    rel = rel.onRegister(<span class="built_in">this</span>);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="onregister"><a class="markdownIt-Anchor" href="#onregister"></a> onRegister</h5><p>第一次调用 <code>setRoot</code> 方法时，<code>rel</code> 参数为 <code>LogicalProject</code>，因此会调用后续逻辑进行处理，<code>onRegister</code> 方法会确保 RelNode 的子节点也注册生成 RelSubset。<code>AbstractRelNode#onRegister</code> 方法实现逻辑如下，<code>getInputs</code> 方法会获取当前 RelNode 的子节点（返回 LogicalFilter 子节点），并调用 <code>VolcanoPlanner#ensureRegistered</code> 方法，确保所有的子节点都会进行注册，然后重新 copy 生成新的 RelNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RelNode <span class="title function_">onRegister</span><span class="params">(RelOptPlanner planner)</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取子节点</span></span><br><span class="line">    List&lt;RelNode&gt; oldInputs = getInputs();</span><br><span class="line">    List&lt;RelNode&gt; inputs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(oldInputs.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RelNode input : oldInputs) &#123;</span><br><span class="line">      	<span class="comment">// 调用 VolcanoPlanner#ensureRegistered 注册子节点</span></span><br><span class="line">        <span class="type">RelNode</span> <span class="variable">e</span> <span class="operator">=</span> planner.ensureRegistered(input, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">assert</span> e == input || RelOptUtil.equal(<span class="string">&quot;rowtype of rel before registration&quot;</span>, input.getRowType(), <span class="string">&quot;rowtype of rel after registration&quot;</span>, e.getRowType(), Litmus.THROW);</span><br><span class="line">        inputs.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RelNode</span> <span class="variable">r</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Util.equalShallow(oldInputs, inputs)) &#123;</span><br><span class="line">      	<span class="comment">// 复制生成新的 RelNode</span></span><br><span class="line">        r = copy(getTraitSet(), inputs);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 重新计算 Digest 摘要信息，是 RelNode 的唯一标识</span></span><br><span class="line">    r.recomputeDigest();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VolcanoPlanner#ensureRegistered</code> 方法会对当前子节点 LogicalFilter 进行注册，先调用 getSubset 从 <code>mapRel2Subset</code> 获取当前 RelNode 对应的 RelSubset，如果不存在则调用 <code>VolcanoPlanner#register</code> 方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护已注册的 RelNode 和 RelSubset 映射关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IdentityHashMap&lt;RelNode, RelSubset&gt; mapRel2Subset = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RelSubset <span class="title function_">ensureRegistered</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelNode equivRel)</span> &#123;</span><br><span class="line">    RelSubset result;</span><br><span class="line">    <span class="comment">// 从 mapRel2Subset 中获取 RelSubset</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> getSubset(rel);</span><br><span class="line">    <span class="keyword">if</span> (subset != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equivRel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">RelSubset</span> <span class="variable">equivSubset</span> <span class="operator">=</span> getSubsetNonNull(equivRel);</span><br><span class="line">            <span class="comment">// 如果当前节点的等价集合和已知的等价集合不同，则进行合并</span></span><br><span class="line">            <span class="keyword">if</span> (subset.set != equivSubset.set) &#123;</span><br><span class="line">                merge(equivSubset.set, subset.set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = canonize(subset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 RelSubset 为空则进行注册</span></span><br><span class="line">        result = register(rel, equivRel);</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VolcanoPlanner#register</code> 方法会调用 <code>VolcanoPlanner#registerImpl</code> 对 LogicalFilter 节点进行注册，然后逻辑又重新回到了 <code>VolcanoPlanner#registerImpl</code> 方法。<code>onRegister</code> 方法会对 LogicalFilter 节点的子节点 <code>CsvTableScan</code> 进行注册，由于 CsvTableScan 节点没有子节点，因此在 onRegister 方法处理时会中断递归，此外，由于没有子节点，CsvTableScan 会返回当前 RelNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RelNode <span class="title function_">onRegister</span><span class="params">(RelOptPlanner planner)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    List&lt;RelNode&gt; oldInputs = getInputs();</span><br><span class="line">    List&lt;RelNode&gt; inputs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(oldInputs.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RelNode input : oldInputs) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RelNode</span> <span class="variable">r</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Util.equalShallow(oldInputs, inputs)) &#123;</span><br><span class="line">        <span class="comment">// 复制生成新的 RelNode</span></span><br><span class="line">        r = copy(getTraitSet(), inputs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新计算 Digest 摘要信息，是 RelNode 的唯一标识</span></span><br><span class="line">    r.recomputeDigest();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后优化器会从双端队列 ruleCallStack 中获取首个元素，并记录到 <code>provenanceMap</code> 中，provenanceMap 用于记录 RelNode 的来源，包括 <code>UnknownProvenance</code>、<code>DirectProvenance</code> 和 <code>RuleProvenance</code>。如果当前参数的 RelSet 为 null，则会创建一个 RelSet 并添加到 <code>allSets</code> 中。<code>registerClass</code> 方法允许 RelNode 注册自己特有的优化规则，本案例中 <code>CsvTableScan</code> 注册了 <code>CsvRules.PROJECT_SCAN</code> 规则。完成规则注册后，优化器会调用 addRelToSet 和 fireRules 方法，这部分是 VolcanoPlanner 的核心逻辑，下面我们来一起深入分析下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">registerImpl</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelSet set)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">        <span class="keyword">return</span> registerSubset(set, (RelSubset) rel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure that its sub-expressions are registered.</span></span><br><span class="line">    rel = rel.onRegister(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// Record its provenance. (Rule call may be null.)</span></span><br><span class="line">    <span class="comment">// 从双端队列中获取 VolcanoRuleCall，并记录到 provenanceMap 中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">VolcanoRuleCall</span> <span class="variable">ruleCall</span> <span class="operator">=</span> ruleCallStack.peek();</span><br><span class="line">    <span class="keyword">if</span> (ruleCall == <span class="literal">null</span>) &#123;</span><br><span class="line">        provenanceMap.put(rel, Provenance.EMPTY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        provenanceMap.put(rel, <span class="keyword">new</span> <span class="title class_">RuleProvenance</span>(ruleCall.rule, ImmutableList.copyOf(ruleCall.rels), ruleCall.id));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Place the expression in the appropriate equivalence set.</span></span><br><span class="line">    <span class="comment">// 如果当前 RelSet 为空，则创建一个 RelSet 并添加到 allSets 中</span></span><br><span class="line">    <span class="keyword">if</span> (set == <span class="literal">null</span>) &#123;</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">RelSet</span>(nextSetId++, Util.minus(RelOptUtil.getVariablesSet(rel), rel.getVariablesSet()), RelOptUtil.getVariablesUsed(rel));</span><br><span class="line">        <span class="built_in">this</span>.allSets.add(set);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Allow each rel to register its own rules.</span></span><br><span class="line">    <span class="comment">// 触发当前 RelNode#register 方法，允许注册自己的优化规则</span></span><br><span class="line">    <span class="comment">// CsvTableScan#register 方法注册了 CsvRules.PROJECT_SCAN 规则</span></span><br><span class="line">    registerClass(rel);</span><br><span class="line">    <span class="comment">// 当前节点注册完成后，调用 addRelToSet 添加到等价集合中</span></span><br><span class="line">    <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> addRelToSet(rel, set);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Queue up all rules triggered by this relexp&#x27;s creation.</span></span><br><span class="line">    <span class="comment">// 对注册的规则进行匹配筛选</span></span><br><span class="line">    fireRules(rel);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="addreltoset"><a class="markdownIt-Anchor" href="#addreltoset"></a> addRelToSet</h5><p>每个 RelNode 注册完成后会调用 <code>addRelToSet</code> 添加到等价集 RelSet 中，<code>set.add(rel)</code> 内部会调用 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/c4042a34ef054b89cec1c47fefcbc8689bad55be/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java#L261">RelSet#getOrCreateSubset</a> 方法，该方法会根据特征 Trait 判断 RelSubset 是否已经存在，不存在则创建 RelSubset 实例，此时 bestCost 为 VolcanoCost.INFINITY。然后会将返回的 RelSubset 维护到 <code>mapRel2Subset</code> 中，方便后续复用。<code>propagateCostImprovements</code> 会重新计算节点的代价，如果它的代价小于 RelSubset 的代价，则更新 RelSubset 中的 <code>bestCost</code> 和 <code>best</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">addRelToSet</span><span class="params">(RelNode rel, RelSet set)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到等价集合中 RelSet 和 RelSubset 中，并返回 RelSubset</span></span><br><span class="line">    <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> set.add(rel);</span><br><span class="line">    <span class="comment">// 维护 Rel 和 Subset 映射关系</span></span><br><span class="line">    mapRel2Subset.put(rel, subset);</span><br><span class="line">    <span class="comment">// While a tree of RelNodes is being registered, sometimes nodes&#x27; costs</span></span><br><span class="line">    <span class="comment">// improve and the subset doesn&#x27;t hear about it. You can end up with</span></span><br><span class="line">    <span class="comment">// a subset with a single rel of cost 99 which thinks its best cost is</span></span><br><span class="line">    <span class="comment">// 100. We think this happens because the back-links to parents are</span></span><br><span class="line">    <span class="comment">// not established. So, give the subset another chance to figure out</span></span><br><span class="line">    <span class="comment">// its cost.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新计算是否存在更小的 cost，存在则更新 RelSubset 中的 bestCost 和 best</span></span><br><span class="line">        propagateCostImprovements(rel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CyclicMetadataException e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ruleDriver != <span class="literal">null</span>) &#123;</span><br><span class="line">        ruleDriver.onProduce(rel, subset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>propagateCostImprovements</code> 方法的实现逻辑如下，方法内部定义了一个优先级队列，队列会根据 RelNode 的代价 RelOptCost 进行排序，从而方便获取最小代价的 RelNode。然后从队列中弹出 RelNode，并遍历 RelNode 对应 RelSet 中的 RelSubset，判断当前计算的代价是否小于已知的最小代价，如果代价更小则更新最小代价 bestCost 和最优计划 best。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">propagateCostImprovements</span><span class="params">(RelNode rel)</span> &#123;</span><br><span class="line">    <span class="type">RelMetadataQuery</span> <span class="variable">mq</span> <span class="operator">=</span> rel.getCluster().getMetadataQuery();</span><br><span class="line">    <span class="comment">// RelNode 和 RelOptCost 映射，方便后续获取 RelOptCost</span></span><br><span class="line">    Map&lt;RelNode, RelOptCost&gt; propagateRels = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 优先级队列，按照 RelOptCost 排序</span></span><br><span class="line">    PriorityQueue&lt;RelNode&gt; propagateHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; &#123;...&#125;);</span><br><span class="line">    <span class="comment">// 获取 RelNode 对应的代价</span></span><br><span class="line">    propagateRels.put(rel, getCostOrInfinite(rel, mq));</span><br><span class="line">    <span class="comment">// 添加到队列中</span></span><br><span class="line">    propagateHeap.offer(rel);</span><br><span class="line">    RelNode relNode;</span><br><span class="line">    <span class="comment">// 从队列中弹出 RelNode</span></span><br><span class="line">    <span class="keyword">while</span> ((relNode = propagateHeap.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RelOptCost</span> <span class="variable">cost</span> <span class="operator">=</span> requireNonNull(propagateRels.get(relNode), <span class="string">&quot;propagateRels.get(relNode)&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历当前 RelNode 对应 RelSet 中的 RelSubset 集合（Trait 不同存储在不同 RelSubset 中）</span></span><br><span class="line">        <span class="keyword">for</span> (RelSubset subset : getSubsetNonNull(relNode).set.subsets) &#123;</span><br><span class="line">            <span class="comment">// 判断 Trait 是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (!relNode.getTraitSet().satisfies(subset.getTraitSet())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断代价是否小于已知最小代价</span></span><br><span class="line">            <span class="keyword">if</span> (!cost.isLt(subset.bestCost)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Update subset best cost when we find a cheaper rel or the current</span></span><br><span class="line">            <span class="comment">// best&#x27;s cost is changed</span></span><br><span class="line">            subset.timestamp++;</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;Subset cost changed: subset [&#123;&#125;] cost was &#123;&#125; now &#123;&#125;&quot;</span>,</span><br><span class="line">                    subset, subset.bestCost, cost);</span><br><span class="line">            <span class="comment">// 更新最小代价和最优计划</span></span><br><span class="line">            subset.bestCost = cost;</span><br><span class="line">            subset.best = relNode;</span><br><span class="line">            <span class="comment">// since best was changed, cached metadata for this subset should be removed</span></span><br><span class="line">            mq.clearCache(subset);</span><br><span class="line">            <span class="comment">// 遍历 RelSubset 的父节点（CsvTableScan 对应 RelSet 的父节点为空）</span></span><br><span class="line">            <span class="keyword">for</span> (RelNode parent : subset.getParents()) &#123;</span><br><span class="line">                mq.clearCache(parent);</span><br><span class="line">                <span class="comment">// 计算父节点代价</span></span><br><span class="line">                <span class="type">RelOptCost</span> <span class="variable">newCost</span> <span class="operator">=</span> getCostOrInfinite(parent, mq);</span><br><span class="line">                <span class="type">RelOptCost</span> <span class="variable">existingCost</span> <span class="operator">=</span> propagateRels.get(parent);</span><br><span class="line">                <span class="keyword">if</span> (existingCost == <span class="literal">null</span> || newCost.isLt(existingCost)) &#123;</span><br><span class="line">                    <span class="comment">// 如果父节点代价更小，则加入 propagateHeap 重新计算</span></span><br><span class="line">                    propagateRels.put(parent, newCost);</span><br><span class="line">                    <span class="keyword">if</span> (existingCost != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Cost reduced, force the heap to adjust its ordering</span></span><br><span class="line">                        propagateHeap.remove(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    propagateHeap.offer(parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 RelNode 代价是通过 <code>VolcanoPlanner#getCostOrInfinite</code> 方法，如果 getCost 返回的代价为 null，则会返回无穷大代价 infCost。getCost 方法会先判断当前 RelNode 是否已经是 RelSubset，如果是则直接返回 bestCost。然后根据 <code>noneConventionHasInfiniteCost</code> 标记以及当前 RelNode 的 Trait 判断是否针对 None Convention 直接返回无穷大代价，noneConventionHasInfiniteCost 参数可以通过 <code>VolcanoPlanner#setNoneConventionHasInfiniteCost</code> 方法设置。当前节点的代价计算是调用 <code>RelMetadataQuery#getNonCumulativeCost</code> 方法获取，然后获取子节点的代价进行累加，即 <code>RelNode 总代价 = RelNode 自身代价 + 所有子节点代价</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelOptCost <span class="title function_">getCostOrInfinite</span><span class="params">(RelNode rel, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">    <span class="type">RelOptCost</span> <span class="variable">cost</span> <span class="operator">=</span> getCost(rel, mq);</span><br><span class="line">    <span class="keyword">return</span> cost == <span class="literal">null</span> ? infCost : cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">getCost</span><span class="params">(RelNode rel, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">  	<span class="comment">// 如果已经是 RelSubset，直接返回 bestCost</span></span><br><span class="line">    <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((RelSubset) rel).bestCost;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 根据 noneConventionHasInfiniteCost 标记以及当前 RelNode 的 Trait 判断是否针对 None Convention 直接返回无穷大代价</span></span><br><span class="line">  	<span class="comment">// noneConventionHasInfiniteCost 参数可以通过 VolcanoPlanner#setNoneConventionHasInfiniteCost 设置</span></span><br><span class="line">    <span class="keyword">if</span> (noneConventionHasInfiniteCost</span><br><span class="line">            &amp;&amp; rel.getTraitSet().getTrait(ConventionTraitDef.INSTANCE) == Convention.NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> costFactory.makeInfiniteCost();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 获取当前 RelNode 的代价</span></span><br><span class="line">    <span class="type">RelOptCost</span> <span class="variable">cost</span> <span class="operator">=</span> mq.getNonCumulativeCost(rel);</span><br><span class="line">    <span class="keyword">if</span> (cost == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 判断代价是否为正数代价，不满足则返回最小代价</span></span><br><span class="line">    <span class="keyword">if</span> (!zeroCost.isLt(cost)) &#123;</span><br><span class="line">        <span class="comment">// cost must be positive, so nudge it</span></span><br><span class="line">        cost = costFactory.makeTinyCost();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 获取子节点的代价进行累加，即 RelNode 总代价 = RelNode 自身代价 + 所有子节点代价</span></span><br><span class="line">    <span class="keyword">for</span> (RelNode input : rel.getInputs()) &#123;</span><br><span class="line">        <span class="type">RelOptCost</span> <span class="variable">inputCost</span> <span class="operator">=</span> getCost(input, mq);</span><br><span class="line">        <span class="keyword">if</span> (inputCost == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cost = cost.plus(inputCost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RelMetadataQuery#getNonCumulativeCost</code> 方法如下，Calcite 会通过 Janino 动态生成 nonCumulativeCostHandler 对象，然后调用 <code>RelMdPercentageOriginalRows#getNonCumulativeCost</code> 方法，该方法会调用 RelNode#computeSelfCost 方法，此处为 CsvTableScan 实现的方法。CsvTableScan 会调用父类 TableScan 中的方法，此时会获取统计信息中获取行数信息 rowCount，然后使用优化器中的 CostFactory 计算代价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RelMetadataQuery#getNonCumulativeCost 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">getNonCumulativeCost</span><span class="params">(RelNode rel)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonCumulativeCostHandler.getNonCumulativeCost(rel, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MetadataHandlerProvider.NoHandler e) &#123;</span><br><span class="line">            nonCumulativeCostHandler = revise(BuiltInMetadata.NonCumulativeCost.Handler.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RelMdPercentageOriginalRows#getNonCumulativeCost 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">getNonCumulativeCost</span><span class="params">(RelNode rel, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rel.computeSelfCost(rel.getCluster().getPlanner(), mq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CsvTableScan#computeSelfCost 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">computeSelfCost</span><span class="params">(RelOptPlanner planner, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">    <span class="comment">// Multiply the cost by a factor that makes a scan more attractive if it</span></span><br><span class="line">    <span class="comment">// has significantly fewer fields than the original scan.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The &quot;+ 2D&quot; on top and bottom keeps the function fairly smooth.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For example, if table has 3 fields, project has 1 field,</span></span><br><span class="line">    <span class="comment">// then factor = (1 + 2) / (3 + 2) = 0.6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.computeSelfCost(planner, mq).multiplyBy(((<span class="type">double</span>) fields.length + <span class="number">2D</span>) / ((<span class="type">double</span>) table.getRowType().getFieldCount() + <span class="number">2D</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableScan#computeSelfCost 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> RelOptCost <span class="title function_">computeSelfCost</span><span class="params">(RelOptPlanner planner, RelMetadataQuery mq)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">dRows</span> <span class="operator">=</span> table.getRowCount();</span><br><span class="line">    <span class="type">double</span> <span class="variable">dCpu</span> <span class="operator">=</span> dRows + <span class="number">1</span>; <span class="comment">// ensure non-zero cost</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">dIo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> planner.getCostFactory().makeCost(dRows, dCpu, dIo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RelOptTableImpl#getRowCount 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRowCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rowCount != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rowCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (table != <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// CSV 示例中未注册统计信息，默认为 Statistics.UNKNOWN，rowCount 为 null</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Double</span> <span class="variable">rowCount</span> <span class="operator">=</span> table.getStatistic().getRowCount();</span><br><span class="line">        <span class="keyword">if</span> (rowCount != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rowCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 默认返回 100d</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的 CsvTableScan VolcanoCost 对象如下图所示，记录了 <code>cpu</code>、<code>io</code> 和 <code>rowCount</code> 信息。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703207948.png" title="CsvTableScan VolcanoCost 对象"><p><code>propagateCostImprovements</code> 方法会按照前文所述，将 RelSubset 中的代价和新计算的代价进行比较，如果发现更小代价，则会更新 bestCost 和 best 属性，RelSubset 更新后的对象如下图所示。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703208192.png" title="更新代价后的 RelSubset"><h5 id="firerules"><a class="markdownIt-Anchor" href="#firerules"></a> fireRules</h5><p>生成完 RelSubset 并计算 RelNode 的代价后，VolcanoPlanner 会调用 <code>fireRules</code> 方法，对队列中的规则进行匹配筛选，fireRules 实现逻辑如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires all rules matched by a relational expression.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rel Relational expression which has just been created (or maybe</span></span><br><span class="line"><span class="comment"> *            from the queue)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fireRules</span><span class="params">(RelNode rel)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (RelOptRuleOperand operand : classOperands.get(rel.getClass())) &#123;</span><br><span class="line">        <span class="comment">// 判断当前 Rel 是否匹配规则</span></span><br><span class="line">        <span class="keyword">if</span> (operand.matches(rel)) &#123;</span><br><span class="line">            <span class="keyword">final</span> VolcanoRuleCall ruleCall;</span><br><span class="line">            ruleCall = <span class="keyword">new</span> <span class="title class_">DeferringRuleCall</span>(<span class="built_in">this</span>, operand);</span><br><span class="line">            ruleCall.match(rel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>classOperands</code> 中记录了 RelNode 和 RelOptRuleOperand 的对应关系，RelOptRuleOperand 用于判断 RelOptRule 是否可以用于某个关系代数。下图展示了 CsvTableScan 对应的 RelOptRuleOperand 集合，这些 RelOptRuleOperand 都是和 TableScan 相关的规则。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703298241.png" title="classOperands 存储的优化规则"><p>对于每一个 RelOptRuleOperand，都会调用其 <code>matches</code> 方法，方法内会判断 RelNode 是否是 RelOptRuleOperand 中记录的 clazz 实例，以及 RelNode 是否包含定义的 trait 特征，最后会使用 predicate 方法对 RelNode 进行匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(RelNode rel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!clazz.isInstance(rel)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((trait != <span class="literal">null</span>) &amp;&amp; !rel.getTraitSet().contains(trait)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> predicate.test(rel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好奇的读者可能会问，RelOptRuleOperand 记录的这些信息是在什么时候初始化的？以 CsvProjectTableScanRule 为例，在该优化规则初始化时，会调用 <code>super(config)</code> 方法，使用 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/bebe473fab2e242736614659ed6e5d04eeeb8bf5/core/src/main/java/org/apache/calcite/plan/RelRule.java#L123">OperandBuilderImpl.operand(config.operandSupplier())</a> 初始化 RelOptRuleOperand 类，感兴趣的朋友可以自行探究下。</p><p>RelOptRuleOperand 匹配成功后，会创建一个 <code>DeferringRuleCall</code>，该类表示对 Rule 的调用，并且可以延迟执行。然后调用 <code>DeferringRuleCall#match</code> 方法应用当前匹配的规则，match 方法会调用 <code>VolcanoRuleCall#matchRecurse</code> 方法，如果规则匹配则会调用 onMatch 方法。<code>DeferringRuleCall#onMatch</code> 方法会匹配规则以及 RelNode 封装成 VolcanoRuleMatch，然后添加到 RuleQueue 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VolcanoRuleCall#matchRecurse 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">matchRecurse</span><span class="params">(<span class="type">int</span> solve)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;RelOptRuleOperand&gt; operands = getRule().operands;</span><br><span class="line">		<span class="comment">// 当求解顺序参数等于操作数时，判断当前 Rule 是否</span></span><br><span class="line">    <span class="keyword">if</span> (solve == operands.size()) &#123;</span><br><span class="line">        <span class="comment">// We have matched all operands. Now ask the rule whether it</span></span><br><span class="line">        <span class="comment">// matches; this gives the rule chance to apply side-conditions.</span></span><br><span class="line">        <span class="comment">// If the side-conditions are satisfied, we have a match.</span></span><br><span class="line">        <span class="keyword">if</span> (getRule().matches(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            onMatch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeferringRuleCall#onMatch 方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rather than invoking the rule (as the base method does), creates a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> VolcanoRuleMatch&#125; which can be invoked later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">VolcanoRuleMatch</span> <span class="variable">match</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolcanoRuleMatch</span>(volcanoPlanner, getOperand0(), rels, nodeInputs);</span><br><span class="line">    volcanoPlanner.ruleDriver.getRuleQueue().addMatch(match);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，setRoot 就完成了对 CsvTableScan 节点的处理，为 CsvTableScan 生成了 RelSet 和 RelSubset，并筛选了 CsvTableScan 匹配的规则。CsvTableScan 对应的 RelSubset 会以 inputs 的形式返回，提供给 LogicalFilter 作为子节点，LogicalFilter 仍然会按照前文介绍的 <code>onRegister</code> -&gt; <code>addRelToSet</code> -&gt; <code>fireRules</code> 的流程进行处理，并同样返回 RelSubset 作为 LogicalProject 的子节点。LogicalFilter 和 LogicalProject 由于 Convention 为 None，因此计算代价时，他们的代价为正无穷，执行完第一轮 setRoot 方法，最终会得到如下的 RelSubset 树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LogicalProject(subset=[rel#14:RelSubset#2.NONE.[]], EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], SLACKER=[$7], MANAGER=[$8], JOINEDAT=[$9])</span><br><span class="line">  LogicalFilter(subset=[rel#12:RelSubset#1.NONE.[]], condition=[=($1, &#x27;Alice&#x27;)])</span><br><span class="line">    CsvTableScan(subset=[rel#10:RelSubset#0.ENUMERABLE.[]], table=[[SALES, EMPS]], fields=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])</span><br></pre></td></tr></table></figure><p>RelSubset 树是通过成员变量 <code>final RelSet set</code> 变量实现，RelSet 中维护了当前 RelNode，通过 RelNode 的 input 维护了 RelSubset 子节点，以此类推，形成了一颗 RelSubset 树，整体结构如下图所示。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703810657.png" title="RelSubset 树结构"><h4 id="第二轮-setroot"><a class="markdownIt-Anchor" href="#第二轮-setroot"></a> 第二轮 setRoot</h4><p>在调用第二轮 setRoot 前，会优先判断当前 RelNode 的 Trait 是否和目标 Trait 相同，不相同则调用优化器的 <code>changeTraits</code> 方法变换特征。由于 RelNode 中的 Convention Trait 是 NONE，目标 Convention Trait 是 ENUMERABLE，因此会先调用 changeTraits 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">rootRel2</span> <span class="operator">=</span> rel.getTraitSet().equals(requiredOutputTraits) ? rel : planner.changeTraits(rel, requiredOutputTraits);</span><br></pre></td></tr></table></figure><h5 id="changetraits"><a class="markdownIt-Anchor" href="#changetraits"></a> changeTraits</h5><p>changeTraits 实现逻辑如下，会传入 RelNode 和期望的 RelTraitSet，然后先调用 ensureRegistered 确保所有的 RelNode 都注册成 RelSubset，然后调用 <code>getOrCreateSubset</code> 方法生成 RelTraitSet 对应的 RelSubset。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RelNode <span class="title function_">changeTraits</span><span class="params">(<span class="keyword">final</span> RelNode rel, RelTraitSet toTraits)</span> &#123;</span><br><span class="line">    <span class="type">RelSubset</span> <span class="variable">rel2</span> <span class="operator">=</span> ensureRegistered(rel, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (rel2.getTraitSet().equals(toTraits)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rel2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rel2.set.getOrCreateSubset(rel.getCluster(), toTraits, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，根节点 RelSubSet 的 Convention 已经变换为 ENUMERABLE，子节点 RelSubSet 的 Convention 仍然是 NONE，后续需要关注子节点 Convention 的变换时机。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703636903.png" title="根节点 RelSubSet Convention"><h5 id="registersubset"><a class="markdownIt-Anchor" href="#registersubset"></a> registerSubset</h5><p>由于经过了第一轮 setRoot 以及 changeTraits 处理，<code>rootRel2</code> 变成了一颗 RelSubset 树，在第二轮 setRoot 调用 registerImpl 时，由于 RelNode 已经是 RelSubset，因此会调用 registerSubset 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VolcanoPlanner#registerImpl 方法</span></span><br><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">registerImpl</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelSet set)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">        <span class="keyword">return</span> registerSubset(set, (RelSubset) rel);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerSubset 方法实现逻辑如下，首先会尝试对 RelSet 进行合并，由于当前案例中 <code>RelSet set</code> 为 null，未覆盖 merge 逻辑，后续我们会探索其他复杂案例的 RelSet 合并操作。<code>canonize</code> 方法用于处理当前 RelSubset 存在多个等价的 RelSubset 时，获取原始的 RelSubSet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">registerSubset</span><span class="params">(<span class="meta">@Nullable</span> RelSet set, RelSubset subset)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((set != subset.set) &amp;&amp; (set != <span class="literal">null</span>) &amp;&amp; (set.equivalentSet == <span class="literal">null</span>)) &#123;</span><br><span class="line">        LOGGER.trace(<span class="string">&quot;Register #&#123;&#125; &#123;&#125;, and merge sets&quot;</span>, subset.getId(), subset);</span><br><span class="line">        merge(set, subset.set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canonize(subset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If a subset has one or more equivalent subsets (owing to a set having</span></span><br><span class="line"><span class="comment"> * merged with another), returns the subset which is the leader of the</span></span><br><span class="line"><span class="comment"> * equivalence class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subset Subset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Leader of subset&#x27;s equivalence class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RelSubset <span class="title function_">canonize</span><span class="params">(<span class="keyword">final</span> RelSubset subset)</span> &#123;</span><br><span class="line">    <span class="type">RelSet</span> <span class="variable">set</span> <span class="operator">=</span> subset.set;</span><br><span class="line">    <span class="keyword">if</span> (set.equivalentSet == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环获取原始的 RelSet，然后创建对应 Trait 的 RelSubset</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        set = set.equivalentSet;</span><br><span class="line">    &#125; <span class="keyword">while</span> (set.equivalentSet != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> set.getOrCreateSubset(subset.getCluster(), subset.getTraitSet(), subset.isRequired());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ensurerootconverters"><a class="markdownIt-Anchor" href="#ensurerootconverters"></a> ensureRootConverters</h5><p>最后会执行 <code>ensureRootConverters</code> 方法，确保根节点的等价集合都包含了 <code>AbstractConverter</code>，以便于发现代价更小的实现时，能够将 RelSubset 转换为根节点。ensureRootConverters 方法实现逻辑如下，如果根节点中记录的等价关系代数 RelNode 已经是 AbstractConverter，则直接添加到 subsets 集合中。然后判断根节点的所有 RelSubset，如果发现 <code>root trait</code> 和 <code>subset trait</code> 不同时，将会注册一个 AbstractConverter（AbstractConverter 是一个 RelNode，用于将一个关系代数转换为指定 Convention 的关系代数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that the subset that is the root relational expression contains</span></span><br><span class="line"><span class="comment"> * converters to all other subsets in its equivalence set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Thus the planner tries to find cheap implementations of those other</span></span><br><span class="line"><span class="comment"> * subsets, which can then be converted to the root. This is the only place</span></span><br><span class="line"><span class="comment"> * in the plan where explicit converters are required; elsewhere, a consumer</span></span><br><span class="line"><span class="comment"> * will be asking for the result in a particular convention, but the root has</span></span><br><span class="line"><span class="comment"> * no consumers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureRootConverters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;RelSubset&gt; subsets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (RelNode rel : root.getRels()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> AbstractConverter) &#123;</span><br><span class="line">            subsets.add((RelSubset) ((AbstractConverter) rel).getInput());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RelSubset subset : root.set.subsets) &#123;</span><br><span class="line">        <span class="keyword">final</span> ImmutableList&lt;RelTrait&gt; difference = root.getTraitSet().difference(subset.getTraitSet());</span><br><span class="line">      	<span class="comment">// 当 root trait 和 subset trait 不同时，注册一个 AbstractConverter（AbstractConverter 是一个 RelNode）</span></span><br><span class="line">        <span class="keyword">if</span> (difference.size() == <span class="number">1</span> &amp;&amp; subsets.add(subset)) &#123;</span><br><span class="line">            register(<span class="keyword">new</span> <span class="title class_">AbstractConverter</span>(subset.getCluster(), subset, difference.get(<span class="number">0</span>).getTraitDef(), root.getTraitSet()), root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用 register 方法，分别将 AbstractConverter 和 root 节点作为参数传入，然后调用 ensureRegistered 方法将 RelNode 注册为 RelSubset，此处 root 节点已经为 RelSubset，所以会直接返回，并获取到 RelSubset 对应的 RelSet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RelSubset <span class="title function_">register</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelNode equivRel)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> RelSet set;</span><br><span class="line">    <span class="keyword">if</span> (equivRel == <span class="literal">null</span>) &#123;</span><br><span class="line">        set = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        equivRel = ensureRegistered(equivRel, <span class="literal">null</span>);</span><br><span class="line">        set = getSet(equivRel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registerImpl(rel, set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后逻辑会再次调用到 registerImpl 方法，当发现当前节点是 Converter 时，会尝试将 Converter merge 到 Converter 子节点的 RelSet 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RelSubset <span class="title function_">registerImpl</span><span class="params">(RelNode rel, <span class="meta">@Nullable</span> RelSet set)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Converters are in the same set as their children.</span></span><br><span class="line">    <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">input</span> <span class="operator">=</span> ((Converter) rel).getInput();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelSet</span> <span class="variable">childSet</span> <span class="operator">=</span> castNonNull(getSet(input));</span><br><span class="line">      	<span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> ((set != <span class="literal">null</span>) &amp;&amp; (set != childSet) &amp;&amp; (set.equivalentSet == <span class="literal">null</span>)) &#123;</span><br><span class="line">            merge(set, childSet);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set = childSet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二轮 setRoot 结束后，RelSubset 的树形结构如下图所示，根节点的 Convention 变成了 ENUMERABLE，根节点 RelSet 中记录的 rels 增加了 AbstractConverter，subsets 增加了 Convention 为 ENUMERABLE 的 RelSubset，其他子节点的信息和第一轮 setRoot 一致。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703810113.jpg" title="第二轮 setRoot RelSubset 树形结构"><h3 id="findbestexp-流程"><a class="markdownIt-Anchor" href="#findbestexp-流程"></a> findBestExp 流程</h3><p>完成了 setRoot 流程后，最后一步就是调用 <code>findBestExp</code> 方法，根据 setRoot 阶段生成的 RelSubset 树以及其中记录的代价信息，寻找最优的执行计划。下面是 findBestExp 方法的实现，核心的处理逻辑主要是 <code>ruleDriver.drive()</code> 和 <code>buildCheapestPlan</code> 方法，<code>ruleDriver.drive()</code> 负责从 ruleQueue 中取出匹配的规则并进行关系代数变换，并和之前的代价进行比较以寻找每一个节点的最小代价实现。<code>buildCheapestPlan</code> 方法则遍历整个 RelSubset 树，寻找出全局最优的执行计划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the most efficient expression to implement the query given via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.calcite.plan.RelOptPlanner#setRoot(org.apache.calcite.rel.RelNode)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the most efficient RelNode tree found for implementing the given</span></span><br><span class="line"><span class="comment"> * query</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RelNode <span class="title function_">findBestExp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> root != <span class="literal">null</span> : <span class="string">&quot;root must not be null&quot;</span>;</span><br><span class="line">    <span class="comment">// 确保所有等价集都包含 AbstractConverter，以便于发现代价更小的实现时，能够将 RelSubset 转换为根节点</span></span><br><span class="line">    ensureRootConverters();</span><br><span class="line">  	<span class="comment">// 注册物化视图相关的关系代数，本文暂时不涉及，后续文章会单独解读物化视图和 Lattice 格</span></span><br><span class="line">    registerMaterializations();</span><br><span class="line">    <span class="comment">// 寻找最优 plan，即 cost 最小的 plan，先找到每个节点的最优 plan，然后构建全局最优 plan</span></span><br><span class="line">    <span class="comment">// ruleDriver 包括 IterativeRuleDriver 和 TopDownRuleDriver 两种，本文案例使用的是 IterativeRuleDriver</span></span><br><span class="line">    ruleDriver.drive();</span><br><span class="line">    <span class="comment">// 构建全局最优 plan</span></span><br><span class="line">    <span class="type">RelNode</span> <span class="variable">cheapest</span> <span class="operator">=</span> root.buildCheapestPlan(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cheapest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="drive"><a class="markdownIt-Anchor" href="#drive"></a> drive</h4><p>本文案例中 <code>driver</code> 的实现类为 <code>IterativeRuleDriver</code>，该方法负责应用规则，按照优化规则对关系代数进行变换。<code>IterativeRuleDriver#drive</code> 方法实现逻辑如下，该方法使用了一个 <code>while(true)</code> 死循环，会不断地从 <code>ruleQueue</code> 中弹出规则，并调用 <code>VolcanoRuleMatch#onMatch</code> 方法对关系代数进行变换。当 ruleQueue 中没有匹配的规则，或者优化器抛出了 <code>VolcanoTimeoutException</code> 时，此时会中断循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 ruleQueue 中弹出匹配规则</span></span><br><span class="line">        <span class="type">VolcanoRuleMatch</span> <span class="variable">match</span> <span class="operator">=</span> ruleQueue.popMatch();</span><br><span class="line">        <span class="keyword">if</span> (match == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断规则是否匹配</span></span><br><span class="line">        <span class="keyword">assert</span> match.getRule().matches(match);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 onMatch 方法对关系代数进行变换</span></span><br><span class="line">            match.onMatch();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolcanoTimeoutException e) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;Volcano planning times out, cancels the subsequent optimization.&quot;</span>);</span><br><span class="line">            planner.canonize();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The root may have been merged with another subset. Find the new root subset.</span></span><br><span class="line">        planner.canonize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的案例中，preQueue 中记录了 2 个需要预先处理的匹配规则：<code>ExpandConversionRule</code> 和 <code>ProjectRemoveRule</code>，ruleQueue 包含了 4 个匹配规则，分别是 <code>EnumerableFilterRule</code>、<code>ProjectFilterTransposeRule</code>、<code>EnumerableProjectRule</code> 和 <code>ExpandConversionRule</code>。</p><p>ExpandConversionRule 则用于将 AbstractConverter 转换为 converters 链，converters 链会将原始的关系代数转换到目标特征。ProjectRemoveRule 负责将仅返回其输入的 Project 节点转换为其子节点，例如：<code>Project(ArrayReader(a), &#123;$input0&#125;) becomes ArrayReader(a)</code>。</p><p>EnumerableFilterRule 和 EnumerableProjectRule 在 Calcite 中属于 <code>ConverterRule</code>，负责将 LogicalFilter、LogicalProject 转换为 EnumerableFilter 和 EnumerableProject。ProjectFilterTransposeRule 会将 Project 和 Filter 进行转置变换，属于 <code>TransformationRule</code>。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1703897196.png" title="ruleQueue 包含的 VolcanoRuleMatch"><p>从队列中弹出 <code>VolcanoRuleMatch</code> 后会调用 <code>VolcanoRuleMatch#onMatch</code> 方法进行关系代数变换，方法实现逻辑如下。VolcanoRuleMatch 继承了 <code>RelOptRuleCall</code>，RelOptRuleCall 代表了对 RelOptRule 的调用，并传递了一组关系表达式作为参数。开始 onMatch 前，会将当前的 VolcanoRuleCall 添加到 deque 头部，然后调用不同 rule 的 onMatch 方法，完成后 finally 代码块会从 deque 头部弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VolcanoRuleMatch 继承了 RelOptRuleCall，RelOptRuleCall 代表了对 RelOptRule 的调用，并传递了一组关系表达式作为参数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 遍历 VolcanoRuleMatch 中记录的 rels</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rels.length; i++) &#123;</span><br><span class="line">            <span class="type">RelNode</span> <span class="variable">rel</span> <span class="operator">=</span> rels[i];</span><br><span class="line">            <span class="comment">// 获取对应的 RelSubset</span></span><br><span class="line">            <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> volcanoPlanner.getSubset(rel);</span><br><span class="line">            <span class="comment">// 检查 subset 不能为空，并输出 debug 日志</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将当前的 VolcanoRuleCall 添加到 deque 头部，push 内部调用 addFirst</span></span><br><span class="line">        volcanoPlanner.ruleCallStack.push(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 VolcanoRuleCall 中缓存的 rule#onMatch 方法</span></span><br><span class="line">            getRule().onMatch(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 从 ruleCallStack 中弹出首个对象，调用 deque removeFirst 方法</span></span><br><span class="line">            volcanoPlanner.ruleCallStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error while applying rule &quot;</span> + getRule() + <span class="string">&quot;, args &quot;</span> + Arrays.toString(rels), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>EnumerableFilterRule</code> 为例，onMatch 方法会先调用 <code>convert</code> 方法，将 LogicalFilter 转换为 EnumerableFilter，然后调用 transformTo 方法对 RelNode 树进行变换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMatch</span><span class="params">(RelOptRuleCall call)</span> &#123;</span><br><span class="line">    <span class="type">RelNode</span> <span class="variable">rel</span> <span class="operator">=</span> call.rel(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rel.getTraitSet().contains(inTrait)) &#123;</span><br><span class="line">        <span class="comment">// 将 LogicalFilter 转换为 EnumerableFilter</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">converted</span> <span class="operator">=</span> convert(rel);</span><br><span class="line">        <span class="keyword">if</span> (converted != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 transformTo 方法对 RelNode 树进行变换</span></span><br><span class="line">            call.transformTo(converted);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VolcanoRuleCall#transformTo</code> 实现逻辑如下，由于 EnumerableFilter 是转换的节点，会调用 ensureRegistered 方法对该节点进行重新注册，此时会计算 EnumerableFilter 的代价，并更新 RelSubset 中记录的最小代价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transformTo</span><span class="params">(RelNode rel, Map&lt;RelNode, RelNode&gt; equiv, RelHintsPropagator handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 Hint 进行处理，将原始 RelNode 的 Hint 复制到新的 RelNode 中</span></span><br><span class="line">    rel = handler.propagate(rels[<span class="number">0</span>], rel);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Registering the root relational expression implicitly registers</span></span><br><span class="line">        <span class="comment">// its descendants. Register any explicit equivalences first, so we</span></span><br><span class="line">        <span class="comment">// don&#x27;t register twice and cause churn.</span></span><br><span class="line">        <span class="comment">// 遍历等价集，并进行注册，本案例中 EnumerableFilter 等价集合为空</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;RelNode, RelNode&gt; entry : equiv.entrySet()) &#123;</span><br><span class="line">            volcanoPlanner.ensureRegistered(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册 EnumerableFilter 并重新计算最小代价</span></span><br><span class="line">        <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> volcanoPlanner.ensureRegistered(rel, rels[<span class="number">0</span>]);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error occurred while applying rule &quot;</span> + getRule(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变换完成后 RelSubset 树更新了 bestCost，并且 rels 中同时记录了 LogicalFilter 和 EnumerableFilter。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1704158875.png" title="EnumerableFilterRule 变换后结构"><h4 id="buildcheapestplan"><a class="markdownIt-Anchor" href="#buildcheapestplan"></a> buildCheapestPlan</h4><p>变换完成后，会调用 <code>RelSubset#buildCheapestPlan</code> 方法构建代价最小的执行计划，buildCheapestPlan 方法实现逻辑如下，首先会初始化 CheapestPlanReplacer 类，它负责遍历 RelSubset 树并将每个节点替换为代价最小的 RelNode，遍历完成后返回全局最小代价的执行计划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursively builds a tree consisting of the cheapest plan at each node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RelNode <span class="title function_">buildCheapestPlan</span><span class="params">(VolcanoPlanner planner)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化树遍历器，会遍历 RelSubset 树并进行节点替换</span></span><br><span class="line">    <span class="type">CheapestPlanReplacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheapestPlanReplacer</span>(planner);</span><br><span class="line">    <span class="comment">// Replacer 内部维护了 final Map&lt;Integer, RelNode&gt; visited = new HashMap&lt;&gt;(); 记录当前节点是否遍历过</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">cheapest</span> <span class="operator">=</span> replacer.visit(<span class="built_in">this</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cheapest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CheapestPlanReplacer#visit</code> 是处理的核心逻辑，其实现细节如下，首先会根据 RelNode 的 Id 标识从 visited 中获取最优节点，如果当前节点已经遍历过则会直接返回。如果 visited 中未包含，则会判断节点是否为 RelSubset，案例中的节点已经都变换为 RelSubset，因此这一步会找出 RelSubset 中的最小代价 cheapest 进行替换。然后会继续遍历子节点寻找 cheapest 进行替换，替换后的子节点会和原子节点进行比对，不同则会将新的子节点复制到当前节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RelNode <span class="title function_">visit</span><span class="params">(RelNode p, <span class="type">int</span> ordinal, <span class="meta">@Nullable</span> RelNode parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 每一个 RelNode 都有个唯一 Id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pId</span> <span class="operator">=</span> p.getId();</span><br><span class="line">    <span class="comment">// 从 visited 中获取当前节点是否已经遍历过，如果遍历过则直接返回</span></span><br><span class="line">    <span class="type">RelNode</span> <span class="variable">prevVisit</span> <span class="operator">=</span> visited.get(pId);</span><br><span class="line">    <span class="keyword">if</span> (prevVisit != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// return memoized result of previous visit if available</span></span><br><span class="line">        <span class="keyword">return</span> prevVisit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前节点为 RelSubset，则进行进一步处理</span></span><br><span class="line">    <span class="keyword">if</span> (p <span class="keyword">instanceof</span> RelSubset) &#123;</span><br><span class="line">        <span class="type">RelSubset</span> <span class="variable">subset</span> <span class="operator">=</span> (RelSubset) p;</span><br><span class="line">        <span class="comment">// 获取 RelSubset 中记录的最优 plan</span></span><br><span class="line">        <span class="type">RelNode</span> <span class="variable">cheapest</span> <span class="operator">=</span> subset.best;</span><br><span class="line">        <span class="keyword">if</span> (cheapest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果获取不到最优 plan，则抛出异常</span></span><br><span class="line">            ...</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;Caught exception in class=&#123;&#125;, method=visit&quot;</span>, getClass().getName(), e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        p = cheapest;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取当前节点的子节点，进行遍历处理，获取最优 plan</span></span><br><span class="line">    List&lt;RelNode&gt; oldInputs = p.getInputs();</span><br><span class="line">    List&lt;RelNode&gt; inputs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldInputs.size(); i++) &#123;</span><br><span class="line">        <span class="type">RelNode</span> <span class="variable">oldInput</span> <span class="operator">=</span> oldInputs.get(i);</span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="type">RelNode</span> <span class="variable">input</span> <span class="operator">=</span> visit(oldInput, i, p);</span><br><span class="line">        inputs.add(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的子节点和老的子节点不同，则将新的子节点复制到当前节点中</span></span><br><span class="line">    <span class="keyword">if</span> (!inputs.equals(oldInputs)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelNode</span> <span class="variable">pOld</span> <span class="operator">=</span> p;</span><br><span class="line">        p = p.copy(p.getTraitSet(), inputs);</span><br><span class="line">        planner.provenanceMap.put(p, <span class="keyword">new</span> <span class="title class_">VolcanoPlanner</span>.DirectProvenance(pOld));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录到 visited</span></span><br><span class="line">    visited.put(pId, p); <span class="comment">// memoize result for pId</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，我们得到了如下的最优执行计划，Calcite 执行器会生成执行代码，执行并返回查询结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumerableFilter(condition=[=($1, &#x27;Alice&#x27;)])</span><br><span class="line">  CsvTableScan(table=[[SALES, EMPS]], fields=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])</span><br></pre></td></tr></table></figure><h3 id="整体流程总结"><a class="markdownIt-Anchor" href="#整体流程总结"></a> 整体流程总结</h3><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/1704245597.png" title="VolcanoPlanner 整体流程"><p>前文我们以简单的查询语句为例，一起探究了 VolcanoPlanner 优化器实现细节，想必大家阅读完一定有所收获。为了加深大家对优化器的理解，最后我们再进行一些梳理总结，上图展示了 VolcanoPlanner 优化器的整体流程，总体上可以分为三步：</p><ol><li>第一步：注册优化器规则。通过调用 <code>addRule</code> 方法，我们可以快速将优化器规则注册进来，这些规则会维护在 VolcanoPlanner 的 classOperands 对象中，后续筛选规则时会从该对象中获取规则；</li><li>第二步：初始化 <code>RelSubset</code>。这步会遍历逻辑计划树，将每个节点注册成为 RelSubset 并维护节点的代价信息，然后将逻辑计划树转换为 RelSubset 树，RelSubset 对象关联了所属的 <code>RelSet</code> 对象，该对象维护了当前节点的等价集合，RelSubset 中记录的是当前已知代价最小的关系代数。<code>fireRules</code> 方法负责筛选规则，会将匹配的规则添加到队列中；</li><li>第三步：查找最优计划。根据前文初始化的 RelSubset 树以及队列中记录的匹配规则，该步骤会调用 <code>drive</code> 方法应用规则，然后通过 <code>onMatch</code> 方法对关系代数进行变换，完成变换后会重新计算代价信息，并更新 RelSubset 和 RelSet 对象。最后会调用 buildCheapestPlan 方法，从 RelSubset 树中获取整体代价最小的执行计划。</li></ol><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>本文首先介绍了 Volcano/Cascades 优化器的理论基础，Volcano 优化器生成器论文中介绍的 <code>Logical Algebra</code>、<code>Physical Algebra</code>、<code>Transformation Rule</code>，以及 Cascades 优化器论文中介绍的 <code>Memo</code> 数据结构，<code>Pattern</code> 匹配规则等概念在 Calcite VolcanoPlanner 中都有体现，大家在阅读代码时可以参考论文中的概念进行理解。</p><p>然后介绍了 VolcanoPlanner 中的一些基础概念——RelNode、RelSet 和 RelSubset，理解了这些概念对学习 VolcanoPlanner 原理非常有帮助。同时，我们参考了 Julain 分享的 <a target="_blank" rel="noopener" href="https://calcite.apache.org/community/#cost-based-query-optimization-in-apache-phoenix-using-apache-calcite">Cost-based Query Optimization in Apache Phoenix using Apache Calcite</a>，提前了解了 VolcanoPlanner 的处理流程，整体上对优化流程有了一些了解。最后，本文结合一个简单的案例，深入 Calcite 源码细节，带领大家一起探究了整个流程。</p><p>限于文章的篇幅以及案例的选择，VolcanoPlanner 优化器的一些细节本文无法全面覆盖，还请各位读者多多包涵。下一篇文章，我们将关注 <strong>VolcanoPlanner 中的统计信息和代价模型，并会通过一个多表关联查询的案例，一起探究下 VolcanoPlanner 优化器是如何使用统计信息和代价模型进行代价计算，在多表关联查询 SQL 中，VolcanoPlanner 又会使用哪些优化方式得到最优执行计划</strong>。欢迎大家持续关注后续文章，如果有感兴趣的问题，也欢迎大家留言交流。</p><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">写在最后</span><span class="empty"></span></p></div><p>笔者因为工作原因接触到 Calcite，前期学习过程中，深感 Calcite 学习资料之匮乏，因此创建了 <a target="_blank" rel="noopener" href="https://wx.zsxq.com/dweb2/index/group/51128414222814">Calcite 从入门到精通知识星球</a>，希望能够将学习过程中的资料和经验沉淀下来，为更多想要学习 Calcite 的朋友提供一些帮助。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/deep-understand-of-apache-calcite-volcano-planner/202309210909027-20240207092016569.png" title="Calcite 从入门到精通"><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">欢迎关注</span><span class="empty"></span></p></div><p>欢迎关注「<strong>端小强的博客</strong>」微信公众号，会不定期分享日常学习和工作经验，欢迎大家关注交流。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/wechat/gongzhonghao.png" alt="微信公众号"></p><div class="article-footer fs14"><section id="references"><div class="header"><span>参考资料</span></div><div class="body"><ul><li class="post-title"><p><a target="_blank" rel="noopener" href="https://matt33.com/2019/03/17/apache-calcite-planner/">Apache Calcite 优化器详解（二）</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/640328243">万字详解 Calcite Volcano 优化器</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/283362100">Apache Calcite VolcanoPlanner 优化过程解析</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://aaaaaaron.github.io/2020/02/09/Calcite-Volcano-Planner/">Calcite Volcano Planner</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fxjwind/p/11325753.html">Calcite 分析 - Volcano 模型</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://note.youdao.com/s/2FGoKAwV">Traditional Query Optimization</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://cn.pingcap.com/blog/tidb-cascades-planner/">揭秘 TiDB 新优化器：Cascades Planner 原理解析</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2019/papers/22-optimizer1/graefe-icde1993.pdf">The Volcano Optimizer Generator: Extensibility and Efficient Search</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/15-optimizer1/graefe-ieee1995.pdf">The Cascades Framework for Query Optimization</a></p></li></ul></div></section><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">署名-非商业性使用-禁止演绎 4.0 国际</a> 许可协议，未经授权请勿转载。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner.html"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner.html&title=深入理解 Apache Calcite ValcanoPlanner 优化器 - 端小强的博客&pics=/assets/blog/2022/04/05/1649126780.jpg&summary=
注意：本文基于 Calcite 1.35.0 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。

 前言
在上一篇深入理解 Apache Calcite HepPlanner 优化器一文中，我..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=深入理解 Apache Calcite ValcanoPlanner 优化器 - 端小强的博客&amp;body=https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner.html"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://strongduanmu.com/blog/deep-understand-of-apache-calcite-volcano-planner.html"></div></div></section></div></article><div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/blog/cornerstone-of-cbo-optimization-apache-calcite-statistics-and-cost-model.html">CBO 优化的基石——Apache Calcite 统计信息和代价模型详解</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/blog/use-wireshark-to-solve-benchmarksql-exception-with-shardingsphere-proxy.html">使用 Wireshark 解决 BenchmarkSQL 压测 Proxy 异常</a></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="strongduanmu/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkzNzQwMDk3Njg=" data-category="Announcements" data-category-id="DIC_kwDOFkrvqM4CZIsa" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">文档</span><a href="/wiki/calcite/background.html">Calcite</a><a href="/wiki/cmu_15_445/index.html">CMU 15-445</a><a href="/wiki/cmu_15_721/index.html">CMU 15-721</a></div><div class="sitemap-group"><span class="fs15">便笺</span><a href="/notes/">Common</a><a href="/notes/docker.html">Docker</a><a href="/notes/git.html">Git</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/more/">关于</a><a href="/more/news/">动态</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://github.com/strongduanmu">@strongduanmu</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建，使用 <a target="_blank" rel="noopener" href="https://vercel.com/">Vercel</a> 网站部署。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br>本站总访问量 <span id="vercount_value_site_pv"></span> 次，本站访客数 <span id="vercount_value_site_uv"></span> 人次。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volcanocascades-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">Volcano&#x2F;Cascades 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volcano-%E4%BC%98%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">Volcano 优化器生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cascades-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">Cascades 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#memo-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Memo 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rule-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">Rule 的改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pattern-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">Pattern 匹配规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#searching-algorithm"><span class="toc-text">Searching Algorithm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volcanoplanner-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-text">VolcanoPlanner 基础介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#relnode"><span class="toc-text">RelNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relset"><span class="toc-text">RelSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relsubset"><span class="toc-text">RelSubset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volcanoplanner-%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A7%98"><span class="toc-text">VolcanoPlanner 源码探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volcanoplanner-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">VolcanoPlanner 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setroot-%E6%B5%81%E7%A8%8B"><span class="toc-text">setRoot 流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%BD%AE-setroot"><span class="toc-text">第一轮 setRoot</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#onregister"><span class="toc-text">onRegister</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addreltoset"><span class="toc-text">addRelToSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#firerules"><span class="toc-text">fireRules</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%BD%AE-setroot"><span class="toc-text">第二轮 setRoot</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#changetraits"><span class="toc-text">changeTraits</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#registersubset"><span class="toc-text">registerSubset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ensurerootconverters"><span class="toc-text">ensureRootConverters</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findbestexp-%E6%B5%81%E7%A8%8B"><span class="toc-text">findBestExp 流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#drive"><span class="toc-text">drive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buildcheapestplan"><span class="toc-text">buildCheapestPlan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">整体流程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel blur"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"codeblock":true,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"/assets/placeholder/avatar.svg",cover:"/assets/placeholder/cover.svg"},deps={jquery:"https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js",marked:"https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js"}</script><script>function RunItem(){function n(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let s=e,i=new n(s=r?()=>{utils.requestAnimationFrame(e)}:s,t);this.list.push(i)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,s)=>{var i,n,a=window.document,o=a.createElement("link"),d=(n=t||(i=(a.body||a.getElementsByTagName("head")[0]).childNodes)[i.length-1],a.styleSheets);if(s)for(var l in s)s.hasOwnProperty(l)&&o.setAttribute(l,s[l]);o.rel="stylesheet",o.href=e,o.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){n.parentNode.insertBefore(o,t?n:n.nextSibling)});function u(e){for(var t=o.href,r=d.length;r--;)if(d[r].href===t)return e();setTimeout(function(){u(e)})}function h(){o.addEventListener&&o.removeEventListener("load",h),o.media=r||"all"}return o.addEventListener&&o.addEventListener("load",h),o.onloadcssdefined=u,u(h),o},js:(i,n)=>new Promise((t,e)=>{var r=document.createElement("script");if(i.startsWith("/")&&(i=ctx.root+i.substring(1)),r.src=i,n)for(var s of Object.keys(n))r[s]=n[s];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(n,a,o,d)=>{let l=3;utils.onLoading(n),function i(){new Promise((t,e)=>{let r=0,s=setTimeout(()=>{0===r&&(r=2,s=null,e("请求超时"),0==l)&&d()},5e3);fetch(a).then(function(e){if(2!==r&&(clearTimeout(s),t(e),s=null,r=1),e.ok)return e.json();throw new Error("Network response was not ok.")}).then(function(e){l=0,utils.onLoadSuccess(n),o(e)}).catch(function(e){0<l?(--l,setTimeout(()=>{i()},5e3)):(utils.onLoadFailure(n),d())})})}()},requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script src="/js/main.js?v=1.30.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e),applyThemeToGiscus(e)},applyThemeToGiscus=e=>{e="auto"===e?"preferred_color_scheme":e;var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let n=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<n.length;++e){var s=n[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=o(i)+":"+o(t)}}function o(e){return e<10?"0"+e:e}0<n.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="/js/flying-pages.min.js"></script><script defer src="/js/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy"},window.addEventListener("LazyLoad::Initialized",function(n){window.lazyLoadInstance=n.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()})</script><script>ctx.fancybox={selector:"article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)",css:"/css/fancybox.min.css",js:"/js/fancybox.umd.min.js"};var selector="[data-fancybox]:not(.error)",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let e=document.getElementsByClassName("ds-memos");null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(e,t)=>t.triggerEl.alt||t.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let i=document.getElementById("swiper-api");null!=i&&(utils.css("/css/swiper-bundle.min.css"),utils.js("/js/swiper-bundle.min.js",{defer:!0}).then(function(){var e=i.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"复制代码",success_text:"复制成功",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script async>((a,t,c)=>{t.ChatraID="PHWnu7Bamcwtbnx2d";var h=a.createElement("script");t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},h.async=!0,h.src="https://call.chatra.io/chatra.js",a.head&&a.head.appendChild(h)})(document,window,"Chatra")</script><script defer src="https://cn.vercount.one/js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>window.va=window.va||function(){(window.vaq=window.vaq||[]).push(arguments)}</script><script defer src="/_vercel/insights/script.js"></script><script>window.si=window.si||function(){(window.siq=window.siq||[]).push(arguments)}</script><script defer src="/_vercel/speed-insights/script.js"></script><script>function change_banner(){$(".banner img.bg").attr("src","/assets/banner/banner_"+Math.floor(20*Math.random()+1)+".jpg")}setTimeout("change_banner()",250)</script><script>function add_page_pv(){$("#post-meta").after('<div class="flex-row" id="post-meta"><span class="text created">本文总阅读量 <span id="vercount_value_page_pv"></span> 次</span></div>')}setTimeout("add_page_pv()",500)</script><script>function change_img_alt(){$("article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)").each(function(t){$(this).after("<div class='image-meta' style='text-align:center;'><span class='image-caption center' style='display:inline-block;font-size:.8125rem;color:var(--text-p2);line-height:1.5;text-align:justify;'>"+($(this).attr("title")||$(this).attr("alt"))+"</span></div>")})}setTimeout("change_img_alt()",1e3)</script></div></body></html>