<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1" theme-name="Stellar" theme-version="1.30.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展 - 端小强的博客</title><meta name="description" content="注意：本文基于 Calcite main 分支 60e0a3f 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。   前言 最近，很多朋友咨询关于 Calcite UDF 实现和扩展的问题，在之前 Apache Calcite System Catalog 实现探究一文中，我们简单介绍过 Catalog 中的 Function 对象，也了解到 Calcit"><meta property="og:type" content="article"><meta property="og:title" content="Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展"><meta property="og:url" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"><meta property="og:site_name" content="端小强的博客"><meta property="og:description" content="注意：本文基于 Calcite main 分支 60e0a3f 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。   前言 最近，很多朋友咨询关于 Calcite UDF 实现和扩展的问题，在之前 Apache Calcite System Catalog 实现探究一文中，我们简单介绍过 Catalog 中的 Function 对象，也了解到 Calcit"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/calcite-function-inherit-class.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/scalar-function-inherit-class.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/aggregate-function-inherit-class.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/table-function-marco-inherit-class.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/function-parse-result.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/validated-sql-node.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/sql-operator-function-inherited-class.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/convertlet_table_map.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/concat_ws_function_call.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/select-user-defined-function-parse-result.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/lookup-user-defined-function.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/implement-scalar-function.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/udf-without-parentheses.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/udtf-parse-result.png"><meta property="og:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/validated-udtf-sqlnode.png"><meta property="og:image" content="https://strongduanmu.com/assets/xingqiu/calcite_xingqiu.png"><meta property="og:image" content="https://strongduanmu.com/assets/wechat/gongzhonghao.png"><meta property="article:published_time" content="2024-09-23T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-23T00:00:00.000Z"><meta property="article:author" content="端小强"><meta property="article:tag" content="Calcite"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension/calcite-function-inherit-class.png"><meta name="twitter:creator" content="@strongduanmu"><meta name="keywords" content="Calcite"><link rel="alternate" href="/atom.xml" title="端小强的博客" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=1.30.1"><link rel="shortcut icon" href="/assets/placeholder/favicon.ico"><meta name="baidu-site-verification" content="codeva-sIRwgTpHve"><link rel="apple-touch-icon" sizes="180x180" href="/assets/placeholder/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/placeholder/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/placeholder/favicon-16x16.png"><link rel="manifest" href="/assets/placeholder/site.webmanifest"><link rel="stylesheet" href="/css/custom.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaimono-bold.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaiscreen.css" media="all" onload='this.media="all"'></head><body><div class="l_body content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container"><header class="header"><div class="logo-wrap"><a class="avatar" href="/more/"><div class="bg" style="opacity:0;background-image:url(/assets/placeholder/rainbow64@3x.webp)"></div><img no-lazy class="avatar" src="/assets/placeholder/avatar.png" onerror="javascript:this.classList.add('error');this.src='/assets/placeholder/image.svg';"></a><a class="title" href="/"><div class="main" ff="title">端小强的博客</div><div class="sub normal cap">不积跬步，无以至千里 🤔</div><div class="sub hover cap" style="opacity:0">不积小流，无以成江海 😃</div></a></div></header><div class="nav-area"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><nav class="menu dis-select"><a class="nav-item active" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="文档" href="/wiki/"><span>文档</span></a><a class="nav-item" title="便笺" href="/notes/"><span>便笺</span></a><a class="nav-item" title="更多" href="/more/"><span>更多</span></a></nav></div><div class="widgets"><widget class="widget-wrapper markdown"><div class="widget-header dis-select"><span class="name">欢迎光临</span></div><div class="widget-body fs14"><p>欢迎访问端小强的博客，本人目前专注于 <a target="_blank" rel="noopener" href="https://github.com/apache/shardingsphere">Apache ShardingSphere</a> 内核模块开发，以及 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite">Apache Calcite</a> 查询优化技术的研究，本站会记录日常工作学习过程中的经验总结和知识梳理，欢迎大家留言交流。</p><div class="linklist center" style="grid-template-columns:repeat(1,1fr)"><a class="link" title="立即前往" href="/more/#comments"><div class="flex"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"></path><path fill="currentColor" d="M7.25 9A.75.75 0 0 1 8 8.25h8a.75.75 0 0 1 0 1.5H8A.75.75 0 0 1 7.25 9m0 3.5a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 0 1.5H8a.75.75 0 0 1-.75-.75"></path></svg><span>立即前往</span></div></a></div></div></widget><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">专栏：Calcite</span></div><div class="widget-body"><a class="item" href="/blog/apache-calcite-catalog-type-system-implementation.html"><span class="title">Apache Calcite Catalog 拾遗之类型系统实现</span></a><a class="item" href="/blog/using-calcite-as-an-example-to-explore-the-common-implementation-of-join-operators.html"><span class="title">以 Calcite 为例探究 Join 算子的常用实现</span></a><a class="item" href="/blog/explore-the-practice-of-apache-calcite-in-mycat2.html"><span class="title">Apache Calcite 在 MyCat2 中的实践探究</span></a><a class="item" href="/blog/calcite-udf-in-action-shardingsphere-sql-federation-adapte-to-mysql-bit-count.html"><span class="title">Calcite UDF 实战之 ShardingSphere 联邦查询适配 MySQL BIT_COUNT</span></a><a class="item active" href="/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"><span class="title">Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item" href="/blog/in-depth-exploration-of-implementation-principle-of-apache-calcite-sql-validator.html"><span class="title">深度探究 Apache Calcite SQL 校验器实现原理</span></a><a class="item" href="/blog/cornerstone-of-cbo-optimization-apache-calcite-statistics-and-cost-model.html"><span class="title">CBO 优化的基石——Apache Calcite 统计信息和代价模型详解</span></a><a class="item" href="/blog/deep-understand-of-apache-calcite-volcano-planner.html"><span class="title">深入理解 Apache Calcite ValcanoPlanner 优化器</span></a><a class="item" href="/blog/deep-understand-of-apache-calcite-hep-planner.html"><span class="title">深入理解 Apache Calcite HepPlanner 优化器</span></a><a class="item" href="/blog/explore-apache-calcite-system-catalog-implementation.html"><span class="title">Apache Calcite System Catalog 实现探究</span></a><a class="item" href="/blog/implementation-principle-of-apache-calcite-sql-parser.html"><span class="title">Apache Calcite SQL Parser 原理剖析</span></a><a class="item" href="/blog/apache-calcite-quick-start-guide.html"><span class="title">Apache Calcite 快速入门指南</span></a><a class="item" href="/blog/apache-calcite-learning-materials.html"><span class="title">Apache Calcite 学习资料整理</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="mailto:duanzhengqiang@apache.org" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/email.svg"></a><a class="social" href="https://github.com/strongduanmu" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/github.svg"></a><a class="social" href="/sitemap.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/sitemap.svg"></a><a class="social" href="/atom.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/rss.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/banner/banner_9.jpg"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/blog/apache-calcite-catalog-type-system-implementation.html">Calcite</a></div><div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-09-23T00:00:00.000Z">2024-09-23</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-10-23T00:00:00.000Z">2024-10-23</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展</span></h1></div></div></div></div><article class="md-text content"><blockquote><p>注意：本文基于 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/commit/60e0a3f441a009e55a36cac192253a436bec3f6d">Calcite main 分支 60e0a3f</a> 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者<strong>请注意版本选择</strong>。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近，很多朋友咨询关于 <code>Calcite UDF</code> 实现和扩展的问题，在之前 <a href="https://strongduanmu.com/blog/explore-apache-calcite-system-catalog-implementation.html">Apache Calcite System Catalog 实现探究</a>一文中，我们简单介绍过 <code>Catalog</code> 中的 <code>Function</code> 对象，也了解到 Calcite 内置了很多函数实现，但在实际使用中内置函数往往无法满足要求，用户需要能够根据自己的需求，灵活地注册新的函数。Caclite 允许用户动态注册 UDF 函数，从而实现更加复杂的 SQL 逻辑，下面本文将深入探讨 Calcite 函数的实现原理，以及 UDF 函数的扩展方式，帮助大家更好地在项目中使用 Calcite UDF。</p><h2 id="calcite-函数简介"><a class="markdownIt-Anchor" href="#calcite-函数简介"></a> Calcite 函数简介</h2><p>在日常开发、数据分析工作中，我们除了会使用常用的 SQL 语句外，还会经常用到函数来实现一些特殊功能，函数功能的强弱直接会影响我们的开发效率。Calcite 作为当前流行的计算引擎，对函数功能也有较好的支持，它内置了不同数据库的上百种常用函数，可以直接调用执行。此外，Calcite 也提供了 UDF 自定义函数能力，用户可以通过 Schema 注册 UDF，从而实现更灵活地 SQL 运算逻辑。</p><p>在了解 UDF 函数实现和扩展前，我们先来了解下 Calcite 函数的基本概念。Calcite 对函数的定义是：<strong>接受参数并返回结果的命名表达式</strong>，函数一般通过 Schema 进行注册，然后使用 <code>Schema#getFunctions</code> 获取函数，获取函数时会根据参数类型进行过滤。下面是 Schema 中 <code>Function</code> 接口声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    List&lt;FunctionParameter&gt; <span class="title function_">getParameters</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function 接口提供了 <code>getParameters</code> 获取函数参数的方法，它包含了 <code>ScalarFunction</code>、<code>AggregateFunction</code>、<code>TableFunction</code> 和 <code>TableMarco</code> 等几个主要的子接口。ScalarFunction 对应标量函数，也就是函数返回的结果为一个标量，AggregateFunction 对应聚合函数，会将多个值聚合计算为一个标量返回。</p><p>TableFunction 和 TableMacro 都对应了表函数，会返回一个表，他们的区别是 TableMacro 会在编译期间进行调用，编译期展开表达式允许 Calcite 实现更加强大的查询优化，例如我们可以对视图在编译期进行展开。相比于 TableMacro，TableFunction 则需要在执行阶段才能知道表的结果。</p><p>下图展示了 Function 的继承体系，Function 接口的 4 个子接口 <code>ScalarFunction</code>、<code>AggregateFunction</code>、<code>TableFunction</code> 和 <code>TableMarco</code>，他们都有对应的 <code>Impl</code> 实现类，实现类中定义了很多函数处理相关的方法，下面小节我们将分别对这几类函数的内部实现进行探究。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/calcite-function-inherit-class.png" title="Calcite Function 继承体系"><h2 id="内置函数实现探究"><a class="markdownIt-Anchor" href="#内置函数实现探究"></a> 内置函数实现探究</h2><h3 id="标量函数"><a class="markdownIt-Anchor" href="#标量函数"></a> 标量函数</h3><p>标量函数（<code>ScalarFunction</code>）是指<strong>将输入数据转换为输出数据的函数，通常用于对单个字段值进行计算和转换</strong>。例如：<code>ABS(num)</code> 函数，它负责将每行输入的 <code>num</code> 字段值转换为绝对值再输出。</p><p>下图展示了标量函数在 Schema 对象中的继承体系，核心的实现逻辑在 <code>ScalarFunctionImpl</code> 类中，它实现了 <code>ScalarFunction</code> 和 <code>ImplementableFunction</code> 接口，并继承了 <code>ReflectiveFunctionBase</code> 抽象类，下面我们分别来介绍下这些接口和类的作用。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/scalar-function-inherit-class.png" title="标量函数继承体系"><ul><li>ScalarFunction 接口：</li></ul><p><code>ScalarFunction</code> 接口继承了 <code>Function</code> 接口，并在接口中声明了 <code>getReturnType</code> 方法，用于表示标量函数返回值的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function that returns a scalar result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScalarFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the return type of this function, constructed using the given</span></span><br><span class="line"><span class="comment">     * type factory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeFactory Type factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RelDataType <span class="title function_">getReturnType</span><span class="params">(RelDataTypeFactory typeFactory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ImplementableFunction 接口：</li></ul><p><code>ImplementableFunction</code> 接口用于声明该函数可以转换为 Java 代码进行执行，接口中提供了 <code>getImplementor</code> 方法，可以返回一个函数实现器 <code>CallImplementor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function that can be translated to java code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ScalarFunction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TableFunction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImplementableFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns implementor that translates the function to linq4j expression.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> implementor that translates the function to linq4j expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CallImplementor <span class="title function_">getImplementor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CallImplementor</code> 接口中声明了 <code>implement</code> 方法，可以将函数转换为 <code>linq4j</code> 表达式，用于函数逻辑的调用（<code>linq4j</code> 参考了 <code>.NET</code> 中的 <code>LINQ（Language-Integrated Query）</code> 功能，可以实现类似于 SQL 的声明式语法，后续我们专门写一篇文章介绍 <code>linq4j</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallImplementor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements a call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> translator Translator for the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> call Call that should be implemented</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nullAs The desired mode of &#123;<span class="doctag">@code</span> null&#125; translation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Translated call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Expression <span class="title function_">implement</span><span class="params">(RexToLixTranslator translator, RexCall call, RexImpTable.NullAs nullAs)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ReflectiveFunctionBase 抽象类：</li></ul><p><code>ReflectiveFunctionBase</code> 抽象类用于处理基于方法实现的函数，负责将方法参数映射为 <code>List&lt;FunctionParameter&gt;</code>。在初始化 ReflectiveFunctionBase 时，会传入函数逻辑对应的 <code>Method</code> 对象，<code>ParameterListBuilder</code> 类会根据 method 对象构造 <code>List&lt;FunctionParameter&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a ReflectiveFunctionBase.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method Method that is used to get type information from</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ReflectiveFunctionBase</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.method = method;</span><br><span class="line">    <span class="built_in">this</span>.parameters = builder().addMethodParameters(method).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParameterListBuilder</code> 类的核心逻辑为 <code>addMethodParameters</code> 方法，内部会遍历方法参数，通过 ReflectUtil 工具类获取参数名称（优先从 Parameter 注解中获取名称，无注解则使用参数名）和参数是否可选（优先从 Parameter 注解中获取是否可选，无注解则为 false），然后将 <code>type</code>、<code>name</code> 和 <code>optional</code> 参数传入 <code>add</code> 方法，用于创建 FunctionParameter 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ParameterListBuilder <span class="title function_">addMethodParameters</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        add(types[i], ReflectUtil.getParameterName(method, i), ReflectUtil.isParameterOptional(method, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add</code> 方法实现逻辑如下，主要将传入的 <code>type</code> 参数通过 <code>typeFactory</code> 构建为 <code>RelDataType</code> 类型，将 <code>name</code> 和 <code>optional</code> 封装到对应的 <code>FunctionParameter</code> 接口方法中。此外，还根据参数的个数生成了 <code>ordinal</code> 序号，并封装到 <code>getOrdinal</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ParameterListBuilder <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; type, <span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="type">boolean</span> optional)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ordinal</span> <span class="operator">=</span> builder.size();</span><br><span class="line">    builder.add(<span class="keyword">new</span> <span class="title class_">FunctionParameter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ordinal + <span class="string">&quot;: &quot;</span> + name + <span class="string">&quot; &quot;</span> + type.getSimpleName() + (optional ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基于 0 的参数序号</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrdinal</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数名称</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> RelDataType <span class="title function_">getType</span><span class="params">(RelDataTypeFactory typeFactory)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typeFactory.createJavaType(type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数是否可选，可选参数可以在函数调用时省略</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOptional</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> optional;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 FunctionParameter 构建逻辑外，ReflectiveFunctionBase 还提供了 <code>classHasPublicZeroArgsConstructor</code> 和 <code>classHasPublicFunctionContextConstructor</code> 方法，用于判断函数逻辑类是否提供了无关构造方法，以及包含 <code>FunctionContext</code>（提供函数调用的相关信息，可以使函数在构造期间提前执行，无需每次调用执行，具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/b2e9e6cba1e2ce28368d1281f527a9e53f4628ca/core/src/main/java/org/apache/calcite/schema/FunctionContext.java#L24-L85">FunctionContext</a>）的构造方法，这些构造方法会在函数初始化时进行调用，不包含可能会抛出异常。</p><ul><li>ScalarFunctionImpl 类：</li></ul><p><code>ScalarFunctionImpl</code> 类实现了 ScalarFunction 和 ImplementableFunction 接口中的相关方法，内部方法通过调用如下的私有构造方法进行初始化。如下展示了 ScalarFunctionImpl 了的构造方法，首先会调用 <code>super(method)</code> 初始化函数参数 <code>List&lt;FunctionParameter&gt;</code>，然后将函数实现器 CallImplementor 存储在成员变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ScalarFunctionImpl</span><span class="params">(Method method, CallImplementor implementor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(method);</span><br><span class="line">    <span class="built_in">this</span>.implementor = implementor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScalarFunctionImpl 核心的创建逻辑是由公共的 <code>create</code> 方法触发的，外部调用将函数方法 Method 对象传递给 <code>create</code> 方法。方法内部会先判断 Method 是否为静态方法，非静态方法如果没有无参构造方法，或者没有包含 FunctionContext 的构造方法，则会抛出异常。</p><p>如果检查通过，则根据 Method 对象创建 CallImplementor 函数实现器，然后调用私有的 ScalarFunctionImpl 构造方法，将 Method 对象和 CallImplementor 函数实现器传递给构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScalarFunction <span class="title function_">create</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStatic(method)) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">if</span> (!classHasPublicZeroArgsConstructor(clazz) &amp;&amp; !classHasPublicFunctionContextConstructor(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RESOURCE.requireDefaultConstructor(clazz.getName()).ex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">CallImplementor</span> <span class="variable">implementor</span> <span class="operator">=</span> createImplementor(method);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScalarFunctionImpl</span>(method, implementor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 CallImplementor 函数实现器的逻辑如下，首先会调用 <code>getNullPolicy</code> 方法，返回 <code>NullPolicy</code> 枚举类型用于描述函数（或运算符）何时返回 NULL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CallImplementor <span class="title function_">createImplementor</span><span class="params">(<span class="keyword">final</span> Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">NullPolicy</span> <span class="variable">nullPolicy</span> <span class="operator">=</span> getNullPolicy(method);</span><br><span class="line">    <span class="keyword">return</span> RexImpTable.createImplementor(<span class="keyword">new</span> <span class="title class_">ReflectiveCallNotNullImplementor</span>(method), nullPolicy, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NullPolicy</code> 枚举类包含了 <code>ALL</code>、<code>STRICT</code>、<code>SEMI_STRICT</code>、<code>ANY</code>、<code>ARG0</code> 和 <code>NONE</code>。<code>ALL</code> 表示只有所有的参数为 NULL，函数结果采返回 NULL。<code>STRICT</code> 表示只有一个参数为 NULL 使，函数结果返回 NULL。<code>SEMI_STRICT</code> 表示有 1 个或多个参数为 NULL 时，函数结果返回 NULL。<code>ANY</code> 表示只要有任意一个参数为 NULL，则函数结果返回 NULL，<code>ANY</code> 和 <code>STRICT</code> 比较类似，Caclite 更推荐使用 <code>STRICT</code> 类型。<code>ARG0</code> 表示第一个参数为 NULL 时，函数结果返回 NULL。<code>NONE</code> 表示不指定 NULL 策略，由函数逻辑进行处理。</p><p>这些枚举类型中，<code>STRICT</code>、<code>SEMI_STRICT</code> 比较常用，Calcite 分别为他们提供了 <code>Strict</code> 和 <code>SemiStrict</code> 注解，可以标注在函数方法或类上，用来声明 NULL 值策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">NullPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns null if and only if all of the arguments are null;</span></span><br><span class="line"><span class="comment">     * If all of the arguments are false return false otherwise true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALL,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns null if and only if one of the arguments are null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    STRICT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns null if one of the arguments is null, and possibly other times.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SEMI_STRICT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If any of the arguments are null, return null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ANY,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the first argument is null, return null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ARG0, NONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到 NullPolicy 后，调用 <code>RexImpTable.createImplementor()</code> 方法创建函数实现器，由于函数实现器中的 <code>implement</code> 方法在执行阶段才会调用，我们将在后面的 ScalarFunction 案例中进行详细介绍。</p><h3 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h3><p>聚合函数（<code>AggregateFunction</code>）是指<strong>将多个值组合转换为标量值输出的函数</strong>。例如：<code>SUM(num)</code> 函数，它负责将每行输入的 <code>num</code> 字段值进行累加，最终输出累加总和。</p><p>Calcite 聚合函数内部包含了一个累加过程，如下面的伪代码所示，<code>Accumulator</code> 累加器内部维护了一个 <code>sum</code> 变量，用于存储 <code>SUM</code> 函数计算的累加值。聚合函数调用 <code>init</code> 方法进行初始化，此时会创建一个累加器对象，并将 <code>sum</code> 初始化为 0，然后通过 <code>add</code> 方法将当前行的值添加到累加器中进行计算。如果有多个累加器，则可以使用 <code>merge</code> 方法将两个累加器中的值合二为一，最后计算完成可以通过 <code>result</code> 方法返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚合函数累加器</span></span><br><span class="line">struct Accumulator &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合函数初始化方法</span></span><br><span class="line">Accumulator <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Accumulator</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合函数累加方法</span></span><br><span class="line">Accumulator <span class="title function_">add</span><span class="params">(Accumulator a, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Accumulator</span>(a.sum + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合函数合并方法</span></span><br><span class="line">Accumulator <span class="title function_">merge</span><span class="params">(Accumulator a, Accumulator a2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Accumulator</span>(a.sum + a2.sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合函数获取结果方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">result</span><span class="params">(Accumulator a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了聚合函数在 Schema 对象中的继承体系，核心的实现逻辑在 <code>AggregateFunctionImpl</code> 类中，它实现了 <code>AggregateFunction</code> 和 <code>ImplementableAggFunction</code> 接口，下面我们分别来介绍下这些接口和类的作用。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/aggregate-function-inherit-class.png" title="聚合函数继承体系"><ul><li>AggregateFunction 接口：</li></ul><p><code>AggregateFunction</code> 接口继承了 <code>Function</code> 接口，并在接口中声明了 <code>getReturnType</code> 方法，用于表示聚合函数返回值的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function that combines several values into a scalar result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AggregateFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the return type of this function, constructed using the given</span></span><br><span class="line"><span class="comment">     * type factory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeFactory Type factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RelDataType <span class="title function_">getReturnType</span><span class="params">(RelDataTypeFactory typeFactory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ImplementableAggFunction 接口：</li></ul><p><code>ImplementableAggFunction</code> 接口用于声明该函数可以转换为 Java 代码进行执行，接口中提供了 <code>getImplementor</code> 方法，可以返回一个聚合函数实现器 <code>AggImplementor</code>，<code>windowContext</code> 用于标记当前聚合函数是否包含在窗口运算中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImplementableAggFunction</span> <span class="keyword">extends</span> <span class="title class_">AggregateFunction</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns implementor that translates the function to linq4j expression.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> windowContext true when aggregate is used in window context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> implementor that translates the function to linq4j expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AggImplementor <span class="title function_">getImplementor</span><span class="params">(<span class="type">boolean</span> windowContext)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AggImplementor</code> 接口可以实现聚合函数所需的初始化、累加以及获取结果方法，如下展示了 <code>AggImplementor</code> 接口中的方法，<code>getStateType</code> 方法可以返回聚合函数实现时，中间变量的类型，例如：字符串连接函数，它的中间变量类型可以是 StringBuilder。<code>implementReset</code>、<code>implementAdd</code> 和 <code>implementResult</code> 分别对应了聚合函数的初始化、累加和获取结果方法，AggImplementor 接口的实现类，会根据不同的聚合函数类型实现其逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AggImplementor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回聚合函数实现时，中间变量的类型</span></span><br><span class="line">    <span class="comment">// 例如：字符串连接函数，它的中间变量类型可以是 StringBuilder</span></span><br><span class="line">    List&lt;Type&gt; <span class="title function_">getStateType</span><span class="params">(AggContext info)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将中间变量重置为初识状态</span></span><br><span class="line">    <span class="comment">// 应使用 AggResetContext.accumulator() 来引用状态变量</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">implementReset</span><span class="params">(AggContext info, AggResetContext reset)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将新增加的当前值，累加到中间变量</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">implementAdd</span><span class="params">(AggContext info, AggAddContext add)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据中间变量计算结果值</span></span><br><span class="line">    Expression <span class="title function_">implementResult</span><span class="params">(AggContext info, AggResultContext result)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AggregateFunctionImpl 类：</li></ul><p><code>AggregateFunctionImpl</code> 类实现了 <code>AggregateFunction</code> 和 <code>ImplementableAggFunction</code> 接口，通过私有的构造方法进行初始化，构造方法如下，<code>declaringClass</code> 表示聚合函数对应的实现类，<code>params</code> 表示聚合函数的参数，<code>valueTypes</code> 表示聚合函数参数的类型，<code>accumulatorType</code> 表示聚合器的类型，<code>resultType</code> 表示函数结果类型。</p><p><code>initMethod</code>、<code>addMethod</code>、<code>mergeMethod</code> 和 <code>resultMethod</code> 分别表示聚合函数初始化方法、累加方法、合并方法和结果方法，<code>isStatic</code> 表示 <code>initMethod</code> 是否为静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">AggregateFunctionImpl</span><span class="params">(Class&lt;?&gt; declaringClass, List&lt;FunctionParameter&gt; params, List&lt;Class&lt;?&gt;&gt; valueTypes, Class&lt;?&gt; accumulatorType, Class&lt;?&gt; resultType, Method initMethod, Method addMethod, <span class="meta">@Nullable</span> Method mergeMethod, <span class="meta">@Nullable</span> Method resultMethod)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.declaringClass = declaringClass;</span><br><span class="line">    <span class="built_in">this</span>.valueTypes = ImmutableList.copyOf(valueTypes);</span><br><span class="line">    <span class="built_in">this</span>.parameters = params;</span><br><span class="line">    <span class="built_in">this</span>.accumulatorType = accumulatorType;</span><br><span class="line">    <span class="built_in">this</span>.resultType = resultType;</span><br><span class="line">    <span class="built_in">this</span>.initMethod = requireNonNull(initMethod, <span class="string">&quot;initMethod&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.addMethod = requireNonNull(addMethod, <span class="string">&quot;addMethod&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.mergeMethod = mergeMethod;</span><br><span class="line">    <span class="built_in">this</span>.resultMethod = resultMethod;</span><br><span class="line">    <span class="built_in">this</span>.isStatic = isStatic(initMethod);</span><br><span class="line">    <span class="keyword">assert</span> resultMethod != <span class="literal">null</span> || accumulatorType == resultType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 AggregateFunctionImpl 构造方法是私有的，通常 Calcite 内部都是通过 <code>create</code> 方法来创建 AggregateFunctionImpl 对象，<code>create</code> 方法实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an aggregate function, or returns null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> AggregateFunctionImpl <span class="title function_">create</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取函数类中的 init 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">initMethod</span> <span class="operator">=</span> ReflectiveFunctionBase.findMethod(clazz, <span class="string">&quot;init&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取函数类中的 add 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> ReflectiveFunctionBase.findMethod(clazz, <span class="string">&quot;add&quot;</span>);</span><br><span class="line">    <span class="comment">// merge 方法暂未实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">mergeMethod</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">// 获取函数类中的 result 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">resultMethod</span> <span class="operator">=</span> ReflectiveFunctionBase.findMethod(clazz, <span class="string">&quot;result&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (initMethod != <span class="literal">null</span> &amp;&amp; addMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A is return type of init by definition</span></span><br><span class="line">        <span class="comment">// A 表示 init 方法的返回类型</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; accumulatorType = initMethod.getReturnType();</span><br><span class="line">        <span class="comment">// R is return type of result by definition</span></span><br><span class="line">        <span class="comment">// R 表示 result 方法的返回类型</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMethod != <span class="literal">null</span> ? resultMethod.getReturnType() : accumulatorType;</span><br><span class="line">        <span class="comment">// V is remaining args of add by definition</span></span><br><span class="line">        <span class="comment">// V 表示 add 方法第一个参数之外的类型</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Class&gt; addParamTypes = ImmutableList.copyOf(addMethod.getParameterTypes());</span><br><span class="line">        <span class="comment">// 检查 add 方法第一个参数和累加器类型是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (addParamTypes.isEmpty() || addParamTypes.get(<span class="number">0</span>) != accumulatorType) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RESOURCE.firstParameterOfAdd(clazz.getName()).ex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ReflectiveFunctionBase.<span class="type">ParameterListBuilder</span> <span class="variable">params</span> <span class="operator">=</span> ReflectiveFunctionBase.builder();</span><br><span class="line">        <span class="keyword">final</span> ImmutableList.Builder&lt;Class&lt;?&gt;&gt; valueTypes = ImmutableList.builder();</span><br><span class="line">        <span class="comment">// 跳过第一个构造器参数，从第二个参数开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; addParamTypes.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> addParamTypes.get(i);</span><br><span class="line">            <span class="comment">// 调用 ReflectUtil 获取参数名称和参数是否可选标记，优先选择 Parameter 注解声明的信息</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ReflectUtil.getParameterName(addMethod, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">optional</span> <span class="operator">=</span> ReflectUtil.isParameterOptional(addMethod, i);</span><br><span class="line">            params.add(type, name, optional);</span><br><span class="line">            valueTypes.add(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如下展示了聚合函数中的方法和类型</span></span><br><span class="line">        <span class="comment">// A init()</span></span><br><span class="line">        <span class="comment">// A add(A, V)</span></span><br><span class="line">        <span class="comment">// A merge(A, A)</span></span><br><span class="line">        <span class="comment">// R result(A)        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AggregateFunctionImpl</span>(clazz, params.build(), valueTypes.build(), accumulatorType, resultType, initMethod, addMethod, mergeMethod, resultMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>create</code> 方法首先会从 <code>clazz</code> 类中获取 <code>init</code>、<code>add</code>、<code>merge</code> 和 <code>result</code> 对应的 Method 对象，目前 <code>merge</code> 方法仍然没有实现，<code>init</code> 和 <code>add</code> 方法是必须的，否则 <code>create</code> 方法会直接返回 null，外部调用的地方会判断是否允许函数为 null。</p><p>如果 <code>init</code> 和 <code>add</code> 方法不为 null，则会从 Method 对象中获取聚合函数相关的类型及参数信息，代码中使用 A 表示 init 方法的返回类型，使用 R 表示 result 方法的返回类型，使用 V 表示 add 方法第一个参数之外的类型，并检查 add 方法中的第一个参数是否和累加器类型一致，不一致则抛出异常。</p><p>然后循环 <code>add</code> 方法的参数，循环时会跳过第一个累加器参数，从第二个参数开始遍历，然后使用 <code>ReflectUtil</code> 优先从 <code>Parameter</code> 注解中获取参数名称和参数是否可选标记，循环过程中会把参数和参数类型存储在 params 和 valueTypes 中，最终所有的参数会传递给 <code>AggregateFunctionImpl</code> 私有构造方法，用于创建 AggregateFunctionImpl 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AggImplementor <span class="title function_">getImplementor</span><span class="params">(<span class="type">boolean</span> windowContext)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RexImpTable</span>.UserDefinedAggReflectiveImplementor(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AggregateFunctionImpl#getImplementor</code> 方法用于获取聚合函数实现器，参数 <code>windowContext</code> 表示当前是否是位于窗口运算中，聚合函数实现器直接调用了 <code>RexImpTable.UserDefinedAggReflectiveImplementor</code> 构造方法，并将当前的聚合函数实现类对象传递进去，实现器内部具体的逻辑，我们后文再详细分析，此处暂时跳过。</p><h3 id="表函数-表宏"><a class="markdownIt-Anchor" href="#表函数-表宏"></a> 表函数 &amp; 表宏</h3><p>表函数（<code>TableFunction</code>）是指<strong>在执行阶段将某些数据转换为表的函数</strong>，表宏（<code>TableMacro</code>）是指<strong>在编译阶段将某些数据转换为表的函数</strong>。表函数或者表宏，通常会使用在 FROM 子句中，作为一张表进行使用，例如：<code>SELECT * FROM XML_EXTRACT(&quot;/opt/csv/test.csv&quot;)</code>，<code>XML_EXTRACT</code> 就是一个表函数，它负责从 <code>test.csv</code> 文件中获取数据，并返回一张表。</p><p>下图展示了表函数和表宏在 Schema 对象中的继承体系，表函数的核心实现逻辑在 <code>TableFunctionImpl</code> 类中，它实现了 <code>ImplementableFunction</code> 和 <code>TableFunction</code> 接口，并继承了 <code>ReflectiveFunctionBase</code> 抽象类。表宏的核心实现逻辑在 <code>TableMarcoImpl</code> 类中，它实现了 <code>TableMarco</code> 接口，并继承了 <code>ReflectiveFunctionBase</code> 抽象类，下面我们分别来介绍下这些接口和类的作用。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/table-function-marco-inherit-class.png" title="表函数 &amp; 表宏继承体系"><ul><li>TableFunction 接口：</li></ul><p><code>TableFunction</code> 接口继承了 <code>Function</code> 接口，并在接口中声明了 <code>getRowType</code> 方法，用于表示表函数返回表的数据行类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="comment">// 使用指定参数产生的表对应的数据行类型</span></span><br><span class="line">    RelDataType <span class="title function_">getRowType</span><span class="params">(RelDataTypeFactory typeFactory, List&lt;? extends <span class="meta">@Nullable</span> Object&gt; arguments)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取表对应的数据行类型（Java 类型）</span></span><br><span class="line">    Type <span class="title function_">getElementType</span><span class="params">(List&lt;? extends <span class="meta">@Nullable</span> Object&gt; arguments)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TableFunctionImpl 类：</li></ul><p><code>TableFunctionImpl</code> 类实现了 <code>TableFunction</code> 和 <code>ImplementableFunction</code> 接口，并继承了 <code>ReflectiveFunctionBase</code> 抽象类，私有构造方法允许传入函数实现的 Method 对象，以及调用实现逻辑 CallImplementor，<code>super(method)</code> 会调用 ReflectiveFunctionBase 抽象类的方法，对函数参数进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">TableFunctionImpl</span><span class="params">(Method method, CallImplementor implementor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(method);</span><br><span class="line">    <span class="built_in">this</span>.implementor = implementor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造方法会被 <code>create</code> 方法调用，<code>create</code> 方法会传入一个 <code>Class</code> 对象，以及函数方法名 <code>methodName</code>，根据方法名会查找 <code>Method</code> 对象，如果对象为 null，则返回 TableFunction 为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> TableFunctionImpl&#125; from a class, looking for a method</span></span><br><span class="line"><span class="comment"> * with a given name. Returns null if there is no such method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> TableFunction <span class="title function_">create</span><span class="params">(Class&lt;?&gt; clazz, String methodName)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> findMethod(clazz, methodName);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Method</code> 对象存在，则继续判断方法是否为静态，如果是非静态方法，则需要提供无参的构造方法，否则抛出异常。此外，表函数返回值需要是 <code>QueryableTable</code> 或者 <code>ScannableTable</code> 类型，否则表函数直接返回 null。<code>Method</code> 对象检查满足条件后，则调用 <code>createImplementor</code> 创建方法实现器，再调用私有的 <code>TableFunctionImpl</code> 构造方法创建表函数对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> TableFunctionImpl&#125; from a method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> TableFunction <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Method method)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为非静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isStatic(method)) &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> method.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 非静态方法，如果没有公有的无参构造方法，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!classHasPublicZeroArgsConstructor(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RESOURCE.requireDefaultConstructor(clazz.getName()).ex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">    <span class="comment">// 如果表函数返回值不为 QueryableTable 或者 ScannableTable，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (!QueryableTable.class.isAssignableFrom(returnType) &amp;&amp; !ScannableTable.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建调用实现器</span></span><br><span class="line">    <span class="type">CallImplementor</span> <span class="variable">implementor</span> <span class="operator">=</span> createImplementor(method);</span><br><span class="line">    <span class="comment">// 创建 TableFunctionImpl 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableFunctionImpl</span>(method, implementor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TableMacro 接口：</li></ul><p><code>TableMacro</code> 和 <code>TableFunction</code> 接口类似，都继承了 <code>Function</code> 接口，但是它是在编译期间进行调用，如下展示了 TableMacro 接口提供的 <code>apply</code> 方法，它可以根据传入的参数转换为 TranslatableTable，通过 <code>TranslatableTable#toRel</code> 方法，可以得到 <code>RelNode</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableMacro</span> <span class="keyword">extends</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies arguments to yield a table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments Arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TranslatableTable <span class="title function_">apply</span><span class="params">(List&lt;? extends <span class="meta">@Nullable</span> Object&gt; arguments)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TableMacroImpl 类：</li></ul><p><code>TableMacroImpl</code> 类实现了 <code>TableMacro</code> 接口，并继承了 <code>ReflectiveFunctionBase</code> 抽象类，私有构造方法接受一个 Method 参数，并会调用 <code>super(method)</code> 方法，处理函数参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private constructor; use &#123;<span class="doctag">@link</span> #create&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">TableMacroImpl</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calcite 内部通过 <code>create</code> 方法创建 <code>TableMacro</code> 对象，和 <code>TableFunction</code> 一样，在创建之前会判断方法是否为非静态方法，非静态方法必须提供公有无参构造方法。然后检查 TableMacro 函数返回值，必须为 <code>TranslatableTable</code> 类型，否则返回 null，最后调用 <code>TableMacroImpl</code> 构造方法创建表宏对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> TableMacro&#125; from a method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> TableMacro <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Method method)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> method.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 非静态方法，必须提供公有无参构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isStatic(method)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!classHasPublicZeroArgsConstructor(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RESOURCE.requireDefaultConstructor(clazz.getName()).ex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">    <span class="comment">// 检查表宏返回值是否为 TranslatableTable</span></span><br><span class="line">    <span class="keyword">if</span> (!TranslatableTable.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableMacroImpl</span>(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TableMacroImpl 类中的 <code>apply</code> 方法负责调用 method 方法，并将参数 arguments 传递给该方法，最终会返回 <code>TranslatableTable</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> TranslatableTable <span class="title function_">apply</span><span class="params">(List&lt;? extends <span class="meta">@Nullable</span> Object&gt; arguments)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isStatic(method)) &#123;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; constructor = method.getDeclaringClass().getConstructor();</span><br><span class="line">            o = constructor.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (TranslatableTable) requireNonNull(method.invoke(o, arguments.toArray()), () -&gt; <span class="string">&quot;got null from &quot;</span> + method + <span class="string">&quot; with arguments &quot;</span> + arguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Expected &quot;</span> + Arrays.toString(method.getParameterTypes()) + <span class="string">&quot; actual &quot;</span> + arguments, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数执行流程"><a class="markdownIt-Anchor" href="#函数执行流程"></a> 函数执行流程</h3><p>前文我们介绍了标量函数、聚合函数、表函数和表宏中的核心类，下面我们将结合 Calcite 中的 CoreQuidemTest（该测试使用了 <a target="_blank" rel="noopener" href="https://github.com/julianhyde/quidem">quidem</a> 测试框架，可以像编写脚本一样编写测试程序），一起来看看 <code>functions.iq</code> 中的函数是如何执行的。下面的 SQL 取自 <code>functions.iq</code> 文件，它包含了 <code>concat_ws</code> 和 <code>cast</code> 两个函数，会将参数按照分隔符进行组装。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="built_in">cast</span>(<span class="keyword">null</span> <span class="keyword">as</span> <span class="type">varchar</span>), <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure><p>测试程序的入口在 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/9f231cc5b91b100b6a6fbc3cd6324873529dbf49/testkit/src/main/java/org/apache/calcite/test/QuidemTest.java#L223">QuidemTest#test</a> 方法，通过 <code>getPath</code> 获取 <code>functions.iq</code> 文件路径，然后调用 <code>checkRun</code> 中的 <code>new Quidem(config).execute()</code> 执行测试用例。我们可以在 <code>net/hydromatic/quidem/Quidem.java:285</code> 位置打断点，然后设置条件断点——<code>sqlCommand instanceof SqlCommand &amp;&amp; ((SqlCommand) sqlCommand).sql.equalsIgnoreCase(&quot;select concat_ws(',', 'a', cast(null as varchar), 'b')&quot;)</code>，这样可以跟踪上面测试 SQL 的 <code>checkResult</code> 断言逻辑。</p><h4 id="sqlvalidator-函数注册"><a class="markdownIt-Anchor" href="#sqlvalidator-函数注册"></a> SqlValidator 函数注册</h4><p>SQL 语句在 Calcite 中执行，首先会调用 <a target="_blank" rel="noopener" href="https://calcite.apache.org/avatica/">Avatica</a> 提供的 JDBC 接口，内部会对 SQL 语句进行解析，得到 SqlNode 对象。然后创建 <code>SqlValidator</code> 进行校验，校验器创建逻辑具体参考 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/b1308feff49c8b747b3bbb52e1519d334bc984ec/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java#L743">CalcitePrepareImpl#createSqlValidator</a>，首先会根据 <code>context.config()</code> 中配置的 <code>fun</code> 属性，获取对应方言中的函数或运算符，具体调用的方法是 <code>SqlLibraryOperatorTableFactory.INSTANCE.getOperatorTable()</code>，返回方言对应的函数、运算符表对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="meta">@PolyNull</span> T <span class="title function_">fun</span><span class="params">(Class&lt;T&gt; operatorTableClass, <span class="meta">@PolyNull</span> T defaultOperatorTable)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fun</span> <span class="operator">=</span> CalciteConnectionProperty.FUN.wrap(properties).getString();</span><br><span class="line">    <span class="keyword">if</span> (fun == <span class="literal">null</span> || fun.equals(<span class="string">&quot;&quot;</span>) || fun.equals(<span class="string">&quot;standard&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultOperatorTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Parse the libraries</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlLibrary&gt; libraryList = SqlLibrary.parse(fun);</span><br><span class="line">    <span class="comment">// Load standard plus the specified libraries. If &#x27;all&#x27; is among the</span></span><br><span class="line">    <span class="comment">// specified libraries, it is expanded to all libraries (except standard,</span></span><br><span class="line">    <span class="comment">// spatial, all).</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlLibrary&gt; libraryList1 = SqlLibrary.expand(ConsList.of(SqlLibrary.STANDARD, libraryList));</span><br><span class="line">    <span class="comment">// 根据 libraries 获取对应的 SqlLibraryOperatorTable</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlOperatorTable</span> <span class="variable">operatorTable</span> <span class="operator">=</span> SqlLibraryOperatorTableFactory.INSTANCE.getOperatorTable(libraryList1);</span><br><span class="line">    <span class="keyword">return</span> operatorTableClass.cast(operatorTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlLibraryOperatorTableFactory.INSTANCE.getOperatorTable()</code> 方法内部会遍历 <code>SqlLibraryOperators</code> 中的成员变量，获取类型为 <code>SqlOperator</code> 的变量，并判断 <code>LibraryOperator</code> 指定的方言和当前 <code>fun</code> 指定的方言是否一致，如果不匹配则继续比较方言继承的父类是否一致，一致则将 SqlOperator 添加到集合中，并组装为 SqlOperatorTable 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class aClass : classes) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : aClass.getFields()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqlOperator.class.isAssignableFrom(field.getType())) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">SqlOperator</span> <span class="variable">op</span> <span class="operator">=</span> (SqlOperator) requireNonNull(field.get(<span class="built_in">this</span>), () -&gt; <span class="string">&quot;null value of &quot;</span> + field + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                <span class="comment">// 判断 Library 是否一致</span></span><br><span class="line">                <span class="keyword">if</span> (operatorIsInLibrary(op.getName(), field, librarySet)) &#123;</span><br><span class="line">                    list.add(op);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Util.throwAsRuntime(Util.causeOrSelf(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未配置或配置为 <code>standard</code>，则使用 <code>SqlStdOperatorTable.instance()</code> 创建 <code>SqlOperatorTable</code> 标准函数、运算符表对象。然后会将 CalciteCatalogReader 对象添加到集合中，CalciteCatalogReader 对象也实现了 SqlOperatorTable 接口，提供了 <code>lookupOperatorOverloads</code> 查找 Schema 中注册的函数和运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlValidator <span class="title function_">createSqlValidator</span><span class="params">(Context context, CalciteCatalogReader catalogReader, UnaryOperator&lt;SqlValidator.Config&gt; configTransform)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 context.config() 中配置的 fun 属性，获取对应方言中的函数或运算符</span></span><br><span class="line">    <span class="comment">// 未配置或配置为 standard，则使用 SqlStdOperatorTable.instance() 创建的标准函数、运算符表对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlOperatorTable</span> <span class="variable">opTab0</span> <span class="operator">=</span> context.config().fun(SqlOperatorTable.class, SqlStdOperatorTable.instance());</span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlOperatorTable&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(opTab0);</span><br><span class="line">    <span class="comment">// 添加 catalogReader</span></span><br><span class="line">    list.add(catalogReader);</span><br><span class="line">    <span class="comment">// 组装为调用链 Chain</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlOperatorTable</span> <span class="variable">opTab</span> <span class="operator">=</span> SqlOperatorTables.chain(list);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">JavaTypeFactory</span> <span class="variable">typeFactory</span> <span class="operator">=</span> context.getTypeFactory();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CalciteConnectionConfig</span> <span class="variable">connectionConfig</span> <span class="operator">=</span> context.config();</span><br><span class="line">    <span class="keyword">final</span> SqlValidator.<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> configTransform.apply(SqlValidator.Config.DEFAULT.withLenientOperatorLookup(connectionConfig.lenientOperatorLookup()).withConformance(connectionConfig.conformance()).withDefaultNullCollation(connectionConfig.defaultNullCollation()).withIdentifierExpansion(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CalciteSqlValidator</span>(opTab, catalogReader, typeFactory, config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlOperatorTable</code> 对象实例是一个单例对象，只有在第一次执行 <code>ReflectiveSqlOperatorTable#init</code> 方法时才会创建，<code>init</code> 方法会使用反射获取 <code>SqlStdOperatorTable</code> 类中的成员变量，遍历时会判断变量是否使用 <code>LibraryOperator</code> 注解标注，对于有注解但是没有包含 STANDARD 类型的方言函数，直接跳过。处理完成后，会将 SqlOperator 构建为 Map 结果，key 为 SqlOperator 大写名称，value 为 SqlOperator 对象，并存储到 SqlStdOperatorTable 中的 operators 对象中，方便后续使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SqlOperatorTable <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Use reflection to register the expressions stored in public fields.</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlOperator&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Field field : getClass().getFields()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> field.get(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> SqlOperator) &#123;</span><br><span class="line">                <span class="comment">// Fields do not need the LibraryOperator tag, but if they have it,</span></span><br><span class="line">                <span class="comment">// we index them only if they contain STANDARD library.</span></span><br><span class="line">                <span class="comment">// 获取 LibraryOperator 注解，有注解但是没有 STANDARD 类型的函数为方言函数，直接跳过</span></span><br><span class="line">                <span class="type">LibraryOperator</span> <span class="variable">libraryOperator</span> <span class="operator">=</span> field.getAnnotation(LibraryOperator.class);</span><br><span class="line">                <span class="keyword">if</span> (libraryOperator != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.stream(libraryOperator.libraries()).noneMatch(library -&gt; library == SqlLibrary.STANDARD)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标准函数大多不用 LibraryOperator 注解标记，直接添加到集合中</span></span><br><span class="line">                list.add((SqlOperator) o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Util.throwAsRuntime(Util.causeOrSelf(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 SqlOperator 构建为 Map 结果，key 为 SqlOperator 大写名称，value 为 SqlOperator 对象</span></span><br><span class="line">    <span class="comment">// 存储到 SqlStdOperatorTable 中的 operators 对象中</span></span><br><span class="line">    setOperators(buildIndex(list));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了 CalciteSqlValidator 函数注册流程，函数和运算符会存储在 SqlOperatorTable 对象中，通过 <code>CalciteSqlValidator#getOperatorTable</code> 方法，可以快速获取到 SqlOperatorTable 进行函数和运算符查找。</p><h4 id="函数解析和校验"><a class="markdownIt-Anchor" href="#函数解析和校验"></a> 函数解析和校验</h4><p>函数注册完成后，按照 Calcite SQL 执行的流程，会先对 SQL 语句进行解析，下图展示了 SQL 中函数解析的结果，<code>CONCAT_WS</code> 函数被解析为 <code>SqlUnresolvedFunction</code>，它表示该函数在 SQL 解析阶段无法处理，需要通过校验器从 SqlOperatorTable 中查找对应的函数，并将其改写为对应的函数类型，<code>CAST</code> 函数被解析为 <code>SqlCastFunction</code>，在后续的校验阶段无需再进行处理。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/function-parse-result.png" title="函数解析结果"><p>那么，哪些函数会被解析为 <code>SqlUnresolvedFunction</code> 类型呢？根据 Julian 在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/73066108/calcite-does-not-return-correct-sqlkind">Calcite does not return correct SqlKind</a> 中的回答，所有函数在解析阶段都会被处理为 SqlUnresolvedFunction 类型，这样能够保持解析器简单、高效、可预测，在 Calcite 校验阶段，会从 SqlOperatorTable 中查找函数，并将 SqlUnresolvedFunction 转换为具体的 Function 对象。</p><p>但是实际上，从 Calcite <code>Parser.jj</code> 文件来看，不论是标准函数，还是方言函数，都有直接处理为具体 Function 对象的情况，SqlUnresolvedFunction 只是作为最后的处理方式。此外，SqlUnresolvedFunction 也适用于自定义函数场景，这些自定义函数，在 SQL 解析时是无法知道具体的函数对象。</p><p>完成 SQL 解析后，Calcite 会调用校验器对 SqlNode 语法树进行校验，参考<a href="https://strongduanmu.com/blog/in-depth-exploration-of-implementation-principle-of-apache-calcite-sql-validator.html#performunconditionalrewrites">深度探究 Apache Calcite SQL 校验器实现原理</a>一文，我们知道，在校验阶段执行 <code>performUnconditionalRewrites</code> 方法时，会判断当前运算符是否为 <code>SqlUnresolvedFunction</code>，如果是则调用 <code>SqlOperatorTable#lookupOperatorOverloads</code> 方法，从 SqlOperatorTable 中查找函数，查找的范围包括内置函数以及元数据中注册的函数，然后替换 SqlNode 中的函数对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前 SqlNode 是否为 SqlCall</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> SqlCall) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">SqlCall</span> <span class="variable">call</span> <span class="operator">=</span> (SqlCall) node;</span><br><span class="line">    <span class="comment">// 获取 SqlKind 类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlKind</span> <span class="variable">kind</span> <span class="operator">=</span> call.getKind();</span><br><span class="line">    <span class="comment">// 获取 SqlNode 中包含的运算符</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlNode&gt; operands = call.getOperandList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operands.size(); i++) &#123;</span><br><span class="line">        <span class="type">SqlNode</span> <span class="variable">operand</span> <span class="operator">=</span> operands.get(i);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 每一个运算法调用 performUnconditionalRewrites 并设置到 SqlCall 中</span></span><br><span class="line">        <span class="type">SqlNode</span> <span class="variable">newOperand</span> <span class="operator">=</span> performUnconditionalRewrites(operand, childUnderFrom);</span><br><span class="line">        <span class="keyword">if</span> (newOperand != <span class="literal">null</span> &amp;&amp; newOperand != operand) &#123;</span><br><span class="line">            call.setOperand(i, newOperand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前运算符为未解析函数 SqlUnresolvedFunction</span></span><br><span class="line">    <span class="keyword">if</span> (call.getOperator() <span class="keyword">instanceof</span> SqlUnresolvedFunction) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlUnresolvedFunction</span> <span class="variable">function</span> <span class="operator">=</span> (SqlUnresolvedFunction) call.getOperator();</span><br><span class="line">        <span class="keyword">final</span> List&lt;SqlOperator&gt; overloads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 从 SqlOperatorTable 中查找函数，查找的范围包括内置函数以及元数据中注册的函数</span></span><br><span class="line">        opTab.lookupOperatorOverloads(function.getNameAsId(), function.getFunctionType(), SqlSyntax.FUNCTION, overloads, catalogReader.nameMatcher());</span><br><span class="line">        <span class="keyword">if</span> (overloads.size() == <span class="number">1</span>) &#123;</span><br><span class="line">          	<span class="comment">// 查找到函数则设置新的运算符</span></span><br><span class="line">            ((SqlBasicCall) call).setOperator(overloads.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验完成后，可以看到 <code>SqlUnresolvedFunction</code> 被替换为 <code>SqlBasicFunction</code>，它是 SqlFunction 类的一个具体实现，主要用来处理常规的函数格式，例如：<code>NVL(value, value)</code>、<code>LENGTH(string)</code>、<code>LTRIM(string)</code> 等。而 <code>CAST(NULL AS VARCHAR)</code> 由于包含了类型信息，SqlBasicFunction 无法处理，因此需要额外定义一个 <code>SqlCastFunction</code>。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/validated-sql-node.png" title="检验后的 SqlNode"><p>刚好聊到 <code>SqlFunction</code> 对象，我们结合下图，一起来看看 <code>SqlOperator</code> 和 <code>SqlFunction</code> 继承体系。下图展示了部分 SqlFunction 实现类，除了我们刚刚介绍的 <code>SqlBasicFunction</code>、<code>SqlCastFunction</code> 和 <code>SqlUnresolvedFunction</code> 外，还有 <code>SqlUserDefinedFunction</code>、<code>SqlUserDefinedAggFunction</code>、<code>SqlUserDefinedTableFunction</code> 和 <code>SqlUserDefinedTableMacro</code>，他们用于处理用户自定义的函数。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/sql-operator-function-inherited-class.png" title="SqlOperator &amp; SqlFunction 继承体系"><ul><li>SqlOperator 抽象类：</li></ul><p><code>SqlOperator</code> 代表了 SQL 运算符，具体包括函数、运算符（例如：<code>=</code>）和语法结构（例如：<code>CASE</code> 语句），运算符可以表示查询级表达式（例如：<code>SqlSelectOperator</code>），也可以表示行级表达式（例如：<code>SqlBetweenOperator</code>）。</p><p>SqlOperator 不是 SQL 解析树中的 SqlNode 节点，它具体表示了 SqlNode 所对应的运算符类型。运算符中通常包含了若干个操作数，例如：除法运算符中包含两个操作数，分别是分子和分母，而在 SqlFunction 函数中，参数则是操作数。</p><p>如下展示了 SqlOperator 抽象类的核心字段和方法，包含了 <code>name</code>、<code>kind</code> 等表示名称、类型的基础字段，以及用于区分计算优先级的 <code>leftPrec</code> 和 <code>rightPrec</code>，此外，还包含了 <code>returnTypeInference</code>、<code>operandTypeInference</code> 字段，分别用于推断返回类型、操作数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlOperator</span> &#123;</span><br><span class="line">    <span class="comment">// 运算符/函数名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// SqlNode 类型，例如：EQUALS，可以使用 exp.isA(EQUALS) 判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SqlKind kind;</span><br><span class="line">    <span class="comment">// 运算符绑定到左侧表达式的优先级，如果运算符是左结合，则此优先级低于右侧优先级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> leftPrec;</span><br><span class="line">    <span class="comment">// 运算符绑定到右侧表达式的优先级，如果运算符是左结合，则此优先级高于右侧优先级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> rightPrec;</span><br><span class="line">    <span class="comment">// 推断运算符调用后的返回类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> SqlReturnTypeInference returnTypeInference;</span><br><span class="line">    <span class="comment">// 推断操作数的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> SqlOperandTypeInference operandTypeInference;</span><br><span class="line">    <span class="comment">// 用于校验操作数类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> SqlOperandTypeChecker operandTypeChecker;</span><br><span class="line">    <span class="comment">// 返回运算符的语法类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SqlSyntax <span class="title function_">getSyntax</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 推断运算符调用后的返回类型，仅在操作数的数量和类型校验后调用</span></span><br><span class="line">    <span class="keyword">public</span> RelDataType <span class="title function_">inferReturnType</span><span class="params">(SqlOperatorBinding opBinding)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SqlFunction 类：</li></ul><p><code>SqlFunction</code> 继承了 <code>SqlOperator</code>，是用来表示函数调用语法的运算符，SqlFunction 中额外维护了 <code>category</code> 和 <code>sqlIdentifier</code> 字段，category 表示函数的分类，主要包括：<code>STRING</code>、<code>NUMERIC</code>、<code>TIMEDATE</code>、<code>SYSTEM</code> 等函数类型，完整函数类型可查看 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/edbd35acf76dbd44cc148f036d0d02cbe2105c81/core/src/main/java/org/apache/calcite/sql/SqlFunctionCategory.java#L33">SqlFunctionCategory</a>，sqlIdentifier 表示函数的全限定名称，内置函数为 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlFunction</span> <span class="keyword">extends</span> <span class="title class_">SqlOperator</span> &#123;</span><br><span class="line">    <span class="comment">// SQL 函数分类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlFunctionCategory category;</span><br><span class="line">    <span class="comment">// 函数的全限定名称，内置函数为 null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> SqlIdentifier sqlIdentifier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">SqlFunction</span><span class="params">(String name, <span class="meta">@Nullable</span> SqlIdentifier sqlIdentifier, SqlKind kind, <span class="meta">@Nullable</span> SqlReturnTypeInference returnTypeInference, <span class="meta">@Nullable</span> SqlOperandTypeInference operandTypeInference, <span class="meta">@Nullable</span> SqlOperandTypeChecker operandTypeChecker, SqlFunctionCategory category)</span> &#123;</span><br><span class="line">        <span class="comment">// SqlFunction 默认传递给父类 SqlOperator 的 leftPrec 和 rightPrec 为 100</span></span><br><span class="line">        <span class="built_in">super</span>(name, kind, <span class="number">100</span>, <span class="number">100</span>, returnTypeInference, operandTypeInference, operandTypeChecker);</span><br><span class="line">        <span class="built_in">this</span>.sqlIdentifier = sqlIdentifier;</span><br><span class="line">        <span class="built_in">this</span>.category = requireNonNull(category, <span class="string">&quot;category&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取语法类型，SqlSyntax.FUNCTION 表示 Foo(x, y) 格式的函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSyntax <span class="title function_">getSyntax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSyntax.FUNCTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SqlBasicFunction 类：</li></ul><p><code>SqlBasicFunction</code> 类继承了 <code>SqlFunction</code>，它是常规函数（例如：<code>NVL(value, value)</code>、<code>LENGTH(string)</code>、<code>LTRIM(string)</code>）的具体实现类，由于该类字段都是 <code>final</code> 类型，因此 SqlFunction 对象是不可变的，只允许通过 <code>with</code> 方法修改字段，然后创建一个新的对象。</p><p>SqlBasicFunction 字段中记录了 SqlSyntax，允许注册不同类型的函数语法，全部语法类型可以参考 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/db60219198442f2c60345fda95a117d379d87a61/core/src/main/java/org/apache/calcite/sql/SqlSyntax.java#L28">SqlSyntax</a>。此外，还提供了 <code>deterministic</code> 和 <code>dynamic</code> 两个属性，<code>deterministic</code> 表示是否是确定函数，即：是否传入相同操作数时返回相同结果，默认为 true，<code>dynamic</code> 则表示是否是动态函数，即：是否传入相同操作数时返回不同结果，默认为 false，动态函数不能被缓存。<code>monotonicityInference</code> 是一个函数式接口，用于推测函数单调性的策略，入参是 SqlOperatorBinding，表示 SqlOperator 与操作数之间的绑定关系，出参则是 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/571731b80a58eb095ebac7123285c375e7afff90/core/src/main/java/org/apache/calcite/sql/validate/SqlMonotonicity.java#L22">SqlMonotonicity</a>，表示 SQL 中值的单调性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlBasicFunction</span> <span class="keyword">extends</span> <span class="title class_">SqlFunction</span> &#123;</span><br><span class="line">    <span class="comment">// 语法类型，可以使用 withSyntax 修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSyntax syntax;</span><br><span class="line">    <span class="comment">// 是否是确定函数，即：是否传入相同操作数时返回相同结果，默认为 true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> deterministic;</span><br><span class="line">    <span class="comment">// 操作数处理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlOperandHandler operandHandler;</span><br><span class="line">    <span class="comment">// 校验调用的策略，目前没有发现使用场景</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> callValidator;</span><br><span class="line">    <span class="comment">// 推断函数单调性的策略</span></span><br><span class="line">    <span class="comment">// 入参是 SqlOperatorBinding，表示 SqlOperator 与操作数之间的绑定关系</span></span><br><span class="line">    <span class="comment">// 出参是 SqlMonotonicity，表示 SQL 中值的单调性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;SqlOperatorBinding, SqlMonotonicity&gt; monotonicityInference;</span><br><span class="line">    <span class="comment">// 是否是动态函数，即：是否传入相同操作数时返回不同结果，默认为 false，动态函数不能被缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> dynamic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SqlCastFunction 类：</li></ul><p><code>SqlCastFunction</code> 类和 <code>SqlBasicFunction</code> 平级，都继承了 <code>SqlFunction</code>，它表示了常规函数之外的特殊函数，此处表示 <code>CAST(NULL AS VARCHAR)</code> 函数，其他特殊函数也有相应的函数类表示。</p><p>如下展示了 SqlCastFunction 中的核心方法，<code>getSignatureTemplate</code> 方法会返回一个模板，描述如何构建运算符签名，以 CAST 函数为例，<code>&#123;0&#125;</code> 表示运算符 CAST，<code>&#123;1&#125;</code>、<code>&#123;2&#125;</code>、<code>&#123;3&#125;</code> 是操作数。<code>getSyntax</code> 方法此处返回的是 <code>SqlSyntax.SPECIAL</code> 语法类型，它表示特殊语法，例如：CASE、CAST 运算符。<code>getMonotonicity</code> 方法用于获取函数的单调性，会根据函数操作数中配置的排序规则进行比较，如果排序规则的比较器不同，则返回 NOT_MONOTONIC，如果操作数的类型族包含在 <code>nonMonotonicCasts</code> 中，同样会返回 NOT_MONOTONIC 单调性，如果都不满足，则会返回第一个操作数的单调性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlCastFunction</span> <span class="keyword">extends</span> <span class="title class_">SqlFunction</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有不保持单调性的类型转换映射，getMonotonicity 方法根据 map 判断，包含在其中的，则返回 NOT_MONOTONIC</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SetMultimap&lt;SqlTypeFamily, SqlTypeFamily&gt; nonMonotonicCasts = ImmutableSetMultimap.&lt;SqlTypeFamily, SqlTypeFamily&gt;builder().put(SqlTypeFamily.EXACT_NUMERIC, SqlTypeFamily.CHARACTER).put(SqlTypeFamily.NUMERIC, SqlTypeFamily.CHARACTER).put(SqlTypeFamily.APPROXIMATE_NUMERIC, SqlTypeFamily.CHARACTER).put(SqlTypeFamily.DATETIME_INTERVAL, SqlTypeFamily.CHARACTER).put(SqlTypeFamily.CHARACTER, SqlTypeFamily.EXACT_NUMERIC).put(SqlTypeFamily.CHARACTER, SqlTypeFamily.NUMERIC).put(SqlTypeFamily.CHARACTER, SqlTypeFamily.APPROXIMATE_NUMERIC).put(SqlTypeFamily.CHARACTER, SqlTypeFamily.DATETIME_INTERVAL).put(SqlTypeFamily.DATETIME, SqlTypeFamily.TIME).put(SqlTypeFamily.TIMESTAMP, SqlTypeFamily.TIME).put(SqlTypeFamily.TIME, SqlTypeFamily.DATETIME).put(SqlTypeFamily.TIME, SqlTypeFamily.TIMESTAMP).build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法传入 name 和 kind，SAFE_CAST 和 CAST 类似，它转换失败时会返回 NULL，而不是异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlCastFunction</span><span class="params">(String name, SqlKind kind)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, kind, returnTypeInference(kind == SqlKind.SAFE_CAST), InferTypes.FIRST_KNOWN, <span class="literal">null</span>, SqlFunctionCategory.SYSTEM);</span><br><span class="line">        checkArgument(kind == SqlKind.CAST || kind == SqlKind.SAFE_CAST, kind);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个模板，描述如何构建运算符签名，以 CAST 函数为例，&#123;0&#125; 表示运算符 CAST，&#123;1&#125;、&#123;2&#125;、&#123;3&#125; 是操作数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSignatureTemplate</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> operandsCount)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> operandsCount &lt;= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;0&#125;(&#123;1&#125; AS &#123;2&#125; [FORMAT &#123;3&#125;])&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取语法类型，SqlSyntax.SPECIAL 表示特殊语法，例如：CASE、CAST 运算符</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSyntax <span class="title function_">getSyntax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSyntax.SPECIAL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlMonotonicity <span class="title function_">getMonotonicity</span><span class="params">(SqlOperatorBinding call)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个操作数类型，CAST 原始类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelDataType</span> <span class="variable">castFromType</span> <span class="operator">=</span> call.getOperandType(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取第一个操作数类型族</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelDataTypeFamily</span> <span class="variable">castFromFamily</span> <span class="operator">=</span> castFromType.getFamily();</span><br><span class="line">        <span class="comment">// 获取第一个操作数排序规则对应的排序器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Collator</span> <span class="variable">castFromCollator</span> <span class="operator">=</span> castFromType.getCollation() == <span class="literal">null</span> ? <span class="literal">null</span> : castFromType.getCollation().getCollator();</span><br><span class="line">        <span class="comment">// 获取第二个操作数类型，CAST 目标类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelDataType</span> <span class="variable">castToType</span> <span class="operator">=</span> call.getOperandType(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取第二个操作数类型族</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RelDataTypeFamily</span> <span class="variable">castToFamily</span> <span class="operator">=</span> castToType.getFamily();</span><br><span class="line">        <span class="comment">// 获取第二个操作数排序规则对应的排序器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Collator</span> <span class="variable">castToCollator</span> <span class="operator">=</span> castToType.getCollation() == <span class="literal">null</span> ? <span class="literal">null</span> : castToType.getCollation().getCollator();</span><br><span class="line">        <span class="comment">// 如果两个操作数的排序器不同，则返回 NOT_MONOTONIC</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(castFromCollator, castToCollator)) &#123;</span><br><span class="line">            <span class="comment">// Cast between types compared with different collators: not monotonic.</span></span><br><span class="line">            <span class="keyword">return</span> SqlMonotonicity.NOT_MONOTONIC;</span><br><span class="line">            <span class="comment">// 如果两个操作数的类型族包含在 nonMonotonicCasts 中，则返回 NOT_MONOTONIC</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (castFromFamily <span class="keyword">instanceof</span> SqlTypeFamily &amp;&amp; castToFamily <span class="keyword">instanceof</span> SqlTypeFamily &amp;&amp; nonMonotonicCasts.containsEntry(castFromFamily, castToFamily)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SqlMonotonicity.NOT_MONOTONIC;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则返回第一个操作数的单调性策略</span></span><br><span class="line">            <span class="keyword">return</span> call.getOperandMonotonicity(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以上介绍的 <code>SqlOperator</code>、<code>SqlFunction</code>、<code>SqlBasicFunction</code> 以及 <code>SqlCastFunction</code>，其他的函数运算符，大家可以根据兴趣进行探索，本文就不再一一介绍，下面的小节，我们将继续跟踪函数语句的执行。</p><h4 id="sql-优化和函数执行"><a class="markdownIt-Anchor" href="#sql-优化和函数执行"></a> SQL 优化和函数执行</h4><p>完成 SQL 语句的解析和校验后，我们就得到了一个包含不同 SqlFunction 运算符的 SqlNode 语法树，Caclite JDBC 流程会调用 <code>sqlToRelConverter.convertQuery(sqlQuery, needsValidation, true)</code>，将 SqlNode 转换为关系代数表达式 RelNode。</p><p>由于示例 SQL 中的函数位于投影列中，因此我们只需要关注 Projection 转换逻辑即可，下面展示了 <code>SqlToRelConverter#convertSelectList</code> 的部分转换逻辑，投影列会调用 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/98b252b36c84c4715c5bbe8c8a65355c103b3f9e/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java#L5116">Blackboard</a> 对象的 <code>convertExpression</code> 方法，该类实现了 <code>SqlVisitor</code> 接口，可以用于遍历 AST 处理对应 SqlNode 转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project select clause.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (SqlNode expr : selectList) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlNode</span> <span class="variable">measure</span> <span class="operator">=</span> SqlValidatorUtil.getMeasure(expr);</span><br><span class="line">    <span class="keyword">final</span> RexNode e;</span><br><span class="line">    <span class="keyword">if</span> (measure != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 Blackboard 对象 convertExpression 方法，该类实现了 SqlVisitor，用于遍历 AST 处理对应 SqlCall 转换</span></span><br><span class="line">        e = bb.convertExpression(expr);</span><br><span class="line">    &#125;</span><br><span class="line">    exprs.add(e);</span><br><span class="line">    fieldNames.add(deriveAlias(expr, aliases, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>expr</code> 是一个 <code>SqlBasicCall</code>，遍历语法树时会调用 <code>visit(SqlCall call)</code> 方法，该方法内部会调用 <code>exprConverter.convertCall</code> 方法，exprConverter 对应的类是 <code>SqlNodeToRexConverter</code> 用于将 SqlNode 转换为 <code>RexNode</code> 行表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RexNode <span class="title function_">visit</span> <span class="params">(SqlCall call)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (agg != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlOperator</span> <span class="variable">op</span> <span class="operator">=</span> call.getOperator();</span><br><span class="line">        <span class="keyword">if</span> (window == <span class="literal">null</span> &amp;&amp; (op.isAggregator() || op.getKind() == SqlKind.FILTER || op.getKind() == SqlKind.WITHIN_DISTINCT || op.getKind() == SqlKind.WITHIN_GROUP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> requireNonNull(agg.lookupAggregates(call), () -&gt; <span class="string">&quot;agg.lookupAggregates for call &quot;</span> + call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 SqlNodeToRexConverter#convertCall 方法，SqlNodeToRexConverter 用于将 SqlNode 转换为 RexNode 行表达式</span></span><br><span class="line">    <span class="keyword">return</span> exprConverter.convertCall(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">SqlCallBinding</span>(validator(), scope, call).permutedCall());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlNodeToRexConverter#convertCall</code> 内部则是调用 <code>convertletTable</code> 获取 <code>SqlRexConvertlet</code>，然后调用 <code>SqlRexConvertlet#convertCall</code> 转换为 RexNode。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/convertlet_table_map.png" title="convertletTable 内部 map 维护的 SqlFunction 映射"><p><code>SqlRexConvertlet#convertCall</code> 通过反射调用 <code>StandardConvertletTable#convertFunction</code> 方法，<code>CONCAT_WS</code> 函数就会调用该方法进行转换，<code>CAST</code> 函数则会调用 <code>StandardConvertletTable#convertCast</code> 方法。Calcite 支持的运算符、函数转换逻辑，可以参考 <a target="_blank" rel="noopener" href="https://github.com/strongduanmu/calcite/blob/c8cb56525dbc908da4a9081f062d87adfe27ab80/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java#L120">StandardConvertletTable</a> 构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RexNode <span class="title function_">convertFunction</span><span class="params">(SqlRexContext cx, SqlFunction fun, SqlCall call)</span> &#123;</span><br><span class="line">    <span class="comment">// 转换操作数为 RexNode</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;RexNode&gt; exprs = convertOperands(cx, call, SqlOperandTypeChecker.Consistency.NONE);</span><br><span class="line">    <span class="keyword">if</span> (fun.getFunctionType() == SqlFunctionCategory.USER_DEFINED_CONSTRUCTOR) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeConstructorCall(cx, fun, exprs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RelDataType</span> <span class="variable">returnType</span> <span class="operator">=</span> cx.getValidator().getValidatedNodeTypeIfKnown(call);</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="literal">null</span>) &#123;</span><br><span class="line">        returnType = cx.getRexBuilder().deriveReturnType(fun, exprs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 RexBuilder#makeCall 转换</span></span><br><span class="line">    <span class="keyword">return</span> cx.getRexBuilder().makeCall(call.getParserPosition(), returnType, fun, exprs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换完成后，我们就得到了逻辑执行计划树 <code>RelNode Tree</code>，通过 <code>RelOptUtil.toString()</code> 方法输出，可以得到如下结构，<code>CONCAT_WS</code> 函数被转换为 <code>LogicalProject(EXPR$0=[CONCAT_WS(',', 'a', null:VARCHAR, 'b')])</code>，而 <code>CAST</code> 函数则转换为 <code>null:VARCHAR</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogicalProject(EXPR$0=[CONCAT_WS(&#x27;,&#x27;, &#x27;a&#x27;, null:VARCHAR, &#x27;b&#x27;)])</span><br><span class="line">  LogicalValues(tuples=[[&#123; 0 &#125;]])</span><br></pre></td></tr></table></figure><p>经过 Calcite 优化后，逻辑执行计划会被转换为物理执行计划，如下展示了逻辑执行计划的结构，<code>CONCAT_WS</code> 被转换为 <code>expr#5=[CONCAT_WS($t1, $t2, $t3, $t4)</code>，<code>CAST</code> 函数被转换为 <code>expr#3=[null:VARCHAR]</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumerableCalc(expr#0=[&#123;inputs&#125;], expr#1=[&#x27;,&#x27;], expr#2=[&#x27;a&#x27;], expr#3=[null:VARCHAR], expr#4=[&#x27;b&#x27;], expr#5=[CONCAT_WS($t1, $t2, $t3, $t4)], EXPR$0=[$t5])</span><br><span class="line">  EnumerableValues(tuples=[[&#123; 0 &#125;]])</span><br></pre></td></tr></table></figure><p>由于 Calcite JDBC 默认使用 <code>Enumerable</code> 调用约定，生成的物理运算符都是 <code>EnumerableRel</code>，调用 <code>implement</code> 方法执行时，会调用 <code>EnumerableInterpretable#toBindable</code> 方法生成 <code>Bindable</code> 对象，<a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/571731b80a58eb095ebac7123285c375e7afff90/core/src/main/java/org/apache/calcite/runtime/Bindable.java#L27">Bindable</a> 类可以绑定 DataContext 生成 Enumerable 进行执行。<code>EnumerableInterpretable#toBindable</code> 方法实现逻辑如下，它会调用 <code>implementRoot</code> 生成执行代码，然后使用 Janio 将代码库编译为 Bindable 实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bindable <span class="title function_">toBindable</span><span class="params">(Map&lt;String, Object&gt; parameters, CalcitePrepare.<span class="meta">@Nullable</span> SparkHandler spark, EnumerableRel rel, EnumerableRel.Prefer prefer)</span> &#123;</span><br><span class="line">    <span class="type">EnumerableRelImplementor</span> <span class="variable">relImplementor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnumerableRelImplementor</span>(rel.getCluster().getRexBuilder(), parameters);</span><br><span class="line">    <span class="comment">// 调用 implementRoot 生成执行代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassDeclaration</span> <span class="variable">expr</span> <span class="operator">=</span> relImplementor.implementRoot(rel, prefer);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Expressions.toString(expr.memberDeclarations, <span class="string">&quot;\n&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (spark != <span class="literal">null</span> &amp;&amp; spark.enabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> spark.compile(expr, s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 Janio 编译代码为 Bindable 实现类</span></span><br><span class="line">            <span class="keyword">return</span> getBindable(expr, s, rel.getRowType().getFieldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Helper.INSTANCE.wrap(<span class="string">&quot;Error while compiling generated Java code:\n&quot;</span> + s, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>implementRoot</code> 方法根据物理计划树进行遍历，首先调用 <code>EnumerableValues#implement</code> 方法，生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> org.apache.calcite.linq4j.Linq4j.asEnumerable(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会回到 <code>EnumerableCalc#implement</code> 继续执行，EnumerableValues 生成的结果会作为 EnumerableCalc 执行代码的一部分，EnumerableCalc 核心生成投影列函数执行代码的逻辑如下，会调用 <code>RexToLixTranslator#translateProjects</code> 方法进行转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnumerableValues#implement() 方法</span></span><br><span class="line">List&lt;Expression&gt; expressions = RexToLixTranslator.translateProjects(program, typeFactory, conformance, builder3, <span class="literal">null</span>, physType, DataContext.ROOT, <span class="keyword">new</span> <span class="title class_">RexToLixTranslator</span>.InputGetterImpl(input, result.physType), implementor.allCorrelateVariables);</span><br><span class="line">builder3.add(Expressions.return_(<span class="literal">null</span>, physType.record(expressions)));</span><br></pre></td></tr></table></figure><p><code>RexToLixTranslator#translateProjects</code> 内部则会继续调用 <code>RexToLixTranslator#translateList</code> 方法，translateList 方法会遍历运算符的操作数，此案例中操作数对象为 <code>RexLocalRef</code> 类型，内容为 <code>$t5</code>，表示引用 <code>expr#5=[CONCAT_WS($t1, $t2, $t3, $t4)]</code>，获取到 RexNode 后，会继续内部的调用 translate 方法，该方法内会使用 RexToLixTranslator（实现了 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/6f64865eb8c71a65bde60a19de2de42775fae4ed/core/src/main/java/org/apache/calcite/rex/RexVisitor.java#L33">RexVisitor</a> 接口）访问 RexNode，该方法会访问 <code>RexToLixTranslator#visitLocalRef</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Expression&gt; <span class="title function_">translateList</span><span class="params">(List&lt;? extends RexNode&gt; operandList, <span class="meta">@Nullable</span> List&lt;? extends <span class="meta">@Nullable</span> Type&gt; storageTypes)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Expression&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(operandList.size());</span><br><span class="line">    <span class="comment">// 遍历投影列操作数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operandList.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 返回 RexLocalRef 类型，内容为 $t5，表示引用 expr#5=[CONCAT_WS($t1, $t2, $t3, $t4)]</span></span><br><span class="line">        <span class="type">RexNode</span> <span class="variable">rex</span> <span class="operator">=</span> operandList.get(i);</span><br><span class="line">        <span class="type">Type</span> <span class="variable">desiredType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (storageTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">            desiredType = storageTypes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续调用 translate 方法转换函数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Expression</span> <span class="variable">translate</span> <span class="operator">=</span> translate(rex, desiredType);</span><br><span class="line">        list.add(translate);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Expression <span class="title function_">translate</span><span class="params">(RexNode expr, RexImpTable.NullAs nullAs, <span class="meta">@Nullable</span> Type storageType)</span> &#123;</span><br><span class="line">    currentStorageType = storageType;</span><br><span class="line">    <span class="comment">// 使用 RexToLixTranslator 遍历 RexNode，该方法会访问 RexToLixTranslator#visitLocalRef 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> expr.accept(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Expression</span> <span class="variable">translated</span> <span class="operator">=</span> requireNonNull(EnumUtils.toInternal(result.valueVariable, storageType));</span><br><span class="line">    <span class="comment">// When we asked for not null input that would be stored as box, avoid unboxing</span></span><br><span class="line">    <span class="keyword">if</span> (RexImpTable.NullAs.NOT_POSSIBLE == nullAs &amp;&amp; translated.type.equals(storageType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> translated;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullAs.handle(translated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitLocalRef</code> 方法会根据 <code>RexLocalRef</code> 中记录的引用下标，将对象转换为 <code>RexCall</code>，然后继续使用 RexToLixTranslator 进行访问，最终逻辑会执行到 <code>RexToLixTranslator#visitCall</code> 方法。正如下面 Calcite java doc 中说明的那样，大部分的运算符实现时都会从 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/60e0a3f441a009e55a36cac192253a436bec3f6d/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java#L521">RexImpTable</a> 中获取实现器，但也有些特殊的函数需要单独实现，例如 <code>CASE</code> 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visit &#123;<span class="doctag">@code</span> RexCall&#125;. For most &#123;<span class="doctag">@code</span> SqlOperator&#125;s, we can get the implementor</span></span><br><span class="line"><span class="comment"> * from &#123;<span class="doctag">@code</span> RexImpTable&#125;. Several operators (e.g., CaseWhen) with special semantics</span></span><br><span class="line"><span class="comment"> * need to be implemented separately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">visitCall</span><span class="params">(RexCall call)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从 RexImpTable 中获取运算符实现器</span></span><br><span class="line">    <span class="keyword">final</span> RexImpTable.<span class="type">RexCallImplementor</span> <span class="variable">implementor</span> <span class="operator">=</span> RexImpTable.INSTANCE.get(operator);</span><br><span class="line">    <span class="keyword">if</span> (implementor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot translate call &quot;</span> + call);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取操作数</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;RexNode&gt; operandList = call.getOperands();</span><br><span class="line">    <span class="keyword">final</span> List&lt;<span class="meta">@Nullable</span> Type&gt; storageTypes = EnumUtils.internalTypes(operandList);</span><br><span class="line">    <span class="keyword">final</span> List&lt;Result&gt; operandResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历操作数，调用各自的 implement 方法生成代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operandList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Result</span> <span class="variable">operandResult</span> <span class="operator">=</span> implementCallOperand(operandList.get(i), storageTypes.get(i), <span class="built_in">this</span>);</span><br><span class="line">        operandResults.add(operandResult);</span><br><span class="line">    &#125;</span><br><span class="line">    callOperandResultMap.put(call, operandResults);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> implementor.implement(<span class="built_in">this</span>, call, operandResults);</span><br><span class="line">    rexResultMap.put(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了从 RexImpTable 中获取的运算符实现器，可以看到实现器中包含了 <code>CONCAT_WS</code> 函数对应的实现方法 <code>SqlFunctions.concatMultiWithSeparator()</code>。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/concat_ws_function_call.png" title="CONCAT_WS 函数调用"><p>最终，Caclite 会生成如下的代码，对函数的调用逻辑位于 <code>current()</code> 方法中，<code>CONCAT_WS</code> 函数会调用 <code>SqlFunctions.concatMultiWithSeparator()</code> 方法，并将 SQL 中的参数传递给函数方法。<code>CAST</code> 函数由于入参为 <code>null</code>，因此无需调用具体的函数，可以直接执行 <code>(String) null</code> 进行转换。<code>getElementType</code> 用于返回 SQL 执行结果的类型，示例 SQL 返回结果为 String 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.calcite.linq4j.Enumerable <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> org.apache.calcite.DataContext root)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> org.apache.calcite.linq4j.<span class="type">Enumerable</span> <span class="variable">_inputEnumerable</span> <span class="operator">=</span> org.apache.calcite.linq4j.Linq4j.asEnumerable(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.linq4j.AbstractEnumerable() &#123;</span><br><span class="line">        <span class="keyword">public</span> org.apache.calcite.linq4j.Enumerator <span class="title function_">enumerator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.linq4j.Enumerator() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">final</span> org.apache.calcite.linq4j.<span class="type">Enumerator</span> <span class="variable">inputEnumerator</span> <span class="operator">=</span> _inputEnumerable.enumerator();</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">                    inputEnumerator.reset();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">moveNext</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> inputEnumerator.moveNext();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">                    inputEnumerator.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">current</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> org.apache.calcite.runtime.SqlFunctions.concatMultiWithSeparator(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;,&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;a&quot;</span>, (String) <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;b&quot;</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class <span class="title function_">getElementType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> java.lang.String.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 Caclite JDBC 会调用 <code>Bindable#bind</code> 方法执行，会返回一个 Enumerable 枚举对象，使用枚举对象就可以很容易地获取到查询结果集。</p><h2 id="udf-函数扩展实践"><a class="markdownIt-Anchor" href="#udf-函数扩展实践"></a> UDF 函数扩展实践</h2><p>前文我们介绍了 Caclite 函数相关的实现类，带领大家一起探究了标量函数、聚合函数、表函数 &amp; 表宏在 Schema 中的实现，并结合 Calcite 函数测试 Case，一起跟踪了函数的执行流程。<strong>UDF 函数和 Calcite 内置函数类似，只是实现逻辑由用户提供并注册到 Schema 中，Calcite 在执行时会从 Schema 中找到函数实现类，并生成可执行代码</strong>。下面小节，我们结合一些 UDF 案例，为大家介绍下不同类型的 UDF 函数如何扩展。</p><h3 id="udf-标量函数扩展"><a class="markdownIt-Anchor" href="#udf-标量函数扩展"></a> UDF 标量函数扩展</h3><p>首先，我们来实现一个自定义的标量函数 <code>INDEX_OF</code>，用于从 <code>content</code> 中查找 <code>target</code> 字符串，并返回其位置。我们知道，UDF 函数最重要的是函数实现逻辑，所以我们先来实现如下的 <code>indexOf</code> 方法，内部实现逻辑很简单，调用 <code>String#indexOf</code> 实现字符串位置查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDFRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 从 content 中查找 target 字符串，并返回其位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String content, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content.indexOf(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现函数逻辑后，第二步需要注册函数实现到 Schema 中，我们编写如下的逻辑，从 <code>calciteConnection</code> 中获取 <code>SchemaPlus</code> 对象，然后通过 <code>add</code> 方法将 <code>Function</code> 对象添加到 Schema 中。<code>ScalarFunctionImpl#create</code> 方法负责 <code>Function</code> 对象负责函数对象的创建，它的内部实现逻辑我们前文已经介绍，内部使用反射获取 Method 对象，然后创建 CallImplementor 存储在 ScalarFunctionImpl 中，用于后续的函数执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UDFExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;org.apache.calcite.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:calcite:&quot;</span>, initProps())) &#123;</span><br><span class="line">            <span class="type">CalciteConnection</span> <span class="variable">calciteConnection</span> <span class="operator">=</span> connection.unwrap(CalciteConnection.class);</span><br><span class="line">            <span class="type">SchemaPlus</span> <span class="variable">rootSchema</span> <span class="operator">=</span> calciteConnection.getRootSchema();</span><br><span class="line">            <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> createSchema(rootSchema);</span><br><span class="line">            rootSchema.add(<span class="string">&quot;calcite_function&quot;</span>, schema);</span><br><span class="line">            rootSchema.add(<span class="string">&quot;INDEX_OF&quot;</span>, Objects.requireNonNull(ScalarFunctionImpl.create(UDFRegistry.class, <span class="string">&quot;indexOf&quot;</span>)));</span><br><span class="line">            executeQuery(calciteConnection, <span class="string">&quot;SELECT INDEX_OF(user_name, &#x27;san&#x27;) FROM calcite_function.t_user&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<strong>自定义函数在执行阶段和内置函数又有什么不同呢</strong>？我们来跟踪下这段代码，一起来看看内部实现有哪些差异。首先，Schema 中注册的 Function 对象，会在 Calcite JDBC 执行时，封装到 <code>CalciteCatalogReader</code> 对象中，并提供了 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/b1308feff49c8b747b3bbb52e1519d334bc984ec/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java#L254">lookupOperatorOverloads</a> 用于查找内置和自定义函数。然后会创建 <code>SqlValidator</code> 对象，此时会将 <code>CalciteCatalogReader</code> 对象封装到 <code>SqlOperatorTable</code> 对象中，用于后续运算符和函数的查找，也包含了自定义函数的查找。</p><p>Calcite SQL 解析器会将 <code>SELECT INDEX_OF(user_name, 'san') FROM calcite_function.t_user</code> 解析为 SqlNode 抽象语法树，此时可以看到 <code>INDEX_OF</code> 函数被解析为 SqlUnresolvedFunction 对象。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/select-user-defined-function-parse-result.png" title="用户自定义函数解析 AST"><p>解析完成后，会继续执行 SQL 校验，此时会调用 <code>SqlValidatorImpl#performUnconditionalRewrites</code> 方法，此时会判断运算符是否为 SqlUnresolvedFunction，是则从 opTab 中的 CalciteCatalogReader 查找自定义函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (call.getOperator() <span class="keyword">instanceof</span> SqlUnresolvedFunction) &#123;</span><br><span class="line">    <span class="keyword">assert</span> call <span class="keyword">instanceof</span> SqlBasicCall;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlUnresolvedFunction</span> <span class="variable">function</span> <span class="operator">=</span> (SqlUnresolvedFunction) call.getOperator();</span><br><span class="line">    <span class="comment">// This function hasn&#x27;t been resolved yet.  Perform</span></span><br><span class="line">    <span class="comment">// a half-hearted resolution now in case it&#x27;s a</span></span><br><span class="line">    <span class="comment">// builtin function requiring special casing.  If it&#x27;s</span></span><br><span class="line">    <span class="comment">// not, we&#x27;ll handle it later during overload resolution.</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SqlOperator&gt; overloads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    opTab.lookupOperatorOverloads(function.getNameAsId(), function.getFunctionType(), SqlSyntax.FUNCTION, overloads, catalogReader.nameMatcher());</span><br><span class="line">    <span class="keyword">if</span> (overloads.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        ((SqlBasicCall) call).setOperator(overloads.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终从 Schema 中查找到了如下的自定义函数对象：</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/lookup-user-defined-function.png" title="Schema 中查找到的自定义函数对象"><p>然后调用 <code>CalciteCatalogReader#toOp</code> 将 Function 对象转换为 SQL 运算符，内部会根据 function 类型转换为不同函数运算符，标量函数会转换为 <code>SqlUserDefinedFunction</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (function <span class="keyword">instanceof</span> ScalarFunction) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlReturnTypeInference</span> <span class="variable">returnTypeInference</span> <span class="operator">=</span> infer((ScalarFunction) function);</span><br><span class="line">    <span class="comment">// 标量函数转换为 SqlUserDefinedFunction</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlUserDefinedFunction</span>(name, kind, returnTypeInference, operandTypeInference, operandMetadata, function);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (function <span class="keyword">instanceof</span> AggregateFunction) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlReturnTypeInference</span> <span class="variable">returnTypeInference</span> <span class="operator">=</span> infer((AggregateFunction) function);</span><br><span class="line">    <span class="comment">// 聚合函数转换为 SqlUserDefinedAggFunction</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlUserDefinedAggFunction</span>(name, kind, returnTypeInference, operandTypeInference, operandMetadata, (AggregateFunction) function, <span class="literal">false</span>, <span class="literal">false</span>, Optionality.FORBIDDEN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (function <span class="keyword">instanceof</span> TableMacro) &#123;</span><br><span class="line">    <span class="comment">// 表宏转换为 SqlUserDefinedTableMacro</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlUserDefinedTableMacro</span>(name, kind, ReturnTypes.CURSOR, operandTypeInference, operandMetadata, (TableMacro) function);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (function <span class="keyword">instanceof</span> TableFunction) &#123;</span><br><span class="line">    <span class="comment">// 表函数转换为 SqlUserDefinedTableFunction</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlUserDefinedTableFunction</span>(name, kind, ReturnTypes.CURSOR, operandTypeInference, operandMetadata, (TableFunction) function);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;unknown function type &quot;</span> + function);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验完成后，Calcite 会调用 SqlToRelConverter 将 SqlNode 转换为 RelNode，转换的流程和内置函数类似，最终会调用到 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/c8cb56525dbc908da4a9081f062d87adfe27ab80/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java#L936">StandardConvertletTable#convertFunction</a> 方法，将函数运算符转换为 RexCall，完整的 RelNode 树如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogicalProject(EXPR$0=[INDEX_OF($1, &#x27;san&#x27;)])</span><br><span class="line">  JdbcTableScan(table=[[calcite_function, t_user]])</span><br></pre></td></tr></table></figure><p>经过 Calcite 内置的优化器和优化规则优化，可以得到如下的物理执行计划，最底层使用了 <code>JdbcTableScan</code> 运算符扫描表中的数据，然后使用 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/b1308feff49c8b747b3bbb52e1519d334bc984ec/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java#L72">JdbcToEnumerableConverter</a> 将 JdbcConvention 转换为 EnumerableConvention，转换后数据就可以传递给 <code>EnumerableCalc</code> 运算符进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EnumerableCalc(expr#0..3=[&#123;inputs&#125;], expr#4=[&#x27;san&#x27;], expr#5=[INDEX_OF($t1, $t4)], EXPR$0=[$t5])</span><br><span class="line">  JdbcToEnumerableConverter</span><br><span class="line">    JdbcTableScan(table=[[calcite_function, t_user]])</span><br></pre></td></tr></table></figure><p>最后会调用 <code>CalcitePrepareImpl#implement</code> 方法生成执行逻辑，内部生成自定义函数逻辑时会调用 <code>ReflectiveCallNotNullImplementor#implement</code> 方法，并返回一个 MethodCallExpression 对象，里面包含了对 UDF 函数的调用。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/implement-scalar-function.png" title="实现 INDEX_OF 标量函数"><p>UDF 函数生成的代码逻辑如下，该逻辑会嵌入到最终的执行逻辑中，可以看到每行记录获取时，都会调用一次 UDF 函数，因此数据量越大，UDF 函数执行消耗的时间越多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] current = (Object[]) inputEnumerator.current();</span><br><span class="line">    <span class="keyword">return</span> com.strongduanmu.udf.UDFRegistry.indexOf(current[<span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : current[<span class="number">1</span>].toString(), <span class="string">&quot;san&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终 SQL 执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 表中的 user_name 记录</span><br><span class="line">19:46:54.104 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: USER_NAME, ColumnValue: zhangsan</span><br><span class="line">19:46:54.104 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: USER_NAME, ColumnValue: lisi</span><br><span class="line">19:46:54.104 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: USER_NAME, ColumnValue: wangwu</span><br><span class="line"># user_name index_of 执行结果</span><br><span class="line">19:43:32.790 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: EXPR$0, ColumnValue: 5</span><br><span class="line">19:43:32.790 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: EXPR$0, ColumnValue: -1</span><br><span class="line">19:43:32.790 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: EXPR$0, ColumnValue: -1</span><br></pre></td></tr></table></figure><p>除了前面介绍的 UDF 标量函数外，Calcite 社区的同学之前还咨询关于 Oracle <code>ROWNUM</code>、<code>SYSDATE</code> 这些特殊函数，在 Oracle 中无参数的函数不能写括号，无参数的函数通常也叫做 <a target="_blank" rel="noopener" href="https://aplwiki.com/wiki/Niladic_function">Niladic Function</a>，在 Calcite 中使用 <code>allowNiladicParentheses</code> 属性控制无参函数是否可以使用括号，像 MySQL、Apache Phoenix 就允许使用括号，而 Oracle、PostgreSQL、SQL Server 则不支持括号。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/udf-without-parentheses.png" title="无括号 UDF 函数"><p>我们将上面的示例进行一些改造，设置 Calcite JDBC 中的 <code>conformance</code> 属性为 <code>ORACLE_12</code>，它对应的 <code>allowNiladicParentheses</code> 实现为 <code>false</code>。然后在 UDFRegistry 类中增加一个 <code>sysDate</code> 函数实现，并使用 <code>rootSchema.add(&quot;SYS_DATE&quot;, Objects.requireNonNull(ScalarFunctionImpl.create(UDFRegistry.class, &quot;sysDate&quot;)));</code> 将 <code>SYS_DATE</code> 函数注册到 Schema 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title function_">sysDate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LocalDate.now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>SELECT SYS_DATE FROM calcite_function.t_user</code> 语句，按照预期 Calcite 应当能够正确执行该 SQL，并返回结果。但是执行之后，Calcite 却抛出了异常，具体异常堆栈信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.calcite.runtime.CalciteContextException: From line 1, column 8 to line 1, column 15: Column &#x27;SYS_DATE&#x27; not found in any table</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:511)</span><br><span class="line">	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:952)</span><br><span class="line">	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:937)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.newValidationError(SqlValidatorImpl.java:5899)</span><br><span class="line">	at org.apache.calcite.sql.validate.DelegatingScope.fullyQualify(DelegatingScope.java:293)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.visit(SqlValidatorImpl.java:7105)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7276)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl$SelectExpander.visit(SqlValidatorImpl.java:7261)</span><br><span class="line">	at org.apache.calcite.sql.SqlIdentifier.accept(SqlIdentifier.java:324)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl$Expander.go(SqlValidatorImpl.java:7094)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectExpr(SqlValidatorImpl.java:6665)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.expandSelectItem(SqlValidatorImpl.java:481)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelectList(SqlValidatorImpl.java:5015)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:4096)</span><br><span class="line">	at org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:62)</span><br><span class="line">	at org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:95)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1206)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1177)</span><br><span class="line">	at org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:282)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1143)</span><br><span class="line">	at org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:849)</span><br><span class="line">	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQuery(SqlToRelConverter.java:624)</span><br><span class="line">	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:257)</span><br><span class="line">	at org.apache.calcite.prepare.Prepare.prepareSql(Prepare.java:220)</span><br><span class="line">	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare2_(CalcitePrepareImpl.java:673)</span><br><span class="line">	at org.apache.calcite.prepare.CalcitePrepareImpl.prepare_(CalcitePrepareImpl.java:524)</span><br><span class="line">	at org.apache.calcite.prepare.CalcitePrepareImpl.prepareSql(CalcitePrepareImpl.java:492)</span><br><span class="line">	at org.apache.calcite.jdbc.CalciteConnectionImpl.parseQuery(CalciteConnectionImpl.java:237)</span><br><span class="line">	at org.apache.calcite.jdbc.CalciteMetaImpl.prepareAndExecute(CalciteMetaImpl.java:702)</span><br><span class="line">	at org.apache.calcite.avatica.AvaticaConnection.prepareAndExecuteInternal(AvaticaConnection.java:677)</span><br><span class="line">	at org.apache.calcite.avatica.AvaticaStatement.executeInternal(AvaticaStatement.java:157)</span><br><span class="line">	... 3 more</span><br></pre></td></tr></table></figure><p>我们在 <code>SqlValidatorImpl.java:7105</code> 位置设置断点，可以发现在校验 SYS_DATE 函数标识符时，会调用 <code>validator.makeNullaryCall(id)</code> 方法，该方法内部加载完函数后，会判断运算符的语法类型是否为 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/db60219198442f2c60345fda95a117d379d87a61/core/src/main/java/org/apache/calcite/sql/SqlSyntax.java#L139">SqlSyntax.FUNCTION_ID</a>，而 FUNCTION_ID 代表的就是类似于 CURRENTTIME 和 SYS_DATE 这样无括号的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlValidatorImpl#Expander 类 visit 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> SqlNode <span class="title function_">visit</span><span class="params">(SqlIdentifier id)</span> &#123;</span><br><span class="line">    <span class="comment">// First check for builtin functions which don&#x27;t have</span></span><br><span class="line">    <span class="comment">// parentheses, like &quot;LOCALTIME&quot;.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlCall</span> <span class="variable">call</span> <span class="operator">=</span> validator.makeNullaryCall(id);</span><br><span class="line">    <span class="keyword">if</span> (call != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> call.accept(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlIdentifier</span> <span class="variable">fqId</span> <span class="operator">=</span> getScope().fullyQualify(id).identifier;</span><br><span class="line">    <span class="type">SqlNode</span> <span class="variable">expandedExpr</span> <span class="operator">=</span> expandDynamicStar(id, fqId);</span><br><span class="line">    validator.setOriginal(expandedExpr, id);</span><br><span class="line">    <span class="keyword">return</span> expandedExpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlValidatorImpl 类 makeNullaryCall 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> SqlCall <span class="title function_">makeNullaryCall</span><span class="params">(SqlIdentifier id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id.names.size() == <span class="number">1</span> &amp;&amp; !id.isComponentQuoted(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;SqlOperator&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        opTab.lookupOperatorOverloads(id, <span class="literal">null</span>, SqlSyntax.FUNCTION, list, catalogReader.nameMatcher());</span><br><span class="line">        <span class="keyword">for</span> (SqlOperator operator : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operator.getSyntax() == SqlSyntax.FUNCTION_ID) &#123;</span><br><span class="line">                <span class="comment">// Even though this looks like an identifier, it is a</span></span><br><span class="line">                <span class="comment">// actually a call to a function. Construct a fake</span></span><br><span class="line">                <span class="comment">// call to this function, so we can use the regular</span></span><br><span class="line">                <span class="comment">// operator validation.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlBasicCall</span>(operator, ImmutableList.of(), id.getParserPosition(), <span class="literal">null</span>).withExpanded(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题的根源就变成了，为什么自定义函数转换为运算符后，它的语法类型不是 FUNCTION_ID？我们回顾下前面介绍的 <code>INDEX_OF</code> 函数执行过程，在 SQL 校验阶段，会将 ScalarFunction 转换为 SqlUserDefinedFunction 运算符，而它则继承了 SqlFunction 类，<a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/ba36004fb1e52b9bfb06623c7d869e6e01e25082/core/src/main/java/org/apache/calcite/sql/SqlFunction.java#L140">SqlFunction#getSyntax</a> 方法默认返回 SqlSyntax.FUNCTION。笔者排查了 SqlUserDefinedFunction 类，发现 Calcite 没有提供用户自定义语法类型的 API，如果想要支持这种不带括号的写法，需要修改源码调整 CalciteCatalogReader 类中的 <code>toOp</code> 方法。</p><p>本地尝试修改了下 Calcite CalciteCatalogReader 类源码，在 <code>toOp</code> 方法转换时，判断参数个数以及 allowNiladicParentheses 属性，如果无参数并且 allowNiladicParentheses 设置为 false，则将语法类型设置为 FUNCTION_ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (function <span class="keyword">instanceof</span> ScalarFunction) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SqlReturnTypeInference</span> <span class="variable">returnTypeInference</span> <span class="operator">=</span> infer((ScalarFunction) function);</span><br><span class="line">    <span class="type">SqlSyntax</span> <span class="variable">syntax</span> <span class="operator">=</span> function.getParameters().isEmpty() &amp;&amp; config.conformance().allowNiladicParentheses() ? SqlSyntax.FUNCTION : SqlSyntax.FUNCTION_ID;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlUserDefinedFunction</span>(name, kind, returnTypeInference, operandTypeInference, operandMetadata, function, syntax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后，使用 <code>./gradlew publishToMavenLocal</code> 发布到本地 Maven 仓库进行测试，然后引入新版本测试 <code>SELECT SYS_DATE FROM calcite_function.t_user</code>，此时可以正确执行并返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">08:49:17.625 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: SYS_DATE, ColumnValue: 2024-10-18</span><br><span class="line">08:49:17.648 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: SYS_DATE, ColumnValue: 2024-10-18</span><br><span class="line">08:49:17.668 [main] INFO com.strongduanmu.udf.UDFExample - ColumnLabel: SYS_DATE, ColumnValue: 2024-10-18</span><br></pre></td></tr></table></figure><p>目前，该 PR 还存在部分单测异常，笔者稍后修复后会提交到 Calcite 仓库，争取下个版本能够支持自定义函数不带括号的写法。</p><h3 id="udaf-聚合函数扩展"><a class="markdownIt-Anchor" href="#udaf-聚合函数扩展"></a> UDAF 聚合函数扩展</h3><p>聚合函数的扩展和标量函数稍有不同，聚合函数会将多个值组合转换为标量值，因此在聚合函数内部需要维护一个累加器，负责将数据行的值进行累加，当所有数据行遍历完成后，输出聚合函数的结果。因此，扩展聚合函数需要实现 <code>init</code>、<code>add</code> 和 <code>result</code> 方法，如下展示了一个将记录聚合为集合的函数实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDAFRegistry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Object&gt; <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Object&gt; <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> Collection&lt;Object&gt; accumulator, <span class="keyword">final</span> Object newElement)</span> &#123;</span><br><span class="line">        accumulator.add(newElement);</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Object&gt; <span class="title function_">result</span><span class="params">(<span class="keyword">final</span> Collection&lt;Object&gt; accumulator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>init</code> 方法中初始化了一个 <code>Collection&lt;Object&gt;</code> 容器，执行时每行数据都会调用 <code>add</code> 方法，并将 <code>Collection&lt;Object&gt;</code> 容器和当前行的元素传递进来，此时可以将新元数据添加到容器中，然后返回容器对象，最后所有行遍历完成后，会调用 <code>result</code> 方法，此时会返回容器对象，容器中记录了所有元素。</p><p>实现完 UDAF 后，我们需要通过 <code>AggregateFunctionImpl#create</code> 方法，将其注册到 Scehma 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootSchema.add(<span class="string">&quot;CONCAT_TO_LIST&quot;</span>, Objects.requireNonNull(AggregateFunctionImpl.create(UDAFRegistry.class)));</span><br><span class="line">CalciteJDBCUtils.executeQuery(calciteConnection, <span class="string">&quot;SELECT CONCAT_TO_LIST(user_name) FROM calcite_function.t_user&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后我们执行 <code>SELECT CONCAT_TO_LIST(user_name) FROM calcite_function.t_user</code> 语句进行测试，执行结果如下，可以发现 <code>user_name</code> 列中的值被转换为数组进行输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">50</span>:<span class="number">18.709</span> [main] INFO com.strongduanmu.udaf.UDAFExample <span class="operator">-</span> ColumnLabel: EXPR$<span class="number">0</span>, ColumnValue: [zhangsan, lisi, wangwu]</span><br></pre></td></tr></table></figure><p>查看执行过程中的执行计划，可以发现聚合函数位于 LogicalAggregate 运算符中，并且没有指定分组条件，会对所有数据行进行聚合计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑执行计划</span><br><span class="line">LogicalAggregate(<span class="keyword">group</span><span class="operator">=</span>[&#123;&#125;], EXPR$<span class="number">0</span><span class="operator">=</span>[CONCAT_TO_LIST($<span class="number">0</span>)])</span><br><span class="line">  LogicalProject(user_name<span class="operator">=</span>[$<span class="number">1</span>])</span><br><span class="line">    JdbcTableScan(<span class="keyword">table</span><span class="operator">=</span>[[calcite_function, t_user]])</span><br><span class="line"></span><br><span class="line"># 物理执行计划</span><br><span class="line">EnumerableAggregate(<span class="keyword">group</span><span class="operator">=</span>[&#123;&#125;], EXPR$<span class="number">0</span><span class="operator">=</span>[CONCAT_TO_LIST($<span class="number">1</span>)])</span><br><span class="line">  JdbcToEnumerableConverter</span><br><span class="line">    JdbcTableScan(<span class="keyword">table</span><span class="operator">=</span>[[calcite_function, t_user]])</span><br></pre></td></tr></table></figure><p>跟踪 Calcite 生成的执行代码，会依次调用 <code>apply()</code> 方法初始化，内部调用的是 <code>UDAFRegistry#init</code> 方法，然后调用 <code>accumulatorAdder()</code> 方法执行聚合逻辑，每行数据都会调用 <code>UDAFRegistry#add</code> 方法，最后调用 <code>singleGroupResultSelector</code> 获取结果，内部调用的是 <code>UDAFRegistry#result</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">java.util.<span class="type">List</span> <span class="variable">accumulatorAdders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.LinkedList();</span><br><span class="line">accumulatorAdders.add(<span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.linq4j.function.Function2() &#123;</span><br><span class="line">    <span class="keyword">public</span> Record3_0 <span class="title function_">apply</span><span class="params">(Record3_0 acc, Object[] in )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!( in [<span class="number">1</span>] == <span class="literal">null</span> || in [<span class="number">1</span>].toString() == <span class="literal">null</span>)) &#123;</span><br><span class="line">            acc.f2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 调用 add 方法，增加新元数据</span></span><br><span class="line">            acc.f0 = acc.f1.add(acc.f0, in [<span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : in [<span class="number">1</span>].toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Record3_0 <span class="title function_">apply</span><span class="params">(Object acc, Object in )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(</span><br><span class="line">            (Record3_0) acc, (Object[]) in );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">org.apache.calcite.adapter.enumerable.<span class="type">AggregateLambdaFactory</span> <span class="variable">lambdaFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.adapter.enumerable.BasicAggregateLambdaFactory(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.linq4j.function.Function0() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">            java.util.Collection a0s0;</span><br><span class="line">            com.strongduanmu.udaf.UDAFRegistry a0s1;</span><br><span class="line">            <span class="type">boolean</span> a0s2;</span><br><span class="line">            a0s2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 创建 UDAFRegistry 对象</span></span><br><span class="line">            a0s1 = <span class="keyword">new</span> <span class="title class_">com</span>.strongduanmu.udaf.UDAFRegistry();</span><br><span class="line">            <span class="comment">// 调用 init 方法初始化</span></span><br><span class="line">            a0s0 = a0s1.init();</span><br><span class="line">            Record3_0 record0;</span><br><span class="line">            <span class="comment">// 将聚合函数的累加器、UDF 对象、是否计算完成标记记录到 Record3_0 的 f0、f1 和 f2 中</span></span><br><span class="line">            record0 = <span class="keyword">new</span> <span class="title class_">Record3_0</span>();</span><br><span class="line">            record0.f0 = a0s0;</span><br><span class="line">            record0.f1 = a0s1;</span><br><span class="line">            record0.f2 = a0s2;</span><br><span class="line">            <span class="keyword">return</span> record0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    accumulatorAdders);</span><br><span class="line"><span class="comment">// 先调用 apply() 初始化，然后调用 accumulatorAdder() 执行聚合逻辑，最后调用 singleGroupResultSelector 获取结果</span></span><br><span class="line"><span class="keyword">return</span> org.apache.calcite.linq4j.Linq4j.singletonEnumerable(enumerable.aggregate(lambdaFactory.accumulatorInitializer().apply(), lambdaFactory.accumulatorAdder(), lambdaFactory.singleGroupResultSelector(<span class="keyword">new</span> <span class="title class_">org</span>.apache.calcite.linq4j.function.Function1() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Record3_0 acc)</span> &#123;</span><br><span class="line">                        <span class="comment">// 判断是否计算完成，完成则调用 result 方法</span></span><br><span class="line">                        <span class="keyword">return</span> acc.f2 ? acc.f1.result(acc.f0) : <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object acc)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> apply(</span><br><span class="line">                            (Record3_0) acc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="udtf-表函数-表宏扩展"><a class="markdownIt-Anchor" href="#udtf-表函数-表宏扩展"></a> UDTF 表函数 &amp; 表宏扩展</h3><p>根据前文介绍，UDTF 表函数是指<strong>在执行阶段将某些数据转换为表的函数</strong>，而表宏则是指<strong>在编译阶段将某些数据转换为表的函数</strong>，两者都可以用于 FROM 子句中，作为一张表进行使用。本小节重点探究下 UDTF 表函数的扩展，来实现一个将 <code>java=1,go=2,scala=3</code> 结构数据，拆分为两列三行表结构的表函数，表宏的扩展方式类似，留给大家自行探究。</p><p>首先，我们需要实现表函数的逻辑，根据前面介绍，表函数需要实现 <code>QueryableTable</code> 或者 <code>ScannableTable</code> 接口，然后才可以创建出 TableFunction 实现对象，在前面很多文章中，我们介绍过 ScannableTable，本次我们使用 QueryableTable 来实现表函数逻辑。</p><p>UDTF 函数的实现逻辑如下，<code>eval</code> 方法是函数的主体逻辑，它接收 <code>content</code> 字符串以及 <code>columnSize</code> 数值两个参数，并返回 <code>QueryableTable</code> 实现对象。<code>eval</code> 方法内部我们创建了一个 <code>AbstractQueryableTable</code> 对象，构造方法中传递了函数的返回类型，是一个对象数组 <code>Object[].class</code>。</p><p><a target="_blank" rel="noopener" href="https://github.com/apache/calcite/blob/66caa54c5e272f8287ca132ca012733898a38768/core/src/main/java/org/apache/calcite/adapter/java/AbstractQueryableTable.java#L30">AbstractQueryableTable</a> 中需要实现 <code>asQueryable</code> 和 <code>getRowType</code> 方法，asQueryable 方法负责将数据转换为可以遍历的对象，内部可以覆盖 <code>enumerator</code> 方法，该方法内部函数会对传入的 <code>content</code> 字段进行切割处理，并根据 <code>columnSize</code> 组装结果集的列数，<code>moveNext</code> 方法会首先被调用，将游标移动到结果集的第一位，然后调用 <code>current</code> 方法获取当前记录，然后循环调用 <code>moveNext</code> 和 <code>current</code> 直到所有记录遍历完成，最后会调用 <code>reset</code> 和 <code>close</code> 方法重置和关闭资源。<code>getRowType</code> 方法用于返回 UDTF 计算结果集的类型，本案例中表函数返回 key、value 两列，分别为 String 和 int 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDTFRegistry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">UDTF_METHOD</span> <span class="operator">=</span> Types.lookupMethod(UDTFRegistry.class, <span class="string">&quot;eval&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> QueryableTable <span class="title function_">eval</span><span class="params">(<span class="keyword">final</span> String content, <span class="keyword">final</span> <span class="type">int</span> columnSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractQueryableTable</span>(Object[].class) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; Queryable&lt;T&gt; <span class="title function_">asQueryable</span><span class="params">(<span class="keyword">final</span> QueryProvider queryProvider, <span class="keyword">final</span> SchemaPlus schema, <span class="keyword">final</span> String tableName)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Queryable&lt;T&gt;) <span class="keyword">new</span> <span class="title class_">BaseQueryable</span>&lt;Object[]&gt;(queryProvider, String.class, <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Enumerator&lt;Object[]&gt; enumerator() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumerator</span>&lt;Object[]&gt;() &#123;</span><br><span class="line">                            String[] rows = content.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                            </span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> Object[] current() &#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">row</span> <span class="operator">=</span> rows[index];</span><br><span class="line">                                Object[] result = <span class="keyword">new</span> <span class="title class_">Object</span>[columnSize];</span><br><span class="line">                                String[] columns = row.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                                Preconditions.checkArgument(columns.length == <span class="number">2</span>, String.format(<span class="string">&quot;Invalid row: %s, row must constains %d columns.&quot;</span>, row, columnSize));</span><br><span class="line">                                <span class="keyword">return</span> columns;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">moveNext</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (index &lt; rows.length - <span class="number">1</span>) &#123;</span><br><span class="line">                                    index++;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> RelDataType <span class="title function_">getRowType</span><span class="params">(<span class="keyword">final</span> RelDataTypeFactory typeFactory)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> typeFactory.createStructType(Arrays.asList(typeFactory.createJavaType(String.class), typeFactory.createJavaType(String.class)), Arrays.asList(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现完 UDTF 逻辑后，我们需要使用 <code>TableFunctionImpl#create</code> 方法，将 UDTF 函数注册到 Schema 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootSchema.add(<span class="string">&quot;EXTRACT_FROM_CSV&quot;</span>, Objects.requireNonNull(TableFunctionImpl.create(UDTFRegistry.UDTF_METHOD)));</span><br><span class="line">CalciteJDBCUtils.executeQuery(calciteConnection, <span class="string">&quot;SELECT * FROM EXTRACT_FROM_CSV(&#x27;java=1,go=2,scala=3&#x27;, 2)&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后我们执行 <code>SELECT * FROM EXTRACT_FROM_CSV('java=1,go=2,scala=3', 2)</code> 语句，可以得到如下结果，可以看到原先的字符串，被表函数按照 <code>,</code> 拆分为 3 行，每行又按照 <code>=</code> 拆分为 2 列，列名也是我们指定的 <code>key</code> 和 <code>value</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: key, ColumnValue: java</span><br><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: value, ColumnValue: 1</span><br><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: key, ColumnValue: go</span><br><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: value, ColumnValue: 2</span><br><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: key, ColumnValue: scala</span><br><span class="line">08:33:14.584 [main] INFO com.strongduanmu.common.CalciteJDBCUtils - ColumnLabel: value, ColumnValue: 3</span><br></pre></td></tr></table></figure><p>跟踪 UDTF 函数的执行过程，我们可以发现 Calcite 解析后增加了一个 TABLE 函数嵌套在 <code>EXTRACT_FROM_CSV</code> 外部，用于标记这是一个表函数，内部的函数和其他自定义函数一样，是 SqlUnresolvedFunction 类型。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/udtf-parse-result.png" title="UDTF 函数解析结果"><p>在校验阶段，TABLE 函数会被转换为 <code>SqlCollectionTableOperator</code>，根据 Calcite 注释说明，它表示表函数派生表运算符，用于将表函数的值转换为关系 Relation，EXTRACT_FROM_CSV 函数被转换为 SqlUserDefinedTableFunction 对象。</p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/apache-calcite-catalog-udf-function-implementation-and-extension/validated-udtf-sqlnode.png" title="经过校验的 UTDF SqlNode"><p>校验完成后，Calcite 又生成了如下的逻辑执行计划和物理执行计划，可以看到最终物理执行计划只包含了 EnumerableTableFunctionScan，这是因为我们使用 <code>*</code> 查询，最终的投影列和 EnumerableTableFunctionScan 一致，因此无需再进行投影计算。EnumerableTableFunctionScan 中还包含了函数调用信息，以及返回结果类型信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑执行计划</span><br><span class="line">LogicalProject(key<span class="operator">=</span>[$<span class="number">0</span>], <span class="keyword">value</span><span class="operator">=</span>[$<span class="number">1</span>])</span><br><span class="line">  LogicalTableFunctionScan(invocation<span class="operator">=</span>[EXTRACT_FROM_CSV(<span class="string">&#x27;java=1,go=2,scala=3&#x27;</span>, <span class="number">2</span>)], rowType<span class="operator">=</span>[RecordType(JavaType(class java.lang.String) key, JavaType(class java.lang.String) <span class="keyword">value</span>)], elementType<span class="operator">=</span>[class [Ljava.lang.Object;])</span><br><span class="line"></span><br><span class="line"># 物理执行计划</span><br><span class="line">EnumerableTableFunctionScan(invocation<span class="operator">=</span>[EXTRACT_FROM_CSV(<span class="string">&#x27;java=1,go=2,scala=3&#x27;</span>, <span class="number">2</span>)], rowType<span class="operator">=</span>[RecordType(JavaType(class java.lang.String) key, JavaType(class java.lang.String) <span class="keyword">value</span>)], elementType<span class="operator">=</span>[class [Ljava.lang.Object;])</span><br></pre></td></tr></table></figure><p>最终通过 Calcite 代码生成，生成的可执行逻辑如下，在调用 <code>bind</code> 方法时，内部会调用到 <code>UDTFRegistry#eval</code> 方法，并转换为可枚举的 Enumerable 对象，最终通过 Calcite JDBC 提供查询结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> org.apache.calcite.linq4j.Enumerable <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> org.apache.calcite.DataContext root)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> com.strongduanmu.udtf.<span class="type">UDTFRegistry</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.strongduanmu.udtf.UDTFRegistry();</span><br><span class="line">    <span class="keyword">return</span> f.eval(<span class="string">&quot;java=1,go=2,scala=3&quot;</span>, <span class="number">2</span>).asQueryable(root.getQueryProvider(), (org.apache.calcite.schema.SchemaPlus) <span class="literal">null</span>, <span class="string">&quot;EXTRACT_FROM_CSV&quot;</span>).asEnumerable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class <span class="title function_">getElementType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> java.lang.Object[].class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>本文首先介绍了 Calcite 函数相关的概念和构成体系，然后按照函数的分类：<strong>标量函数、聚合函数以及表函数/表宏</strong>，为大家介绍了这些函数内部的实现细节，并通过 Calcite <code>functions.iq</code> 测试用例中的一个典型案例，和大家一起跟踪了函数的执行流程。</p><p>Calcite 函数执行的过程中，首先会创建 <code>SqlValidator</code> 对象，此时会将 Calcite 内置函数以及用户自定义函数注册进来。然后会依次进行 SQL 解析和 SQL 校验，通常函数都会被解析为 <code>SqlUnresolvedFunction</code> 对象，并在 SQL 校验时，通过查找函数注册表将 SqlUnresolvedFunction 转换为 SqlBasicFunction 或其他函数运算符对象。SQL 校验完成后，Calcite 会继续进行 SQL 优化和 SQL 执行，优化阶段会调用 <code>StandardConvertletTable#convertFunction</code> 方法，将函数运算符转换为 RexNode，并和其他 SQL 部分一起构成一个 RelNode 执行计划树。最后 Calcite 会调用 <code>implement</code> 方法生成可执行代码，此时会将内置函数或自定义函数的实现逻辑，嵌入到整个可执行代码中，通过 Janio 将代码编译为可执行的对象，这样就完成了整个 SQL 执行逻辑。</p><p>在文章的最后部分，我们又介绍了不同类型函数的扩展方式。Calcite 扩展函数非常简单，用户只需按照规范编写函数逻辑，然后通过 Schema API 注册到 Calcite 中，就可以成功执行函数逻辑，感兴趣的同学可以参考文中的代码示例，尝试实现不同逻辑的自定义函数。</p><p>根据 <a href="https://strongduanmu.com/blog/explore-apache-calcite-system-catalog-implementation.html">Apache Calcite System Catalog 实现探究</a>中介绍，Calcite Catalog 中除了函数外，还包含了<strong>类型系统、视图、物化视图等</strong>对象，这些对象在日常数据处理中也都非常重要，我们将在后续文章中继续探究学习，欢迎感兴趣的朋友持续关注。</p><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">写在最后</span><span class="empty"></span></p></div><p>笔者因为工作原因接触到 Calcite，前期学习过程中，深感 Calcite 学习资料之匮乏，因此创建了 <a target="_blank" rel="noopener" href="https://wx.zsxq.com/dweb2/index/group/51128414222814">Calcite 从入门到精通知识星球</a>，希望能够将学习过程中的资料和经验沉淀下来，为更多想要学习 Calcite 的朋友提供一些帮助。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/xingqiu/calcite_xingqiu.png" alt="Calcite 从入门到精通"></p><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">欢迎关注</span><span class="empty"></span></p></div><p>欢迎关注「<strong>端小强的博客</strong>」微信公众号，会不定期分享日常学习和工作经验，欢迎大家关注交流。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/wechat/gongzhonghao.png" alt="微信公众号"></p><div class="article-footer fs14"><section id="references"><div class="header"><span>参考资料</span></div><div class="body"><ul><li class="post-title"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/it_dx/article/details/117948590">Apache Calcite——新增动态 UDF 支持</a></p></li><li class="post-title"><p><a href="https://strongduanmu.com/wiki/calcite/adapters.html#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">Calcite 官方文档中文版-适配器-可扩展性</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65472726">如何在 Calcite 注册函数</a></p></li><li class="post-title"><p><a target="_blank" rel="noopener" href="https://articles.zsxq.com/id_sl3habfw53xv.html">Calcite 的初步使用——Calcite 添加自定义函数</a></p></li></ul></div></section><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">署名-非商业性使用-禁止演绎 4.0 国际</a> 许可协议，未经授权请勿转载。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html&title=Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展 - 端小强的博客&pics=/assets/cover/calcite.jpg&summary=
注意：本文基于 Calcite main 分支 60e0a3f 版本源码进行学习研究，其他版本可能会存在实现逻辑差异，对源码感兴趣的读者请注意版本选择。

 前言
最近，很多朋友咨询关于 Calcite UDF 实现和扩展的问题，在..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=Apache Calcite Catalog 拾遗之 UDF 函数实现和扩展 - 端小强的博客&amp;body=https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://strongduanmu.com/blog/apache-calcite-catalog-udf-function-implementation-and-extension.html"></div></div></section></div></article><div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/blog/shardingsphere-proxy-adapt-mysql-add-batch-execute-batch-return-int-array-in-action.html">ShardingSphere Proxy 适配 MySQL addBatch/executeBatch 数组结果实战</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/blog/graalvm-compilation-of-dynamic-link-library-mysql-udf-implementation.html">GraalVM 编译动态链接库之 MySQL UDF 实现</a></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="strongduanmu/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkzNzQwMDk3Njg=" data-category="Announcements" data-category-id="DIC_kwDOFkrvqM4CZIsa" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">文档</span><a href="/wiki/calcite/background.html">Calcite</a><a href="/wiki/cmu_15_445/index.html">CMU 15-445</a><a href="/wiki/cmu_15_721/index.html">CMU 15-721</a></div><div class="sitemap-group"><span class="fs15">便笺</span><a href="/notes/">Common</a><a href="/notes/docker.html">Docker</a><a href="/notes/git.html">Git</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/more/">关于</a><a href="/more/news/">动态</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://github.com/strongduanmu">@strongduanmu</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建，使用 <a target="_blank" rel="noopener" href="https://vercel.com/">Vercel</a> 网站部署。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br>本站总访问量 <span id="vercount_value_site_pv"></span> 次，本站访客数 <span id="vercount_value_site_uv"></span> 人次。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calcite-%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-text">Calcite 函数简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6"><span class="toc-text">内置函数实现探究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-text">标量函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%87%BD%E6%95%B0-%E8%A1%A8%E5%AE%8F"><span class="toc-text">表函数 &amp; 表宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">函数执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sqlvalidator-%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C"><span class="toc-text">SqlValidator 函数注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%A1%E9%AA%8C"><span class="toc-text">函数解析和校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql-%E4%BC%98%E5%8C%96%E5%92%8C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-text">SQL 优化和函数执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udf-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E5%AE%9E%E8%B7%B5"><span class="toc-text">UDF 函数扩展实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#udf-%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95"><span class="toc-text">UDF 标量函数扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udaf-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95"><span class="toc-text">UDAF 聚合函数扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udtf-%E8%A1%A8%E5%87%BD%E6%95%B0-%E8%A1%A8%E5%AE%8F%E6%89%A9%E5%B1%95"><span class="toc-text">UDTF 表函数 &amp; 表宏扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel blur"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"codeblock":true,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"/assets/placeholder/avatar.svg",cover:"/assets/placeholder/cover.svg"},deps={jquery:"https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js",marked:"https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js"}</script><script>function RunItem(){function n(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let s=e,i=new n(s=r?()=>{utils.requestAnimationFrame(e)}:s,t);this.list.push(i)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,s)=>{var i,n,a=window.document,o=a.createElement("link"),d=(n=t||(i=(a.body||a.getElementsByTagName("head")[0]).childNodes)[i.length-1],a.styleSheets);if(s)for(var l in s)s.hasOwnProperty(l)&&o.setAttribute(l,s[l]);o.rel="stylesheet",o.href=e,o.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){n.parentNode.insertBefore(o,t?n:n.nextSibling)});function u(e){for(var t=o.href,r=d.length;r--;)if(d[r].href===t)return e();setTimeout(function(){u(e)})}function h(){o.addEventListener&&o.removeEventListener("load",h),o.media=r||"all"}return o.addEventListener&&o.addEventListener("load",h),o.onloadcssdefined=u,u(h),o},js:(i,n)=>new Promise((t,e)=>{var r=document.createElement("script");if(i.startsWith("/")&&(i=ctx.root+i.substring(1)),r.src=i,n)for(var s of Object.keys(n))r[s]=n[s];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(n,a,o,d)=>{let l=3;utils.onLoading(n),function i(){new Promise((t,e)=>{let r=0,s=setTimeout(()=>{0===r&&(r=2,s=null,e("请求超时"),0==l)&&d()},5e3);fetch(a).then(function(e){if(2!==r&&(clearTimeout(s),t(e),s=null,r=1),e.ok)return e.json();throw new Error("Network response was not ok.")}).then(function(e){l=0,utils.onLoadSuccess(n),o(e)}).catch(function(e){0<l?(--l,setTimeout(()=>{i()},5e3)):(utils.onLoadFailure(n),d())})})}()},requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script src="/js/main.js?v=1.30.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e),applyThemeToGiscus(e)},applyThemeToGiscus=e=>{e="auto"===e?"preferred_color_scheme":e;var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let n=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<n.length;++e){var s=n[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=o(i)+":"+o(t)}}function o(e){return e<10?"0"+e:e}0<n.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="/js/flying-pages.min.js"></script><script defer src="/js/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy"},window.addEventListener("LazyLoad::Initialized",function(n){window.lazyLoadInstance=n.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()})</script><script>ctx.fancybox={selector:"article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)",css:"/css/fancybox.min.css",js:"/js/fancybox.umd.min.js"};var selector="[data-fancybox]:not(.error)",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let e=document.getElementsByClassName("ds-memos");null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(e,t)=>t.triggerEl.alt||t.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let i=document.getElementById("swiper-api");null!=i&&(utils.css("/css/swiper-bundle.min.css"),utils.js("/js/swiper-bundle.min.js",{defer:!0}).then(function(){var e=i.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"复制代码",success_text:"复制成功",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script async>((a,t,c)=>{t.ChatraID="PHWnu7Bamcwtbnx2d";var h=a.createElement("script");t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},h.async=!0,h.src="https://call.chatra.io/chatra.js",a.head&&a.head.appendChild(h)})(document,window,"Chatra")</script><script defer src="https://cn.vercount.one/js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>window.va=window.va||function(){(window.vaq=window.vaq||[]).push(arguments)}</script><script defer src="/_vercel/insights/script.js"></script><script>window.si=window.si||function(){(window.siq=window.siq||[]).push(arguments)}</script><script defer src="/_vercel/speed-insights/script.js"></script><script>function change_banner(){$(".banner img.bg").attr("src","/assets/banner/banner_"+Math.floor(20*Math.random()+1)+".jpg")}setTimeout("change_banner()",250)</script><script>function add_page_pv(){$("#post-meta").after('<div class="flex-row" id="post-meta"><span class="text created">本文总阅读量 <span id="vercount_value_page_pv"></span> 次</span></div>')}setTimeout("add_page_pv()",500)</script><script>function change_img_alt(){$("article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)").each(function(t){$(this).after("<div class='image-meta' style='text-align:center;'><span class='image-caption center' style='display:inline-block;font-size:.8125rem;color:var(--text-p2);line-height:1.5;text-align:justify;'>"+($(this).attr("title")||$(this).attr("alt"))+"</span></div>")})}setTimeout("change_img_alt()",1e3)</script></div></body></html>