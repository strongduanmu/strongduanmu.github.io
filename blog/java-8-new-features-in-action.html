<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1" theme-name="Stellar" theme-version="1.30.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>Java8 新特性实战 - 端小强的博客</title><meta name="description" content="前言 Java8 是 Oracle 公司在 2014 年 3 ⽉发布的版本，是 Java5 之后最重要的版本，带来了诸多⽅⾯的新特性，包括语⾔、类库、编译器及 JVM 等新特性。本⽂重点介绍 Java8 中语法相关的新特性，主要包括 Lambda 表达式、Stream API、New Date API、Optional 等。   Lambda 表达式  什么是 Lambda  Lambda ex"><meta property="og:type" content="article"><meta property="og:title" content="Java8 新特性实战"><meta property="og:url" content="https://strongduanmu.com/blog/java-8-new-features-in-action.html"><meta property="og:site_name" content="端小强的博客"><meta property="og:description" content="前言 Java8 是 Oracle 公司在 2014 年 3 ⽉发布的版本，是 Java5 之后最重要的版本，带来了诸多⽅⾯的新特性，包括语⾔、类库、编译器及 JVM 等新特性。本⽂重点介绍 Java8 中语法相关的新特性，主要包括 Lambda 表达式、Stream API、New Date API、Optional 等。   Lambda 表达式  什么是 Lambda  Lambda ex"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://strongduanmu.com/assets/blog/2022/02/11/1644542238.png"><meta property="og:image" content="https://strongduanmu.com/assets/blog/2022/02/11/1644543745.png"><meta property="og:image" content="https://strongduanmu.com/assets/blog/2022/02/11/1644542092.jpg"><meta property="og:image" content="https://strongduanmu.com/assets/wechat/gongzhonghao.png"><meta property="article:published_time" content="2020-01-12T01:00:00.000Z"><meta property="article:modified_time" content="2020-01-12T01:00:00.000Z"><meta property="article:author" content="端小强"><meta property="article:tag" content="Java8"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://strongduanmu.com/assets/blog/2022/02/11/1644542238.png"><meta name="twitter:creator" content="@strongduanmu"><meta name="keywords" content="Java8"><link rel="alternate" href="/atom.xml" title="端小强的博客" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=1.30.1"><link rel="shortcut icon" href="/assets/placeholder/favicon.ico"><meta name="baidu-site-verification" content="codeva-sIRwgTpHve"><link rel="apple-touch-icon" sizes="180x180" href="/assets/placeholder/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/placeholder/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/placeholder/favicon-16x16.png"><link rel="manifest" href="/assets/placeholder/site.webmanifest"><link rel="stylesheet" href="/css/custom.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaimono-bold.css" media="all" onload='this.media="all"'><link rel="stylesheet" href="/css/lxgwwenkaiscreen.css" media="all" onload='this.media="all"'></head><body><div class="l_body content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container"><header class="header"><div class="logo-wrap"><a class="avatar" href="/more/"><div class="bg" style="opacity:0;background-image:url(/assets/placeholder/rainbow64@3x.webp)"></div><img no-lazy class="avatar" src="/assets/placeholder/avatar.png" onerror="javascript:this.classList.add('error');this.src='/assets/placeholder/image.svg';"></a><a class="title" href="/"><div class="main" ff="title">端小强的博客</div><div class="sub normal cap">不积跬步，无以至千里 🤔</div><div class="sub hover cap" style="opacity:0">不积小流，无以成江海 😃</div></a></div></header><div class="nav-area"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><nav class="menu dis-select"><a class="nav-item active" title="博客" href="/"><span>博客</span></a><a class="nav-item" title="文档" href="/wiki/"><span>文档</span></a><a class="nav-item" title="便笺" href="/notes/"><span>便笺</span></a><a class="nav-item" title="更多" href="/more/"><span>更多</span></a></nav></div><div class="widgets"><widget class="widget-wrapper markdown"><div class="widget-header dis-select"><span class="name">欢迎光临</span></div><div class="widget-body fs14"><p>欢迎访问端小强的博客，本人目前专注于 <a target="_blank" rel="noopener" href="https://github.com/apache/shardingsphere">Apache ShardingSphere</a> 内核模块开发，以及 <a target="_blank" rel="noopener" href="https://github.com/apache/calcite">Apache Calcite</a> 查询优化技术的研究，本站会记录日常工作学习过程中的经验总结和知识梳理，欢迎大家留言交流。</p><div class="linklist center" style="grid-template-columns:repeat(1,1fr)"><a class="link" title="立即前往" href="/more/#comments"><div class="flex"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"></path><path fill="currentColor" d="M7.25 9A.75.75 0 0 1 8 8.25h8a.75.75 0 0 1 0 1.5H8A.75.75 0 0 1 7.25 9m0 3.5a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 0 1.5H8a.75.75 0 0 1-.75-.75"></path></svg><span>立即前往</span></div></a></div></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="mailto:duanzhengqiang@apache.org" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/email.svg"></a><a class="social" href="https://github.com/strongduanmu" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/github.svg"></a><a class="social" href="/sitemap.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/sitemap.svg"></a><a class="social" href="/atom.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/rss.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/banner/banner_1.jpg"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a></div><div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2020-01-12T01:00:00.000Z">2020-01-12</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2020-01-12T01:00:00.000Z">2020-01-12</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>Java8 新特性实战</span></h1></div></div></div></div><article class="md-text content"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>Java8 是 Oracle 公司在 2014 年 3 ⽉发布的版本，是 Java5 之后最重要的版本，带来了诸多⽅⾯的新特性，包括语⾔、类库、编译器及 JVM 等新特性。本⽂重点介绍 Java8 中语法相关的新特性，主要包括 <code>Lambda 表达式</code>、<code>Stream API</code>、<code>New Date API</code>、<code>Optional</code> 等。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/blog/2022/02/11/1644542238.png" alt="1644542238"></p><h2 id="lambda-表达式"><a class="markdownIt-Anchor" href="#lambda-表达式"></a> Lambda 表达式</h2><h3 id="什么是-lambda"><a class="markdownIt-Anchor" href="#什么是-lambda"></a> 什么是 Lambda</h3><blockquote><p>Lambda expression is a new feature which is introduced in Java 8. A lambda expression is <code>an anonymous function</code>. A function that doesn’t have a name and doesn’t belong to any class. The concept of lambda expression was first introduced in LISP programming language.</p></blockquote><p>Lambda 这个概念最早起源于 LISP 语言，Java8 中引入了这个特性，Lambda 表达式本质上是一个匿名函数，这个函数没有名称并且不属于任何类。</p><h3 id="为什么需要-lambda"><a class="markdownIt-Anchor" href="#为什么需要-lambda"></a> 为什么需要 Lambda</h3><p>在 Java8 之前的版本中，如果我们需要实现 <code>行为参数化</code>，必须将特定的行为包装在某个类中，然后将对象传递给具体方法进行执行。使用匿名内部类的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询材料库存数！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询材料门店销量！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方式写出的代码十分冗长，实际我们想要执行的其实就是 run 方法中的功能，Java8 提供了 Lambda 表达式来解决这个问题，经过 Lambda 表达式改造的代码清晰简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;查询材料库存数！&quot;</span>));</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;查询材料门店销量！&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="如何使用-lambda"><a class="markdownIt-Anchor" href="#如何使用-lambda"></a> 如何使用 Lambda</h3><p>Lambda 表达式由参数、箭头和主体组成。Lambda 的基本语法如下，有两种基本形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行语句</span></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line">executorService.execute(() -&gt; System.out.println(<span class="string">&quot;查询材料库存数！&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行语句</span></span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询材料门店销量！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询材料门店销量！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="tag-plugin image"><div class="image-bg" style="background:#fff;padding:20px"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/blog/2022/02/11/1644543745.png" data-fancybox="true" style="width:500px"></div></div><ul><li>参数列表：<code>函数式接口</code> 中的抽象方法对应的参数列表，前文例子中函数式接口为 Runnable 接口，抽象方法为 run 方法，为空参数方法；</li><li>箭头：Lambda 表达式的标志符号，用来分隔参数列表和 Lambda 主体；</li><li>Lambda 主体：功能代码块，多行需要使用 <code>花括号 &#123;&#125;</code>；</li></ul><p>那么究竟在哪里可以使用 Lambda 表达式——在函数式接口上使用 Lambda 表达式，前文示例中的 Runnable 接口就是一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接⼝</h3><p>那么什么是函数式接口呢？简单来说，就是 <code>只定义了一个抽象方法的接口</code>。Lambda 表达式允许直接以内联的方式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。</p><p>在 Java8 中，提供了 <code>@FunctionalInterface</code> 注解来专门表示函数式接口，该注解不是必须的，但是添加了该注解编译器会进行语法检查，保证接口中只能包含一个抽象方法。</p><p>观察下如下接口是否符合函数式接口的定义？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 Comparator 接口也是函数式接口？可以参考 FunctionalInterface 注解的 javadoc：</p><blockquote><p>If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.</p><p>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.</p></blockquote><p>如果一个接口中定义了一个抽象方法——重写 Object 基类中的公有方法，那么这个抽象方法不会被算入接口抽象方法的计数中，因为任何一个这个接口的实现类本来就会通过继承 Object 基类来实现该方法。</p><p>Java8 新增了 <code>java.util.function</code> 包，在 function 包中引入了一些常用的函数式接口：</p><style>.tg{border-collapse:collapse;border-color:#ccc;border-spacing:0}.tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><table class="tg"><thead><tr><th class="tg-baqh">函数式接口</th><th class="tg-baqh">函数描述符</th><th class="tg-baqh">原始类型特化</th><th class="tg-baqh">说明</th></tr></thead><tbody><tr><td class="tg-0lax">Predicate&lt;T&gt;</td><td class="tg-0lax">T -&gt; boolean</td><td class="tg-0lax">IntPredicate, LongPredicate, DoublePredicate</td><td class="tg-0lax">断言型接口</td></tr><tr><td class="tg-0lax">Consumer&lt;T&gt;</td><td class="tg-0lax">T -&gt; void</td><td class="tg-0lax">IntConsumer, LongConsumer, DoubleConsumer</td><td class="tg-0lax">消费型接口</td></tr><tr><td class="tg-0lax">Function&lt;T, R&gt;</td><td class="tg-0lax">T -&gt; R</td><td class="tg-0lax">IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;, ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt;</td><td class="tg-0lax">函数型接口</td></tr><tr><td class="tg-0lax">Supplier&lt;T&gt;</td><td class="tg-0lax">() -&gt; T</td><td class="tg-0lax">BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</td><td class="tg-0lax">供给型接口</td></tr><tr><td class="tg-0lax">UnaryOperator&lt;T&gt;</td><td class="tg-0lax">T -&gt; T</td><td class="tg-0lax">IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td><td class="tg-0lax">一元操作型接口</td></tr><tr><td class="tg-0lax">BinaryOperator&lt;T&gt;</td><td class="tg-0lax">(T, T) -&gt; T</td><td class="tg-0lax">IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td><td class="tg-0lax">二元操作型接口</td></tr><tr><td class="tg-0lax">BiPredicate&lt;L, R&gt;</td><td class="tg-0lax">(L, R) -&gt; boolean</td><td class="tg-0lax"></td><td class="tg-0lax">二元断言型接口</td></tr><tr><td class="tg-0lax">BiConsumer&lt;T, U&gt;</td><td class="tg-0lax">(T, U) -&gt; void</td><td class="tg-0lax">ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt;</td><td class="tg-0lax">二元消费型接口</td></tr><tr><td class="tg-0lax">BiFunction&lt;T, U, R&gt;</td><td class="tg-0lax">(T, U) -&gt; R</td><td class="tg-0lax">ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T, U&gt;</td><td class="tg-0lax">二元函数型接口</td></tr></tbody></table><ul><li><code>Predicate&lt;T&gt;</code>：断言型接口，抽象方法为 <code>boolean test(T t)</code>，传入一个参数，返回一个布尔值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断言型接口</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate = t -&gt; t.equals(<span class="number">30</span>);</span><br><span class="line">System.out.println(predicate.test(<span class="number">35</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言型接口原始类型特化</span></span><br><span class="line"><span class="type">IntPredicate</span> <span class="variable">intPredicate</span> <span class="operator">=</span> t -&gt; t &gt; <span class="number">30</span>;</span><br><span class="line">System.out.println(intPredicate.test(<span class="number">25</span>));</span><br></pre></td></tr></table></figure><ul><li><code>Consumer&lt;T&gt;</code>：消费型接口，抽象方法为 <code>void accept(T t)</code>，传入一个参数，没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费型接口</span></span><br><span class="line"><span class="comment">// Consumer&lt;String&gt; consumer = t -&gt; System.out.println(t);</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Function&lt;T,R&gt;</code>：函数型接口，抽象方法为 <code>R apply(T t)</code>，传入一个参数，返回另一个值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数型接口</span></span><br><span class="line"><span class="comment">// Function&lt;Integer, String&gt; function = (t) -&gt; String.valueOf(t);</span></span><br><span class="line">Function&lt;Integer, String&gt; function = String::valueOf;</span><br><span class="line">System.out.println(function.apply(<span class="number">2020</span>));</span><br></pre></td></tr></table></figure><ul><li><code>Supplier&lt;T&gt;</code>：供给型接口，抽象方法为 <code>T get()</code>，不传入参数，返回一个结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产型接口</span></span><br><span class="line">Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;2020年世界和平！&quot;</span>;</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure><ul><li><code>UnaryOperator&lt;T&gt;</code>：一元操作型接口，继承自 <code>Function&lt;T, T&gt;</code>接口，传入一个参数，返回该参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元操作型接口</span></span><br><span class="line"><span class="comment">// UnaryOperator&lt;String&gt; unaryOperator = t -&gt; t.toUpperCase();</span></span><br><span class="line">UnaryOperator&lt;Integer&gt; unaryOperator = t -&gt; t + <span class="number">1</span>;</span><br><span class="line">System.out.println(unaryOperator.apply(<span class="number">99</span>));</span><br></pre></td></tr></table></figure><h3 id="方法引用构造方法引用"><a class="markdownIt-Anchor" href="#方法引用构造方法引用"></a> ⽅法引⽤&amp;构造⽅法引⽤</h3><p>方法引用是特殊场景下 Lambda 表达式的一种简洁写法。如果某个方法刚好满足了 Lambda 表达式的形式，那么就可以用方法引用来表示 Lambda 表达式。</p><p>方法引用&amp;构造方法引用有四类：</p><ul><li><code>类名::静态方法名</code>——在 lambda 表达式中，调用了某个类的静态方法；</li><li><code>对象::实例方法名</code>——在 lambda 表达式中，调用了某个外部对象的实例方法；</li><li><code>类名::实例方法名</code>——在 lambda 表达式中，调用了 lambda 参数列表中的对象实例方法；</li><li><code>类名::new</code>——在 lambda 表达式中，调用了构造方法创建对象；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nums = Lists.newArrayList(<span class="string">&quot;-11&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;14&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名::静态方法名，在 lambda 表达式中，调用了某个类的静态方法</span></span><br><span class="line"><span class="comment">// nums.sort(Comparator.comparing(num -&gt; Integer.valueOf(num)));</span></span><br><span class="line">nums.sort(Comparator.comparing(Integer::valueOf));</span><br><span class="line">System.out.println(<span class="string">&quot;--类名::静态方法名--&quot;</span> + nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象::实例方法名，在 lambda 表达式中，调用了某个外部对象的实例方法</span></span><br><span class="line"><span class="comment">// Supplier&lt;Integer&gt; supplier = () -&gt; nums.size();</span></span><br><span class="line">Supplier&lt;Integer&gt; supplier = nums::size;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名::实例方法名，在 lambda 表达式中，调用了 lambda 参数列表中的对象实例方法</span></span><br><span class="line"><span class="comment">// nums.sort(Comparator.comparing(num -&gt; num.length()));</span></span><br><span class="line">nums.sort(Comparator.comparing(String::length));</span><br><span class="line">System.out.println(<span class="string">&quot;--类名::实例方法名--&quot;</span> + nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名::new，在 lambda 表达式中，调用了构造方法创建对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Function&lt;String, BigInteger&gt; function = new Function&lt;String, BigInteger&gt;() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public BigInteger apply(String s) &#123;</span></span><br><span class="line"><span class="comment">        return new BigInteger(s);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Function&lt;String, BigInteger&gt; function = BigInteger::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;12345678901234567890&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="stream-api"><a class="markdownIt-Anchor" href="#stream-api"></a> Stream API</h2><h3 id="什么是-stream"><a class="markdownIt-Anchor" href="#什么是-stream"></a> 什么是 Stream</h3><p>Stream API 是对集合功能的增强，借助于 Lambda 表达式，能够极大地提高编程效率和程序可读性。Stream 处理集合数据时，将要处理的元素看做一种流，流在管道中传输，并且可以在管道的节点上处理，包括筛选、去重、排序、聚合等。元素流在管道中经过中间操作的处理，最后由结束操作得到处理结果。</p><p>使用 Stream API 具有以下优势：</p><ul><li>提升性能——Stream 会记录下过程操作、并对这些操作进行叠加，最后在一个迭代循环中执行所有叠加的操作，减少迭代次数；</li><li>代码简洁——函数式编程风格的代码简洁、意图明确；</li><li>多核友好——只需调用 parallel()方法，即可实现并行程序，简化编码；</li></ul><p>使用 Stram API 前的编码风格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Staff&gt; staffs = Lists.newArrayList(Staff.builder().name(<span class="string">&quot;james&quot;</span>).age(<span class="number">35</span>).build(), Staff.builder().name(<span class="string">&quot;wade&quot;</span>).age(<span class="number">37</span>).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;kobe&quot;</span>).age(<span class="number">41</span>).build(), Staff.builder().name(<span class="string">&quot;rose&quot;</span>).age(<span class="number">31</span>).build());</span><br><span class="line">List&lt;Staff&gt; results = Lists.newArrayList();</span><br><span class="line"><span class="comment">// 筛选出年龄大于35岁的员工</span></span><br><span class="line"><span class="keyword">for</span> (Staff staff : staffs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (staff.getAge() &lt;= <span class="number">35</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    results.add(staff);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(results);</span><br></pre></td></tr></table></figure><p>使用 Stram API 后的编码风格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Staff&gt; staffs = Lists.newArrayList(Staff.builder().name(<span class="string">&quot;james&quot;</span>).age(<span class="number">35</span>).build(), Staff.builder().name(<span class="string">&quot;wade&quot;</span>).age(<span class="number">37</span>).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;kobe&quot;</span>).age(<span class="number">41</span>).build(), Staff.builder().name(<span class="string">&quot;rose&quot;</span>).age(<span class="number">31</span>).build());</span><br><span class="line"><span class="comment">// 使用 Stream API 进行筛选</span></span><br><span class="line">List&lt;Staff&gt; streamResults = staffs.stream().filter(staff -&gt; staff.getAge() &gt; <span class="number">35</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(streamResults);</span><br></pre></td></tr></table></figure><h3 id="如何创建-stream"><a class="markdownIt-Anchor" href="#如何创建-stream"></a> 如何创建 Stream</h3><p>通常创建 Stream 都是调用集合（Collection）类中的 stream()方法或者 parallelStream()方法，可以对应生成串行流和并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 List 创建 Stream</span></span><br><span class="line">Lists.newArrayList(<span class="number">123</span>, <span class="number">11</span>, <span class="number">323</span>, <span class="number">2</span>).stream().map(num -&gt; num * <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 直接从 Stream 创建</span></span><br><span class="line">Stream.of(<span class="number">123</span>, <span class="number">11</span>, <span class="number">323</span>, <span class="number">2</span>).map(num -&gt; num * <span class="number">2</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>也可以使用 IntStream、LongStream、DoubleStream 从基本类型创建 Stream，基本类型创建的 Stream 支持一些特殊的结束操作——sum()、average()、max()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 IntStream 直接创建</span></span><br><span class="line">System.out.println(IntStream.of(<span class="number">123</span>, <span class="number">11</span>, <span class="number">323</span>, <span class="number">2</span>).max().orElse(-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>Stream 和 IntStream、LongStream、DoubleStream 之间可以相互装换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Stream 转换成 IntStream</span></span><br><span class="line">Stream.of(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;323&quot;</span>, <span class="string">&quot;2&quot;</span>).mapToInt(Integer::parseInt).average().ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 从 IntStream 转换成 Stream</span></span><br><span class="line">IntStream.of(<span class="number">123</span>, <span class="number">11</span>, <span class="number">323</span>, <span class="number">2</span>).mapToObj(num -&gt; <span class="string">&quot;f6&quot;</span> + num).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="常用-stream-操作"><a class="markdownIt-Anchor" href="#常用-stream-操作"></a> 常⽤ Stream 操作</h3><p>Stream 操作具有如下特点：</p><ul><li>Stream 操作不会修改原始的数据；</li><li>操作无状态，不依赖外部变量，在 Stream 操作内部引用外部非 final 变量会报错（外部变量默认 final，修改之后会报错）；</li><li>Stream 中记录中间操作，并对这些操作进行叠加，最后在一个迭代循环中执行所有叠加的操作，生成结果；</li></ul><p>根据 Stream 操作的执行阶段，可以分为两类：</p><ul><li><code>中间操作</code>：总是会惰式执行，调用中间操作只会生成一个标记了该操作的新 Stream，中间操作的结果仍然是 Stream，可以继续使用 Stream API 连续调用。中间操作又可以分为 <code>有状态操作</code> 和 <code>无状态操作</code>，有状态操作是指该操作只有拿到所有元素之后才能继续执行，而无状态操作则不受之前元素的影响；</li><li><code>结束操作</code>：会触发实际计算，计算发生时会把所有中间操作以 pipeline 的方式执行，这样可以减少迭代次数。结束操作的结果通常是一个非 Stream 结果，计算完成之后 Stream 就会失效（<code>只能遍历一次</code>）；</li></ul><p>常用的 Stream 操作如下图：</p><style>.tg{border-collapse:collapse;border-color:#ccc;border-spacing:0}.tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal}.tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial,sans-serif;font-size:14px;font-weight:400;overflow:hidden;padding:10px 5px;word-break:normal}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><table class="tg"><thead><tr><th class="tg-baqh" colspan="3">Stream 操作分类</th></tr></thead><tbody><tr><td class="tg-baqh" rowspan="2">中间操作</td><td class="tg-baqh">无状态</td><td class="tg-0lax">unordered(), filter(), map(), mapToInt(), mapToLong(), mapToDobule(), flatMap(), flatMapToInt(), flatMapToLong(), flatMapToDobule(), peek()</td></tr><tr><td class="tg-baqh">有状态</td><td class="tg-0lax">distinct(), sorted(), limit(), skip()</td></tr><tr><td class="tg-baqh" rowspan="2">结束操作</td><td class="tg-baqh">非短路操作</td><td class="tg-0lax">forEach(), forEachOrdered(), toArray(), reduce(), collect(), max(), min(), count()</td></tr><tr><td class="tg-baqh">短路操作</td><td class="tg-0lax">anyMatch(), allMatch(), noneMatch(), findFirst(), findAny()</td></tr></tbody></table><h4 id="常用的中间操作"><a class="markdownIt-Anchor" href="#常用的中间操作"></a> 常⽤的中间操作</h4><ul><li>filter——根据 Predicate 条件，过滤出符合条件的元素：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤绝对值开根号大于15的数字</span></span><br><span class="line">Lists.newArrayList(<span class="number">112</span>, <span class="number">131</span>, <span class="number">323</span>, <span class="number">234</span>, <span class="number">730</span>, <span class="number">177</span>, -<span class="number">226</span>, <span class="number">434</span>)</span><br><span class="line">        .stream().filter(num -&gt; Math.sqrt(Math.abs(num)) &gt; <span class="number">15</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>sorted——对集合中的元素进行排序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串装换成数字排序</span></span><br><span class="line">List&lt;String&gt; nums = Lists.newArrayList(<span class="string">&quot;112&quot;</span>, <span class="string">&quot;131&quot;</span>, <span class="string">&quot;323&quot;</span>, <span class="string">&quot;234&quot;</span>, <span class="string">&quot;730&quot;</span>, <span class="string">&quot;177&quot;</span>, <span class="string">&quot;-226&quot;</span>, <span class="string">&quot;434&quot;</span>);</span><br><span class="line">nums.stream().sorted(Comparator.comparingInt(Integer::parseInt)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>map——对集合中的每个元素按照 mapper 操作进行转换，转换前后 Stream 中元素的个数不会改变，但元素的类型取决于转换之后的类型：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map操作：对集合中的每个元素按照 mapper 操作进行转换</span></span><br><span class="line">Lists.newArrayList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>, <span class="string">&quot;a4&quot;</span>, <span class="string">&quot;a5&quot;</span>).stream().map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>flatMap——map 方法只能把一个对象转换成另一个对象，如果需要将一个对象转换成多个，需要使用 flatMap：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap 操作：找出所有员工的兴趣爱好</span></span><br><span class="line">List&lt;Staff&gt; staffs = Lists.newArrayList(Staff.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">18</span>).hobbies(Lists.newArrayList(<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;围棋&quot;</span>)).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;李四&quot;</span>).age(<span class="number">27</span>).hobbies(Lists.newArrayList(<span class="string">&quot;书法&quot;</span>, <span class="string">&quot;围棋&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>)).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;王五&quot;</span>).age(<span class="number">33</span>).hobbies(Lists.newArrayList(<span class="string">&quot;品茶&quot;</span>, <span class="string">&quot;读书&quot;</span>, <span class="string">&quot;篮球&quot;</span>)).build());</span><br><span class="line">Set&lt;String&gt; hobbies = staffs.stream().map(Staff::getHobbies).flatMap(Collection::stream).collect(Collectors.toSet());</span><br><span class="line">System.out.println(hobbies);</span><br></pre></td></tr></table></figure><h4 id="常用的结束操作"><a class="markdownIt-Anchor" href="#常用的结束操作"></a> 常用的结束操作</h4><ul><li>forEach——对每一个元素的执行指定的 action 操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void forEach(Consumer&lt;? super T&gt; action)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 操作：对每一个元素的执行指定的 action 操作</span></span><br><span class="line">Lists.newArrayList(<span class="number">112</span>, <span class="number">131</span>, <span class="number">323</span>, <span class="number">234</span>, <span class="number">730</span>, <span class="number">177</span>, -<span class="number">226</span>, <span class="number">434</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>collect——collect 方法接收一个 Collector 参数，Collector 可以将 Stream 转换成集合，如 List、Set 或 Map。JDK 内置了很多常用的 Collector，大多数场景下不需要自己实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 操作：将 Stream 转换成集合，如：List、Set、Map</span></span><br><span class="line"><span class="comment">// Map&lt;String, Staff&gt; staffMap = staffs.stream().collect(Collectors.toMap((Staff::getName), Function.identity()));</span></span><br><span class="line">Map&lt;String, Staff&gt; staffMap = staffs.stream().collect(Collectors.toMap((Staff::getName), Function.identity(), (oldValue, newValue) -&gt; newValue));</span><br><span class="line">System.out.println(staffMap);</span><br></pre></td></tr></table></figure><p>将 Stream 元素转换成 map 的时候，需要特别注意：key 必须是唯一的，否则会抛出 IllegalStateException 。如果想主动规避这个问题，需要我们传入一个 merge function，来指定重复的元素映射的方式。也可以使用 Collectors.groupingBy()，按照指定 key 分组的方式来代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collect 操作：按照指定 key 分组</span></span><br><span class="line">Map&lt;String, List&lt;Staff&gt;&gt; staffsMap = staffs.stream().collect(Collectors.groupingBy((Staff::getName)));</span><br><span class="line">System.out.println(staffsMap);</span><br></pre></td></tr></table></figure><ul><li>reduce——reduce 操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是 reduce 操作，将他们单独设为函数方便日常使用。redeue 方法定义了三种重载形式：</li></ul><p>第一种方法声明为：<code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</code> 参数为累加器，返回值为 Optional 对象，通过 accumulator 计算得到一个最终结果，通过 Optional 对象中返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现#号拼接字符串</span></span><br><span class="line"><span class="comment">// 第一次执行时第一个参数是 Stream 中的第一个元素，第二个参数是 Stream 参数中的第二个元素</span></span><br><span class="line"><span class="comment">// 后面每次执行的中间结果赋给第一个参数，然后第二个参数为 Stream 中的下一个元素，依次执行，最后返回一个 Optional</span></span><br><span class="line">Lists.newArrayList(<span class="string">&quot;d4&quot;</span>, <span class="string">&quot;c3&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;f5&quot;</span>).stream().sorted().reduce((s1, s2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;s1:&quot;</span> + s1);</span><br><span class="line">    System.out.println(<span class="string">&quot;s2:&quot;</span> + s2);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s1 + <span class="string">&quot;#&quot;</span> + s2;</span><br><span class="line">&#125;).ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">s1:a1</span><br><span class="line">s2:b2</span><br><span class="line">--------</span><br><span class="line">s1:a1#b2</span><br><span class="line">s2:c3</span><br><span class="line">--------</span><br><span class="line">s1:a1#b2#c3</span><br><span class="line">s2:d4</span><br><span class="line">--------</span><br><span class="line">s1:a1#b2#c3#d4</span><br><span class="line">s2:f5</span><br><span class="line">--------</span><br><span class="line">a1#b2#c3#d4#f5</span><br></pre></td></tr></table></figure><p>第二种方法声明为：<code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</code> 新增了一个初始化类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次执行时第一个参数是指定的初始对象，第二个参数是 Stream 参数中的第一个元素</span></span><br><span class="line"><span class="comment">// 后面每次执行的中间结果赋给第一个参数，然后第二个参数为 Stream 中的下一个元素，依次执行，最后返回一个和初始值类型相同的结果</span></span><br><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce(<span class="number">10</span>, (p1, p2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;p1:&quot;</span> + p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;p2:&quot;</span> + p2);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">p1:<span class="number">10</span></span><br><span class="line">p2:<span class="number">1</span></span><br><span class="line">--------</span><br><span class="line">p1:<span class="number">11</span></span><br><span class="line">p2:<span class="number">2</span></span><br><span class="line">--------</span><br><span class="line">p1:<span class="number">13</span></span><br><span class="line">p2:<span class="number">3</span></span><br><span class="line">--------</span><br><span class="line">p1:<span class="number">16</span></span><br><span class="line">p2:<span class="number">4</span></span><br><span class="line">--------</span><br><span class="line">p1:<span class="number">20</span></span><br><span class="line">p2:<span class="number">5</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p>第三种方法声明为：<code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</code> 在初始对象和累加器基础上，添加了组合器 combiner。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种方式，求单词长度之和，使用串行流和并行流分别执行</span></span><br><span class="line">System.out.println(Stream.of(<span class="string">&quot;d4&quot;</span>, <span class="string">&quot;c3&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;f5&quot;</span>).reduce(<span class="number">0</span>, (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;BiFunction--&quot;</span> + threadName);</span><br><span class="line">    System.out.println(<span class="string">&quot;o1:&quot;</span> + o1 + <span class="string">&quot;--&quot;</span> + threadName);</span><br><span class="line">    System.out.println(<span class="string">&quot;o2:&quot;</span> + o2 + <span class="string">&quot;--&quot;</span> + threadName);</span><br><span class="line">    <span class="keyword">return</span> o1 + o2.length();</span><br><span class="line">&#125;, (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;BinaryOperator--&quot;</span> + threadName);</span><br><span class="line">    System.out.println(<span class="string">&quot;o1:&quot;</span> + o1 + <span class="string">&quot;--&quot;</span> + threadName);</span><br><span class="line">    System.out.println(<span class="string">&quot;o2:&quot;</span> + o2 + <span class="string">&quot;--&quot;</span> + threadName);</span><br><span class="line">    <span class="keyword">return</span> o1 + o2;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">0</span>--main</span><br><span class="line">o2:d4--main</span><br><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">2</span>--main</span><br><span class="line">o2:c3--main</span><br><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">4</span>--main</span><br><span class="line">o2:a1--main</span><br><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">6</span>--main</span><br><span class="line">o2:b2--main</span><br><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">8</span>--main</span><br><span class="line">o2:f5--main</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>执行以上的案例发现 BinaryOperator 并没有执行，此时的操作与第二种方式类似，我们将 Stream 转换为并行流再尝试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BiFunction--main</span><br><span class="line">o1:<span class="number">0</span>--main</span><br><span class="line">o2:a1--main</span><br><span class="line">BiFunction--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o1:<span class="number">0</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o2:d4--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">BiFunction--ForkJoinPool.commonPool-worker-<span class="number">2</span></span><br><span class="line">o1:<span class="number">0</span>--ForkJoinPool.commonPool-worker-<span class="number">2</span></span><br><span class="line">o2:f5--ForkJoinPool.commonPool-worker-<span class="number">2</span></span><br><span class="line">BiFunction--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o1:<span class="number">0</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o2:b2--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">BinaryOperator--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o1:<span class="number">2</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o2:<span class="number">2</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">BinaryOperator--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o1:<span class="number">2</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">o2:<span class="number">4</span>--ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">BiFunction--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o1:<span class="number">0</span>--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o2:c3--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">BinaryOperator--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o1:<span class="number">2</span>--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o2:<span class="number">2</span>--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">BinaryOperator--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o1:<span class="number">4</span>--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">o2:<span class="number">6</span>--ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>发现在并行流中，BinaryOperator 执行了，查阅资料发现，为了避免并行竞争，将每个线程的任务单独维护了一个结果，然后通过组合器 combiner 进行最终结果的合并。</p><ul><li>match——用来判断某一种规则是否与流对象匹配。所有的匹配操作都是结束操作，只返回一个 boolean 类型的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match操作：用来判断某一种规则是否与流对象匹配</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> staffs.stream().anyMatch((staff) -&gt; staff.getName().startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">System.out.println(anyMatch);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> staffs.stream().allMatch((staff) -&gt; staff.getAge().equals(<span class="number">34</span>));</span><br><span class="line">System.out.println(allMatch);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> staffs.stream().noneMatch((staff) -&gt; staff.getAge().equals(<span class="number">34</span>));</span><br><span class="line">System.out.println(noneMatch);</span><br></pre></td></tr></table></figure><h2 id="new-date-api"><a class="markdownIt-Anchor" href="#new-date-api"></a> New Date API</h2><p>Java8 另一项新特性是新的时间和日期 API，它们被包含在 java.time 包中。借助新的时间和日期 API 可以更简洁地处理时间和日期。</p><h3 id="为什么需要-new-date-api"><a class="markdownIt-Anchor" href="#为什么需要-new-date-api"></a> 为什么需要 New Date API</h3><p>在 Java8 之前的时间和日期 API 有很多缺陷，具体如下：</p><ul><li><p>Java 的 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 类易用性差，而且不是线程安全的；</p></li><li><p>对日期的计算方式繁琐，容易出错——月份是从 0 开始的，从 Calendar 中获取的月份需要加一才能表示当前月份；</p></li></ul><p>由于以上这些问题，Java 社区出现了一些第三方时间日期库——Joda-Time，Java8 充分借鉴了 Joda 库的一些优点，提供了一套新的时间和日期 API。</p><h3 id="日期时间类"><a class="markdownIt-Anchor" href="#日期时间类"></a> 日期&amp;时间类</h3><p>Java8 中常用的日期和时间类主要有 LocalDate、LocalTime、LocalDateTime、Instant、Duration 和 Period。</p><ul><li>LocalDate、LocalTime、LocalDateTime</li></ul><p>LocalDate 类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过 LocalDate 的静态方法 of() 创建一个实例，LocalDate 也包含一些方法用来获取年份、月份、天、星期几等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 年份 2020</span></span><br><span class="line">System.out.println(localDate.getYear());</span><br><span class="line"><span class="comment">// 年份中第几天 10</span></span><br><span class="line">System.out.println(localDate.getDayOfYear());</span><br><span class="line"><span class="comment">// 月份 JANUARY</span></span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> localDate.getMonth();</span><br><span class="line">System.out.println(month);</span><br><span class="line"><span class="comment">// 月份中的第几天 10</span></span><br><span class="line">System.out.println(localDate.getDayOfMonth());</span><br><span class="line"><span class="comment">// 一周的第几天：FRIDAY</span></span><br><span class="line">System.out.println(localDate.getDayOfWeek());</span><br><span class="line"><span class="comment">// 月份的天数 31</span></span><br><span class="line">System.out.println(localDate.lengthOfMonth());</span><br><span class="line"><span class="comment">// 是否为闰年 true</span></span><br><span class="line">System.out.println(localDate.isLeapYear());</span><br></pre></td></tr></table></figure><p>LocalTime 和 LocalDate 类似，他们之间的区别在于 LocalDate 不包含具体时间，而 LocalTime 包含具体时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个时间：17:50:40</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.of(<span class="number">17</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">// 时：17</span></span><br><span class="line">System.out.println(localTime.getHour());</span><br><span class="line"><span class="comment">// 分：50</span></span><br><span class="line">System.out.println(localTime.getMinute());</span><br><span class="line"><span class="comment">// 秒：40</span></span><br><span class="line">System.out.println(localTime.getSecond());</span><br></pre></td></tr></table></figure><p>LocalDateTime 类是 LocalDate 和 LocalTime 的结合体，可以通过 of()方法直接创建，也可以调用 LocalDate 的 atTime() 方法或 LocalTime 的 atDate() 方法将 LocalDate 或 LocalTime 合并成一个 LocalDateTime：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, Month.JANUARY, <span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, Month.JANUARY, <span class="number">10</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.of(<span class="number">17</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">combineLocalDateTime</span> <span class="operator">=</span> localDate.atTime(localTime);</span><br><span class="line"><span class="comment">// LocalDateTime combineLocalDateTime = localTime.atDate(localDate);</span></span><br><span class="line"><span class="comment">// 从 LocalDateTime 中获取年月日时分秒</span></span><br><span class="line">System.out.println(combineLocalDateTime.getYear());</span><br><span class="line">System.out.println(combineLocalDateTime.getMonth());</span><br><span class="line">System.out.println(combineLocalDateTime.getDayOfMonth());</span><br><span class="line">System.out.println(combineLocalDateTime.getHour());</span><br><span class="line">System.out.println(combineLocalDateTime.getMinute());</span><br><span class="line">System.out.println(combineLocalDateTime.getSecond());</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime 转化成 LocalDate 或 LocalTime</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">transferLocalDate</span> <span class="operator">=</span> localDateTime.toLocalDate();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">transferLocalTime</span> <span class="operator">=</span> localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure><ul><li>Instant——Instant 用于表示一个时间戳，可以精确到纳秒，可以使用 now() 方法创建，也可以通过 ofEpochSecond() 方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instant可以使用 now() 方法创建，也可以通过 ofEpochSecond 方法创建</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">// 2020-01-12T16:16:41.723Z</span></span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofEpochSecond 方法第一个参数表示从 1970-01-01 00:00:00 开始到现在的秒数</span></span><br><span class="line"><span class="comment">// ofEpochSecond 方法第二个参数表示纳秒数，0~999,999,999</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">9999</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 1970-01-01T02:46:39.000001Z</span></span><br><span class="line">System.out.println(instant);</span><br></pre></td></tr></table></figure><ul><li>Duration——Duration 表示一个时间段，可以通过 Duration.between() 或 Duration.of() 方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 of 创建 Duration，统一一个单位设置</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.of(<span class="number">7</span>, ChronoUnit.DAYS);</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration2</span> <span class="operator">=</span> Duration.of(<span class="number">3000</span>, ChronoUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2018-07-03 09:00:00</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, Month.JULY, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2020-01-13 18:00:00</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, Month.JANUARY, <span class="number">13</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总天数</span></span><br><span class="line">System.out.println(duration.toDays());</span><br><span class="line"><span class="comment">// 总小时数</span></span><br><span class="line">System.out.println(duration.toHours());</span><br><span class="line"><span class="comment">// 总分钟数</span></span><br><span class="line">System.out.println(duration.toMinutes());</span><br><span class="line"><span class="comment">// 总秒数</span></span><br><span class="line">System.out.println(duration.getSeconds());</span><br></pre></td></tr></table></figure><ul><li>Period——Period 和 Duration 类似，不同之处在于 Period 是以年月日来衡量一个时间段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建2年3个月6天的范围，年月日单独字段设置</span></span><br><span class="line"><span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 2018-07-03 到 2020-01-13</span></span><br><span class="line"><span class="type">Period</span> <span class="variable">period2</span> <span class="operator">=</span> Period.between(LocalDate.of(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">3</span>), LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">13</span>));</span><br><span class="line">System.out.println(period2.getYears());</span><br><span class="line">System.out.println(period2.getMonths());</span><br><span class="line">System.out.println(period2.getDays());</span><br></pre></td></tr></table></figure><h3 id="日期操作和格式化"><a class="markdownIt-Anchor" href="#日期操作和格式化"></a> 日期操作和格式化</h3><ul><li>日期操作——常用的日期操作有增减天数、月数，查找本月最后一个周五等操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2019-12-01</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 修改日期为 2020-01-13 2020-01-13</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">newDate</span> <span class="operator">=</span> date.withYear(<span class="number">2020</span>).withMonth(<span class="number">1</span>).withDayOfMonth(<span class="number">13</span>);</span><br><span class="line">System.out.println(newDate);</span><br><span class="line"><span class="comment">// 增加一年，减一个月，加十天 2020-12-23</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> newDate.plusYears(<span class="number">1</span>).minusMonths(<span class="number">1</span>).plus(<span class="number">10</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找本月最后一个周五 2020-01-31</span></span><br><span class="line">System.out.println(LocalDate.now().with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY)));</span><br></pre></td></tr></table></figure><ul><li>日期格式化——新的日期 API 中提供了一个 DateTimeFormatter 类用于处理日期格式化操作，日期类中调用 format() 方法，传入 DateTimeFormatter 参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20200113</span></span><br><span class="line">System.out.println(LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE));</span><br><span class="line"><span class="comment">// 2020-01-13</span></span><br><span class="line">System.out.println(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE));</span><br><span class="line"><span class="comment">// 11:02:38.148</span></span><br><span class="line">System.out.println(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME));</span><br><span class="line"><span class="comment">// 2020-01-13</span></span><br><span class="line">System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> Optional</h2><h3 id="什么是-optional"><a class="markdownIt-Anchor" href="#什么是-optional"></a> 什么是 Optional</h3><p>在 Optional 出现之前，Java 的 NullPointerException 问题令人头疼，我们需要手动添加很多判空逻辑：</p><div class="tag-plugin image"><div class="image-bg" style="background:#2b2b2b;padding:20px"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/blog/2022/02/11/1644542092.jpg" data-fancybox="true" style="width:600px"></div></div><p>为了减少这样的 null 值判断，Java8 借鉴了 Guava Optional，提供了新的 Optional 容器。根据官方文档定义，Optional 是一个容器对象，容器中可能包含也可能不包含一个非空对象。如果对象存在，isPresent() 将会返回 true，get()方法将会返回一个值。</p><blockquote><p>A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.</p></blockquote><h3 id="如何使用-optional"><a class="markdownIt-Anchor" href="#如何使用-optional"></a> 如何使用 Optional</h3><ul><li>of、ofNullable——分别为非 null 值和可为 null 值创建一个 Optional：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 of 为非 null 值创建 Optional，ofNullable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> LocalDate.now().isAfter(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">10</span>)) ? <span class="literal">null</span> : <span class="number">0</span>;</span><br><span class="line">Optional&lt;String&gt; nameOptional = Optional.of(name);</span><br><span class="line">Optional&lt;Integer&gt; ageOptional = Optional.ofNullable(age);</span><br></pre></td></tr></table></figure><ul><li>isPresent——判断 Optional 中是否存在值，存在则返回 true，不存在则返回 false：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 isPresent 判断 Optional 是否存在值</span></span><br><span class="line">System.out.println(nameOptional.isPresent());</span><br><span class="line">System.out.println(ageOptional.isPresent());</span><br></pre></td></tr></table></figure><ul><li>ifPresent——如果存在值则执行函数式接口 Consumer 中的逻辑，否则不操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nameOptional.ifPresent(value -&gt; System.out.println(value));</span></span><br><span class="line">nameOptional.ifPresent(System.out::println);</span><br><span class="line">ageOptional.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure><ul><li>get——如果有值直接返回，否则抛出 NoSuchElementException 异常：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(nameOptional.get());</span><br><span class="line"><span class="comment">// NoSuchElementException: No value present</span></span><br><span class="line"><span class="comment">// System.out.println(ageOptional.get());</span></span><br></pre></td></tr></table></figure><ul><li>orElse、orElseGet、orElseThrow——orElse 有值则直接返回，为 null 时返回参数设置的默认值；orElseGet 方法与 orElse 方法类似，只是提供了一个函数式接口 Supplier，用来生成默认值；orElseThrow 允许传入一个 Lambda 表达式，来指定为空时抛出异常信息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orElse 设置为空时的默认值</span></span><br><span class="line">System.out.println(nameOptional.orElse(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">System.out.println(ageOptional.orElse(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// orElseGet 设置为空时的默认值</span></span><br><span class="line">System.out.println(ageOptional.orElseGet(() -&gt; <span class="number">20</span>));</span><br><span class="line"><span class="comment">// orElseThrow 设置为空时抛出的异常</span></span><br><span class="line">System.out.println(ageOptional.orElseThrow(RuntimeException::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><ul><li>map、flatMap——map 允许传入一个 Function 对原始值进行转化，生成一个新的值，然后返回 Optional；flatMap 用法类似，只是传入的 lambda 表达式要求返回值为 Optional：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 map、flatMap 映射得到 Optional</span></span><br><span class="line">nameOptional.map(value -&gt; value.replace(<span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>)).ifPresent(System.out::println);</span><br><span class="line">nameOptional.flatMap(value -&gt; Optional.of(value.replace(<span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>))).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>filter——通过传入的条件 Predicate 对原始值进行过滤，然后返回 Optional：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 filter 对原始值进行过滤</span></span><br><span class="line">System.out.println(nameOptional.filter(value -&gt; value.length() &gt; <span class="number">2</span>).isPresent());</span><br></pre></td></tr></table></figure><h3 id="使用-optional-的注意事项"><a class="markdownIt-Anchor" href="#使用-optional-的注意事项"></a> 使用 Optional 的注意事项</h3><ul><li>不要将 Optional 作为方法参数传递——使用 Optional 作为方法参数传递，如果使用方法时传递了 null，那么这时候就会 NullPointerException，我们不得不加上非空判断，这样就违背了引入 Optional 的初衷；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据名称过滤员工</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staffs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Staff&gt; <span class="title function_">filterStaffByNameAndAge</span><span class="params">(List&lt;Staff&gt; staffs, String name, Optional&lt;Integer&gt; age)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staffs.stream()</span><br><span class="line">            .filter(p -&gt; p.getName().equals(name))</span><br><span class="line">            .filter(p -&gt; p.getAge() &gt;= age.orElse(<span class="number">0</span>))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Optional 的注意事项——不要作为方法参数传递</span></span><br><span class="line">List&lt;Staff&gt; staffs = Lists.newArrayList(Staff.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">18</span>).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;李四&quot;</span>).age(<span class="number">27</span>).hobbies(Lists.newArrayList(<span class="string">&quot;书法&quot;</span>, <span class="string">&quot;围棋&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>)).build(),</span><br><span class="line">        Staff.builder().name(<span class="string">&quot;王五&quot;</span>).age(<span class="number">35</span>).hobbies(Lists.newArrayList(<span class="string">&quot;读书&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;爬山&quot;</span>)).build());</span><br><span class="line">filterStaffByNameAndAge(staffs, <span class="string">&quot;李四&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>不要将 Optional 作为类中的成员变量，因为 Optional 不支持序列化；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Optional 的注意事项——不要作为类中的字段，不支持序列化</span></span><br><span class="line"><span class="type">Staff</span> <span class="variable">staff</span> <span class="operator">=</span> Staff.builder().name(<span class="string">&quot;张三&quot;</span>).telephoneNumber(Optional.of(<span class="string">&quot;12345678900&quot;</span>)).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// java.io.NotSerializableException: java.util.Optional</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br><span class="line">    outputStream.writeObject(staff);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2><ul><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b800057f2d8">Java 8 的新特性—终极版</a></li><li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1#heading-7">Java8 新特性，你应该了解这些</a></li><li><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-optional">Guide To Java 8 Optional</a></li><li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cc124a95188252d891d00f2">一文带你玩转 Java8 Stream 流，从此操作集合 So Easy</a></li></ul><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">欢迎关注</span><span class="empty"></span></p></div><p>欢迎关注「<strong>端小强的博客</strong>」微信公众号，会不定期分享日常学习和工作经验，欢迎大家关注交流。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/wechat/gongzhonghao.png" alt="微信公众号"></p><div class="article-footer fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">署名-非商业性使用-禁止演绎 4.0 国际</a> 许可协议，未经授权请勿转载。</p></div></section><section id="share"><div class="header"><span>分享文章</span></div><div class="body"><div class="link"><input class="copy-area" readonly id="copy-link" value="https://strongduanmu.com/blog/java-8-new-features-in-action.html"></div><div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://strongduanmu.com/blog/java-8-new-features-in-action.html&title=Java8 新特性实战 - 端小强的博客&pics=/assets/blog/2022/02/10/1644493506.jpg&summary= 前言
Java8 是 Oracle 公司在 2014 年 3 ⽉发布的版本，是 Java5 之后最重要的版本，带来了诸多⽅⾯的新特性，包括语⾔、类库、编译器及 JVM 等新特性。本⽂重点介绍 Java8 中语法相关的新特性，主要包括..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=Java8 新特性实战 - 端小强的博客&amp;body=https://strongduanmu.com/blog/java-8-new-features-in-action.html"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div><div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://strongduanmu.com/blog/java-8-new-features-in-action.html"></div></div></section></div></article><div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/blog/download-ding-talk-video-by-charles.html">Charles 抓包下载钉钉群直播视频</a></div><div class="item" id="next"></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="strongduanmu/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkzNzQwMDk3Njg=" data-category="Announcements" data-category-id="DIC_kwDOFkrvqM4CZIsa" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">文档</span><a href="/wiki/calcite/background.html">Calcite</a><a href="/wiki/cmu_15_445/index.html">CMU 15-445</a><a href="/wiki/cmu_15_721/index.html">CMU 15-721</a></div><div class="sitemap-group"><span class="fs15">便笺</span><a href="/notes/">Common</a><a href="/notes/docker.html">Docker</a><a href="/notes/git.html">Git</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/more/">关于</a><a href="/more/news/">动态</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://github.com/strongduanmu">@strongduanmu</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建，使用 <a target="_blank" rel="noopener" href="https://vercel.com/">Vercel</a> 网站部署。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br>本站总访问量 <span id="vercount_value_site_pv"></span> 次，本站访客数 <span id="vercount_value_site_uv"></span> 人次。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-lambda"><span class="toc-text">什么是 Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-lambda"><span class="toc-text">为什么需要 Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-lambda"><span class="toc-text">如何使用 Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数式接⼝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">⽅法引⽤&amp;构造⽅法引⽤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stream-api"><span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-stream"><span class="toc-text">什么是 Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-stream"><span class="toc-text">如何创建 Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-stream-%E6%93%8D%E4%BD%9C"><span class="toc-text">常⽤ Stream 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">常⽤的中间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%93%E6%9D%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">常用的结束操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-date-api"><span class="toc-text">New Date API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-new-date-api"><span class="toc-text">为什么需要 New Date API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-text">日期&amp;时间类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">日期操作和格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#optional"><span class="toc-text">Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-optional"><span class="toc-text">什么是 Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-optional"><span class="toc-text">如何使用 Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-optional-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用 Optional 的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-text">参考文档</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget></div></aside><div class="float-panel blur"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"codeblock":true,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"/assets/placeholder/avatar.svg",cover:"/assets/placeholder/cover.svg"},deps={jquery:"https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js",marked:"https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js"}</script><script>function RunItem(){function n(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let s=e,i=new n(s=r?()=>{utils.requestAnimationFrame(e)}:s,t);this.list.push(i)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,s)=>{var i,n,a=window.document,o=a.createElement("link"),d=(n=t||(i=(a.body||a.getElementsByTagName("head")[0]).childNodes)[i.length-1],a.styleSheets);if(s)for(var l in s)s.hasOwnProperty(l)&&o.setAttribute(l,s[l]);o.rel="stylesheet",o.href=e,o.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){n.parentNode.insertBefore(o,t?n:n.nextSibling)});function u(e){for(var t=o.href,r=d.length;r--;)if(d[r].href===t)return e();setTimeout(function(){u(e)})}function h(){o.addEventListener&&o.removeEventListener("load",h),o.media=r||"all"}return o.addEventListener&&o.addEventListener("load",h),o.onloadcssdefined=u,u(h),o},js:(i,n)=>new Promise((t,e)=>{var r=document.createElement("script");if(i.startsWith("/")&&(i=ctx.root+i.substring(1)),r.src=i,n)for(var s of Object.keys(n))r[s]=n[s];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(n,a,o,d)=>{let l=3;utils.onLoading(n),function i(){new Promise((t,e)=>{let r=0,s=setTimeout(()=>{0===r&&(r=2,s=null,e("请求超时"),0==l)&&d()},5e3);fetch(a).then(function(e){if(2!==r&&(clearTimeout(s),t(e),s=null,r=1),e.ok)return e.json();throw new Error("Network response was not ok.")}).then(function(e){l=0,utils.onLoadSuccess(n),o(e)}).catch(function(e){0<l?(--l,setTimeout(()=>{i()},5e3)):(utils.onLoadFailure(n),d())})})}()},requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script src="/js/main.js?v=1.30.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e),applyThemeToGiscus(e)},applyThemeToGiscus=e=>{e="auto"===e?"preferred_color_scheme":e;var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let n=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<n.length;++e){var s=n[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=o(i)+":"+o(t)}}function o(e){return e<10?"0"+e:e}0<n.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="/js/flying-pages.min.js"></script><script defer src="/js/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy"},window.addEventListener("LazyLoad::Initialized",function(n){window.lazyLoadInstance=n.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()})</script><script>ctx.fancybox={selector:"article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)",css:"/css/fancybox.min.css",js:"/js/fancybox.umd.min.js"};var selector="[data-fancybox]:not(.error)",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let e=document.getElementsByClassName("ds-memos");null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(e,t)=>t.triggerEl.alt||t.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let i=document.getElementById("swiper-api");null!=i&&(utils.css("/css/swiper-bundle.min.css"),utils.js("/js/swiper-bundle.min.js",{defer:!0}).then(function(){var e=i.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"复制代码",success_text:"复制成功",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script async>((a,t,c)=>{t.ChatraID="PHWnu7Bamcwtbnx2d";var h=a.createElement("script");t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},h.async=!0,h.src="https://call.chatra.io/chatra.js",a.head&&a.head.appendChild(h)})(document,window,"Chatra")</script><script defer src="https://cn.vercount.one/js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>window.va=window.va||function(){(window.vaq=window.vaq||[]).push(arguments)}</script><script defer src="/_vercel/insights/script.js"></script><script>window.si=window.si||function(){(window.siq=window.siq||[]).push(arguments)}</script><script defer src="/_vercel/speed-insights/script.js"></script><script>function change_banner(){$(".banner img.bg").attr("src","/assets/banner/banner_"+Math.floor(20*Math.random()+1)+".jpg")}setTimeout("change_banner()",250)</script><script>function add_page_pv(){$("#post-meta").after('<div class="flex-row" id="post-meta"><span class="text created">本文总阅读量 <span id="vercount_value_page_pv"></span> 次</span></div>')}setTimeout("add_page_pv()",500)</script><script>function change_img_alt(){$("article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)").each(function(t){$(this).after("<div class='image-meta' style='text-align:center;'><span class='image-caption center' style='display:inline-block;font-size:.8125rem;color:var(--text-p2);line-height:1.5;text-align:justify;'>"+($(this).attr("title")||$(this).attr("alt"))+"</span></div>")})}setTimeout("change_img_alt()",1e3)</script></div></body></html>