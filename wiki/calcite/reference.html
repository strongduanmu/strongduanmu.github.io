<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.30.1" theme-name="Stellar" theme-version="1.30.1"><meta name="generator" content="Hexo 7.3.0"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="preconnect" href="https://pagead2.googlesyndication.com" crossorigin><link rel="preconnect" href="https://googleads.g.doubleclick.net" crossorigin><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"><meta name="theme-color" content="#f9fafb"><title>Calcite：参考指南 - 端小强的博客</title><meta name="description" content="原文链接：https:&#x2F;&#x2F;calcite.apache.org&#x2F;docs&#x2F;reference.html  该页面描述了 Calcite 的默认 SQL 解析器识别的 SQL 方言。  语法 SQL 语法采用了 BNF 风格。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474"><meta property="og:type" content="website"><meta property="og:title" content="参考指南"><meta property="og:url" content="https://strongduanmu.com/wiki/calcite/reference.html"><meta property="og:site_name" content="端小强的博客"><meta property="og:description" content="原文链接：https:&#x2F;&#x2F;calcite.apache.org&#x2F;docs&#x2F;reference.html  该页面描述了 Calcite 的默认 SQL 解析器识别的 SQL 方言。  语法 SQL 语法采用了 BNF 风格。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://strongduanmu.com/assets/blog/blog/202309210909027.png"><meta property="article:published_time" content="2026-01-22T00:00:00.000Z"><meta property="article:modified_time" content="2026-01-22T00:00:00.000Z"><meta property="article:author" content="端小强"><meta property="article:tag" content="ShardingSphere"><meta property="article:tag" content="Calcite"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://strongduanmu.com/assets/blog/blog/202309210909027.png"><meta name="twitter:creator" content="@strongduanmu"><meta name="keywords" content="ShardingSphere,Calcite"><link rel="alternate" href="/atom.xml" title="端小强的博客" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=1.30.1"><link rel="shortcut icon" href="/assets/placeholder/favicon.ico"><meta name="baidu-site-verification" content="codeva-sIRwgTpHve"><link rel="apple-touch-icon" sizes="180x180" href="/assets/placeholder/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/placeholder/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/placeholder/favicon-16x16.png"><link rel="manifest" href="/assets/placeholder/site.webmanifest"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/lxgwwenkaimono-bold.css" media="print" onload='this.media="all"'><noscript><link rel="stylesheet" href="/css/lxgwwenkaimono-bold.css"></noscript><link rel="stylesheet" href="/css/lxgwwenkaiscreen.css" media="print" onload='this.media="all"'><noscript><link rel="stylesheet" href="/css/lxgwwenkaiscreen.css"></noscript><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://pagead2.googlesyndication.com"><link rel="dns-prefetch" href="https://pagead2.googlesyndication.com"><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9880881761323734" crossorigin="anonymous"></script><script src="/js/plugins/article-bottom-ad.js"></script><script src="/js/plugins/sticky-adsense.js"></script><script src="/js/plugins/adblock-detector.js"></script><style>.widget-wrapper.adsense{background:0 0!important}.widget-wrapper.adsense .widget-body{padding:0!important;background:0 0!important}.widget-wrapper.adsense .widget-body p{margin:0!important}.widget-wrapper.adsense ins.adsbygoogle{display:block;border-radius:12px;overflow:hidden}.article-bottom-ad{margin:2rem 0;padding:1rem;text-align:center}.article-bottom-ad .ad-container{max-width:100%;margin:0 auto}.article-bottom-ad ins.adsbygoogle{display:block;background:0 0}</style></head><body><div class="l_body content tech" id="start" layout="wiki"><aside class="l_left"><div class="leftbar-container"><header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/assets/blog/2021/07/01/1625102427.jpg" onerror="javascript:this.classList.add('error');this.src='/assets/placeholder/image.svg';"></div><a class="title" href="/wiki/calcite/background.html"><div class="main" ff="title">Calcite</div><div class="sub normal cap">最流行的 Java 优化器框架</div><div class="sub hover cap" style="opacity:0">学习数据库内核的绝佳案例</div></a></div></header><div class="nav-area"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/wiki/calcite/" placeholder="在 Calcite 中搜索..."></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><nav class="menu dis-select"><a class="nav-item" title="博客" href="/"><span>博客</span></a><a class="nav-item active" title="文档" href="/wiki/"><span>文档</span></a><a class="nav-item" title="便笺" href="/notes/"><span>便笺</span></a><a class="nav-item" title="更多" href="/more/"><span>更多</span></a></nav></div><div class="widgets"><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">概述</span></div><div class="widget-body fs14"><a class="link" href="/wiki/calcite/background.html#start"><span class="toc-text">背景</span></a><a class="link" href="/wiki/calcite/tutorial.html"><span class="toc-text">教程</span></a><a class="link" href="/wiki/calcite/algebra.html"><span class="toc-text">代数</span></a></div><div class="widget-header dis-select"><span class="name">高级主题</span></div><div class="widget-body fs14"><a class="link" href="/wiki/calcite/adapters.html"><span class="toc-text">适配器</span></a><a class="link" href="/wiki/calcite/spatial.html"><span class="toc-text">空间</span></a><a class="link" href="/wiki/calcite/stream.html"><span class="toc-text">流式查询</span></a><a class="link" href="/wiki/calcite/materialized-views.html"><span class="toc-text">物化视图</span></a><a class="link" href="/wiki/calcite/lattice.html"><span class="toc-text">Lattice 格</span></a></div><div class="widget-header dis-select"><span class="name">适配器</span></div><div class="widget-body fs14"><a class="link" href="/wiki/calcite/cassandra-adapter.html"><span class="toc-text">Cassandra 适配器</span></a><a class="link" href="/wiki/calcite/druid-adapter.html"><span class="toc-text">Druid 适配器</span></a><a class="link" href="/wiki/calcite/elasticsearch-adapter.html"><span class="toc-text">Elasticsearch 适配器</span></a><a class="link" href="/wiki/calcite/file-adapter.html"><span class="toc-text">文件适配器</span></a><a class="link" href="/wiki/calcite/geode-adapter.html"><span class="toc-text">Geode 适配器</span></a><a class="link" href="/wiki/calcite/innodb-adapter.html"><span class="toc-text">InnoDB 适配器</span></a><a class="link" href="/wiki/calcite/os-adapter.html"><span class="toc-text">操作系统适配器</span></a><a class="link" href="/wiki/calcite/pig-adapter.html"><span class="toc-text">Pig 适配器</span></a><a class="link" href="/wiki/calcite/redis-adapter.html"><span class="toc-text">Redis 适配器</span></a><a class="link" href="/wiki/calcite/kafka-adapter.html"><span class="toc-text">Kafka 适配器</span></a></div><div class="widget-header dis-select"><span class="name">参考指南</span></div><div class="widget-body fs14"><a class="link active" href="/wiki/calcite/reference.html"><span class="toc-text">参考指南</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="link" href="/wiki/calcite/model.html"><span class="toc-text">JSON/YAML 模型</span></a><a class="link" href="/wiki/calcite/howto.html"><span class="toc-text">如何参与</span></a><a class="link" href="/wiki/calcite/develop.html"><span class="toc-text">开发 Calcite</span></a></div></widget></div><footer class="footer dis-select"><div class="social-wrap"><a class="social" href="mailto:duanzhengqiang@apache.org" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/email.svg"></a><a class="social" href="https://github.com/strongduanmu" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/github.svg"></a><a class="social" href="/sitemap.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/sitemap.svg"></a><a class="social" href="/atom.xml" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/rss.svg"></a></div></footer></div></aside><div class="l_main" id="main"><div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/banner/banner_1.jpg"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki">文档</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/calcite/background.html">Calcite</a></div><div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2026-01-22T00:00:00.000Z">2026-01-22</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>参考指南</span></h1></div></div></div></div><article class="md-text content"><blockquote><p>原文链接：<a target="_blank" rel="noopener" href="https://calcite.apache.org/docs/reference.html">https://calcite.apache.org/docs/reference.html</a></p></blockquote><p>该页面描述了 Calcite 的默认 SQL 解析器识别的 SQL 方言。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><p>SQL 语法采用了 <a href="ttps://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> 风格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">statement:</span><br><span class="line">      setStatement</span><br><span class="line">  <span class="operator">|</span>   resetStatement</span><br><span class="line">  <span class="operator">|</span>   explain</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">describe</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">insert</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">update</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">merge</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">delete</span></span><br><span class="line">  <span class="operator">|</span>   query</span><br><span class="line"></span><br><span class="line">statementList:</span><br><span class="line">      statement [ <span class="string">&#x27;;&#x27;</span> statement ]<span class="operator">*</span> [ <span class="string">&#x27;;&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">setStatement:</span><br><span class="line">      [ <span class="keyword">ALTER</span> &#123; <span class="keyword">SYSTEM</span> <span class="operator">|</span> SESSION &#125; ] <span class="keyword">SET</span> identifier <span class="string">&#x27;=&#x27;</span> expression</span><br><span class="line"></span><br><span class="line">resetStatement:</span><br><span class="line">      [ <span class="keyword">ALTER</span> &#123; <span class="keyword">SYSTEM</span> <span class="operator">|</span> SESSION &#125; ] RESET identifier</span><br><span class="line">  <span class="operator">|</span>   [ <span class="keyword">ALTER</span> &#123; <span class="keyword">SYSTEM</span> <span class="operator">|</span> SESSION &#125; ] RESET <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">explain:</span><br><span class="line">      EXPLAIN PLAN</span><br><span class="line">      [ <span class="keyword">WITH</span> TYPE <span class="operator">|</span> <span class="keyword">WITH</span> IMPLEMENTATION <span class="operator">|</span> <span class="keyword">WITHOUT</span> IMPLEMENTATION ]</span><br><span class="line">      [ EXCLUDING ATTRIBUTES <span class="operator">|</span> INCLUDING [ <span class="keyword">ALL</span> ] ATTRIBUTES ]</span><br><span class="line">      [ <span class="keyword">AS</span> JSON <span class="operator">|</span> <span class="keyword">AS</span> XML <span class="operator">|</span> <span class="keyword">AS</span> DOT ]</span><br><span class="line">      <span class="keyword">FOR</span> &#123; query <span class="operator">|</span> <span class="keyword">insert</span> <span class="operator">|</span> <span class="keyword">update</span> <span class="operator">|</span> <span class="keyword">merge</span> <span class="operator">|</span> <span class="keyword">delete</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">describe</span>:</span><br><span class="line">      <span class="keyword">DESCRIBE</span> DATABASE databaseName</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">DESCRIBE</span> CATALOG [ databaseName . ] catalogName</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">DESCRIBE</span> SCHEMA [ [ databaseName . ] catalogName ] . schemaName</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">DESCRIBE</span> [ <span class="keyword">TABLE</span> ] [ [ [ databaseName . ] catalogName . ] schemaName . ] tableName [ columnName ]</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">DESCRIBE</span> [ STATEMENT ] &#123; query <span class="operator">|</span> <span class="keyword">insert</span> <span class="operator">|</span> <span class="keyword">update</span> <span class="operator">|</span> <span class="keyword">merge</span> <span class="operator">|</span> <span class="keyword">delete</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>:</span><br><span class="line">      &#123; <span class="keyword">INSERT</span> <span class="operator">|</span> UPSERT &#125; <span class="keyword">INTO</span> tablePrimary</span><br><span class="line">      [ <span class="string">&#x27;(&#x27;</span> <span class="keyword">column</span> [, <span class="keyword">column</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      query</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span>:</span><br><span class="line">      <span class="keyword">UPDATE</span> tablePrimary</span><br><span class="line">      <span class="keyword">SET</span> assign [, assign ]<span class="operator">*</span></span><br><span class="line">      [ <span class="keyword">WHERE</span> booleanExpression ]</span><br><span class="line"></span><br><span class="line">assign:</span><br><span class="line">      identifier <span class="string">&#x27;=&#x27;</span> expression</span><br><span class="line"></span><br><span class="line"><span class="keyword">merge</span>:</span><br><span class="line">      <span class="keyword">MERGE</span> <span class="keyword">INTO</span> tablePrimary [ [ <span class="keyword">AS</span> ] alias ]</span><br><span class="line">      <span class="keyword">USING</span> tablePrimary</span><br><span class="line">      <span class="keyword">ON</span> booleanExpression</span><br><span class="line">      [ <span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> assign [, assign ]<span class="operator">*</span> ]</span><br><span class="line">      [ <span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> <span class="keyword">INSERT</span> <span class="keyword">VALUES</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">value</span> [ , <span class="keyword">value</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>:</span><br><span class="line">      <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablePrimary [ [ <span class="keyword">AS</span> ] alias ]</span><br><span class="line">      [ <span class="keyword">WHERE</span> booleanExpression ]</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">      <span class="keyword">values</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">WITH</span> [ <span class="keyword">RECURSIVE</span> ] withItem [ , withItem ]<span class="operator">*</span> query</span><br><span class="line">  <span class="operator">|</span>   &#123;</span><br><span class="line">          <span class="keyword">select</span></span><br><span class="line">      <span class="operator">|</span>   selectWithoutFrom</span><br><span class="line">      <span class="operator">|</span>   query <span class="keyword">UNION</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] query</span><br><span class="line">      <span class="operator">|</span>   query <span class="keyword">EXCEPT</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] query</span><br><span class="line">      <span class="operator">|</span>   query MINUS [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] query</span><br><span class="line">      <span class="operator">|</span>   query <span class="keyword">INTERSECT</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] query</span><br><span class="line">      &#125;</span><br><span class="line">      [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderItem [, orderItem ]<span class="operator">*</span> ]</span><br><span class="line">      [ LIMIT [ <span class="keyword">start</span>, ] &#123; count <span class="operator">|</span> <span class="keyword">ALL</span> &#125; ]</span><br><span class="line">      [ <span class="keyword">OFFSET</span> <span class="keyword">start</span> &#123; <span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">ROWS</span> &#125; ]</span><br><span class="line">      [ <span class="keyword">FETCH</span> &#123; <span class="keyword">FIRST</span> <span class="operator">|</span> NEXT &#125; [ count ] &#123; <span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">ROWS</span> &#125; <span class="keyword">ONLY</span> ]</span><br><span class="line"></span><br><span class="line">withItem:</span><br><span class="line">      name</span><br><span class="line">      [ <span class="string">&#x27;(&#x27;</span> <span class="keyword">column</span> [, <span class="keyword">column</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      <span class="keyword">AS</span> <span class="string">&#x27;(&#x27;</span> query <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">orderItem:</span><br><span class="line">      expression [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span> ] [ <span class="keyword">NULLS FIRST</span> <span class="operator">|</span> <span class="keyword">NULLS LAST</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>:</span><br><span class="line">      <span class="keyword">SELECT</span> [ hintComment ] [ STREAM ] [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ]</span><br><span class="line">          &#123; <span class="operator">*</span> <span class="operator">|</span> projectItem [, projectItem ]<span class="operator">*</span> &#125;</span><br><span class="line">      <span class="keyword">FROM</span> tableExpression</span><br><span class="line">      [ <span class="keyword">WHERE</span> booleanExpression ]</span><br><span class="line">      [ <span class="keyword">GROUP</span> <span class="keyword">BY</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] &#123; groupItem [, groupItem ]<span class="operator">*</span> &#125; ]</span><br><span class="line">      [ <span class="keyword">HAVING</span> booleanExpression ]</span><br><span class="line">      [ <span class="keyword">WINDOW</span> windowName <span class="keyword">AS</span> windowSpec [, windowName <span class="keyword">AS</span> windowSpec ]<span class="operator">*</span> ]</span><br><span class="line">      [ QUALIFY booleanExpression ]</span><br><span class="line"></span><br><span class="line">selectWithoutFrom:</span><br><span class="line">      <span class="keyword">SELECT</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ]</span><br><span class="line">          &#123; <span class="operator">*</span> <span class="operator">|</span> projectItem [, projectItem ]<span class="operator">*</span> &#125;</span><br><span class="line"></span><br><span class="line">projectItem:</span><br><span class="line">      expression [ [ <span class="keyword">AS</span> ] columnAlias ]</span><br><span class="line">  <span class="operator">|</span>   tableAlias . <span class="operator">*</span></span><br><span class="line"></span><br><span class="line">tableExpression:</span><br><span class="line">      tableReference [, tableReference ]<span class="operator">*</span></span><br><span class="line">  <span class="operator">|</span>   tableExpression [ <span class="keyword">NATURAL</span> ] [ &#123; <span class="keyword">LEFT</span> <span class="operator">|</span> <span class="keyword">RIGHT</span> <span class="operator">|</span> <span class="keyword">FULL</span> &#125; [ <span class="keyword">OUTER</span> ] ] <span class="keyword">JOIN</span> tableExpression [ joinCondition ]</span><br><span class="line">  <span class="operator">|</span>   tableExpression <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> tableExpression</span><br><span class="line">  <span class="operator">|</span>   tableExpression [ <span class="keyword">CROSS</span> <span class="operator">|</span> <span class="keyword">OUTER</span> ] APPLY tableExpression</span><br><span class="line"></span><br><span class="line">joinCondition:</span><br><span class="line">      <span class="keyword">ON</span> booleanExpression</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">USING</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">column</span> [, <span class="keyword">column</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">tableReference:</span><br><span class="line">      tablePrimary</span><br><span class="line">      [ <span class="keyword">FOR</span> <span class="built_in">SYSTEM_TIME</span> <span class="keyword">AS</span> <span class="keyword">OF</span> expression ]</span><br><span class="line">      [ pivot ]</span><br><span class="line">      [ unpivot ]</span><br><span class="line">      [ matchRecognize ]</span><br><span class="line">      [ [ <span class="keyword">AS</span> ] alias [ <span class="string">&#x27;(&#x27;</span> columnAlias [, columnAlias ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ] ]</span><br><span class="line"></span><br><span class="line">tablePrimary:</span><br><span class="line">      [ [ catalogName . ] schemaName . ] tableName</span><br><span class="line">      <span class="string">&#x27;(&#x27;</span> <span class="keyword">TABLE</span> [ [ catalogName . ] schemaName . ] tableName <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   tablePrimary [ hintComment ] [ EXTEND ] <span class="string">&#x27;(&#x27;</span> columnDecl [, columnDecl ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   [ <span class="keyword">LATERAL</span> ] <span class="string">&#x27;(&#x27;</span> query <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   UNNEST <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> [ <span class="keyword">WITH</span> ORDINALITY ]</span><br><span class="line">  <span class="operator">|</span>   [ <span class="keyword">LATERAL</span> ] <span class="keyword">TABLE</span> <span class="string">&#x27;(&#x27;</span> [ <span class="keyword">SPECIFIC</span> ] functionName <span class="string">&#x27;(&#x27;</span> expression [, expression ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">columnDecl:</span><br><span class="line">      <span class="keyword">column</span> type [ <span class="keyword">NOT NULL</span> ]</span><br><span class="line"></span><br><span class="line">hint:</span><br><span class="line">      hintName</span><br><span class="line">  <span class="operator">|</span>   hintName <span class="string">&#x27;(&#x27;</span> hintOptions <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">hintOptions:</span><br><span class="line">      hintKVOption [, hintKVOption ]<span class="operator">*</span></span><br><span class="line">  <span class="operator">|</span>   optionName [, optionName ]<span class="operator">*</span></span><br><span class="line">  <span class="operator">|</span>   optionValue [, optionValue ]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line">hintKVOption:</span><br><span class="line">      optionName <span class="string">&#x27;=&#x27;</span> stringLiteral</span><br><span class="line">  <span class="operator">|</span>   stringLiteral <span class="string">&#x27;=&#x27;</span> stringLiteral</span><br><span class="line"></span><br><span class="line">optionValue:</span><br><span class="line">      stringLiteral</span><br><span class="line">  <span class="operator">|</span>   numericLiteral</span><br><span class="line"></span><br><span class="line">columnOrList:</span><br><span class="line">      <span class="keyword">column</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> <span class="keyword">column</span> [, <span class="keyword">column</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">exprOrList:</span><br><span class="line">      expr</span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> expr [, expr ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">pivot:</span><br><span class="line">      PIVOT <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      pivotAgg [, pivotAgg ]<span class="operator">*</span></span><br><span class="line">      <span class="keyword">FOR</span> pivotList</span><br><span class="line">      <span class="keyword">IN</span> <span class="string">&#x27;(&#x27;</span> pivotExpr [, pivotExpr ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">pivotAgg:</span><br><span class="line">      agg <span class="string">&#x27;(&#x27;</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] <span class="keyword">value</span> [, <span class="keyword">value</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      [ [ <span class="keyword">AS</span> ] alias ]</span><br><span class="line"></span><br><span class="line">pivotList:</span><br><span class="line">      columnOrList</span><br><span class="line"></span><br><span class="line">pivotExpr:</span><br><span class="line">      exprOrList [ [ <span class="keyword">AS</span> ] alias ]</span><br><span class="line"></span><br><span class="line">unpivot:</span><br><span class="line">      UNPIVOT [ INCLUDING NULLS <span class="operator">|</span> EXCLUDING NULLS ] <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      unpivotMeasureList</span><br><span class="line">      <span class="keyword">FOR</span> unpivotAxisList</span><br><span class="line">      <span class="keyword">IN</span> <span class="string">&#x27;(&#x27;</span> unpivotValue [, unpivotValue ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">unpivotMeasureList:</span><br><span class="line">      columnOrList</span><br><span class="line"></span><br><span class="line">unpivotAxisList:</span><br><span class="line">      columnOrList</span><br><span class="line"></span><br><span class="line">unpivotValue:</span><br><span class="line">      <span class="keyword">column</span> [ <span class="keyword">AS</span> literal ]</span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> <span class="keyword">column</span> [, <span class="keyword">column</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> [ <span class="keyword">AS</span> <span class="string">&#x27;(&#x27;</span> literal [, literal ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">values</span>:</span><br><span class="line">      &#123; <span class="keyword">VALUES</span> <span class="operator">|</span> <span class="keyword">VALUE</span> &#125; expression [, expression ]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line">groupItem:</span><br><span class="line">      expression</span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> expression [, expression ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">CUBE</span> <span class="string">&#x27;(&#x27;</span> expression [, expression ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">ROLLUP</span> <span class="string">&#x27;(&#x27;</span> expression [, expression ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">GROUPING SETS</span> <span class="string">&#x27;(&#x27;</span> groupItem [, groupItem ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">window</span>:</span><br><span class="line">      windowName</span><br><span class="line">  <span class="operator">|</span>   windowSpec</span><br><span class="line"></span><br><span class="line">windowSpec:</span><br><span class="line">      <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      [ windowName ]</span><br><span class="line">      [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderItem [, orderItem ]<span class="operator">*</span> ]</span><br><span class="line">      [ <span class="keyword">PARTITION</span> <span class="keyword">BY</span> expression [, expression ]<span class="operator">*</span> ]</span><br><span class="line">      [</span><br><span class="line">          <span class="keyword">RANGE</span> numericOrIntervalExpression &#123; PRECEDING <span class="operator">|</span> FOLLOWING &#125;</span><br><span class="line">      <span class="operator">|</span>   <span class="keyword">ROWS</span> numericExpression &#123; PRECEDING <span class="operator">|</span> FOLLOWING &#125;</span><br><span class="line">      ]</span><br><span class="line">      <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <code>insert</code> 中，如果 <code>INSERT</code> 或 <code>UPSERT</code> 语句未指定目标列列表，则查询必须具有与目标表相同的列数，某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isInsertSubsetColumnsAllowed--">一致性级别</a>除外。</p><p>在 <code>merge</code> 中，至少必须存在 <code>WHEN MATCHED</code> 和 <code>WHEN NOT MATCHED</code> 子句之一。</p><p><code>tablePrimary</code> 只能在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#allowExtend--">一致性级别</a>中包含 <code>EXTEND</code> 子句；在这些相同的一致性级别中，insert 中的任何列都可以由 <code>columnDecl</code> 替换，这与将其包含在 EXTEND 子句中具有类似的效果。</p><p>在 <code>orderItem</code> 中，如果 <code>expression</code> 是正整数 n，则表示 SELECT 子句中的第 n 项。</p><p>在查询中，<code>count</code> 和 <code>start</code> 可以分别是无符号整数字面量或值为整数的动态参数。</p><p>聚合查询是在 SELECT 子句中包含 GROUP BY 或 HAVING 子句，或包含聚合函数的查询。在聚合查询的 SELECT、HAVING 和 ORDER BY 子句中，所有表达式必须是当前组内的常量（即：由 GROUP BY 子句定义的分组常量或常量）、或者是聚合函数，或者是常量和聚合函数的组合。聚合和分组函数只能出现在聚合查询中，并且只能出现在 SELECT、HAVING 或 ORDER BY 子句中。</p><p>标量子查询是指用作表达式的子查询。如果子查询没有返回行，则值为 NULL，如果它返回多于一行，则会报错。</p><p><code>IN</code>、<code>EXISTS</code>、<code>UNIQUE</code> 和标量子查询，可以出现在任何可以出现表达式的位置（例如 JOIN 的 SELECT 子句、WHERE 子句、ON 子句，或作为聚合函数的参数）。</p><p><code>IN</code>、<code>EXISTS</code>、<code>UNIQUE</code> 或标量子查询可以是相关的，即：它可以引用一个封闭查询中 FROM 子句的表。</p><p><code>GROUP BY DISTINCT</code> 删除重复的分组集（例如：<code>GROUP BY DISTINCT GROUPING SETS ((a), (a, b), (a))</code> 等价于 <code>GROUP BY GROUPING SETS ((a), (a, b))</code>），<code>GROUP BY ALL</code> 和 <code>GROUP BY</code> 是等价的。</p><p><code>selectWithoutFrom</code> 等价于 <code>VALUES</code>，但它不是标准 SQL，并且仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isMinusAllowed--">一致性级别</a>中允许使用。</p><p><code>MINUS</code> 等价于 <code>EXCEPT</code>，但不是标准 SQL，仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isMinusAllowed--">一致性级别</a>中允许使用。</p><p><code>CROSS APPLY</code> 和 <code>OUTER APPLY</code> 仅允许在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isApplyAllowed--">一致性级别</a>中使用。</p><p><code>LIMIT start, count</code> 等价于 <code>LIMIT count OFFSET start</code>，但仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isLimitStartCountAllowed--">一致性级别</a>中允许使用。</p><p>在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isOffsetLimitAllowed--">一致性级别</a>中，<code>OFFSET start</code> 可能发生在 <code>LIMIT count</code> 之前。</p><p><code>VALUE</code> 与 <code>VALUES</code> 等效，但不是标准 SQL，并且仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isValueAllowed--">一致性级别</a>中允许使用。</p><h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2><p>以下是 SQL 关键字的列表。保留的关键字使用粗体展示。</p><p>A, <strong>ABS</strong>, ABSENT, ABSOLUTE, ACTION, ADA, ADD, ADMIN, AFTER, <strong>ALL</strong>, <strong>ALLOCATE</strong>, <strong>ALLOW</strong>, <strong>ALTER</strong>, ALWAYS, <strong>AND</strong>, <strong>ANY</strong>, APPLY, <strong>ARE</strong>, <strong>ARRAY</strong>, ARRAY_AGG, ARRAY_CONCAT_AGG, <strong>ARRAY_MAX_CARDINALITY</strong>, <strong>AS</strong>, ASC, <strong>ASENSITIVE</strong>, ASSERTION, ASSIGNMENT, <strong>ASYMMETRIC</strong>, <strong>AT</strong>, <strong>ATOMIC</strong>, ATTRIBUTE, ATTRIBUTES, <strong>AUTHORIZATION</strong>, <strong>AVG</strong>, BEFORE, <strong>BEGIN</strong>, <strong>BEGIN_FRAME</strong>, <strong>BEGIN_PARTITION</strong>, BERNOULLI, <strong>BETWEEN</strong>, <strong>BIGINT</strong>, <strong>BINARY</strong>, <strong>BIT</strong>, <strong>BLOB</strong>, <strong>BOOLEAN</strong>, <strong>BOTH</strong>, BREADTH, <strong>BY</strong>, C, <strong>CALL</strong>, <strong>CALLED</strong>, <strong>CARDINALITY</strong>, CASCADE, <strong>CASCADED</strong>, <strong>CASE</strong>, <strong>CAST</strong>, CATALOG, CATALOG_NAME, <strong>CEIL</strong>, <strong>CEILING</strong>, CENTURY, CHAIN, <strong>CHAR</strong>, <strong>CHARACTER</strong>, CHARACTERISTICS, CHARACTERS, <strong>CHARACTER_LENGTH</strong>, CHARACTER_SET_CATALOG, CHARACTER_SET_NAME, CHARACTER_SET_SCHEMA, <strong>CHAR_LENGTH</strong>, <strong>CHECK</strong>, <strong>CLASSIFIER</strong>, CLASS_ORIGIN, <strong>CLOB</strong>, <strong>CLOSE</strong>, <strong>COALESCE</strong>, COBOL, <strong>COLLATE</strong>, COLLATION, COLLATION_CATALOG, COLLATION_NAME, COLLATION_SCHEMA, <strong>COLLECT</strong>, <strong>COLUMN</strong>, COLUMN_NAME, COMMAND_FUNCTION, COMMAND_FUNCTION_CODE, <strong>COMMIT</strong>, COMMITTED, <strong>CONDITION</strong>, CONDITIONAL, CONDITION_NUMBER, <strong>CONNECT</strong>, CONNECTION, CONNECTION_NAME, <strong>CONSTRAINT</strong>, CONSTRAINTS, CONSTRAINT_CATALOG, CONSTRAINT_NAME, CONSTRAINT_SCHEMA, CONSTRUCTOR, <strong>CONTAINS</strong>, CONTAINS_SUBSTR, CONTINUE, <strong>CONVERT</strong>, <strong>CORR</strong>, <strong>CORRESPONDING</strong>, <strong>COUNT</strong>, <strong>COVAR_POP</strong>, <strong>COVAR_SAMP</strong>, <strong>CREATE</strong>, <strong>CROSS</strong>, <strong>CUBE</strong>, <strong>CUME_DIST</strong>, <strong>CURRENT</strong>, <strong>CURRENT_CATALOG</strong>, <strong>CURRENT_DATE</strong>, <strong>CURRENT_DEFAULT_TRANSFORM_GROUP</strong>, <strong>CURRENT_PATH</strong>, <strong>CURRENT_ROLE</strong>, <strong>CURRENT_ROW</strong>, <strong>CURRENT_SCHEMA</strong>, <strong>CURRENT_TIME</strong>, <strong>CURRENT_TIMESTAMP</strong>, <strong>CURRENT_TRANSFORM_GROUP_FOR_TYPE</strong>, <strong>CURRENT_USER</strong>, <strong>CURSOR</strong>, CURSOR_NAME, <strong>CYCLE</strong>, DATA, DATABASE, <strong>DATE</strong>, <strong>DATETIME</strong>, DATETIME_DIFF, DATETIME_INTERVAL_CODE, DATETIME_INTERVAL_PRECISION, DATETIME_TRUNC, DATE_DIFF, DATE_TRUNC, <strong>DAY</strong>, DAYOFWEEK, DAYOFYEAR, DAYS, <strong>DEALLOCATE</strong>, <strong>DEC</strong>, DECADE, <strong>DECIMAL</strong>, <strong>DECLARE</strong>, <strong>DEFAULT</strong>, DEFAULTS, DEFERRABLE, DEFERRED, <strong>DEFINE</strong>, DEFINED, DEFINER, DEGREE, <strong>DELETE</strong>, <strong>DENSE_RANK</strong>, DEPTH, <strong>DEREF</strong>, DERIVED, DESC, <strong>DESCRIBE</strong>, DESCRIPTION, DESCRIPTOR, <strong>DETERMINISTIC</strong>, DIAGNOSTICS, <strong>DISALLOW</strong>, <strong>DISCONNECT</strong>, DISPATCH, <strong>DISTINCT</strong>, DOMAIN, DOT, <strong>DOUBLE</strong>, DOW, DOY, <strong>DROP</strong>, <strong>DYNAMIC</strong>, DYNAMIC_FUNCTION, DYNAMIC_FUNCTION_CODE, <strong>EACH</strong>, <strong>ELEMENT</strong>, <strong>ELSE</strong>, <strong>EMPTY</strong>, ENCODING, <strong>END</strong>, <strong>END-EXEC</strong>, <strong>END_FRAME</strong>, <strong>END_PARTITION</strong>, EPOCH, <strong>EQUALS</strong>, ERROR, <strong>ESCAPE</strong>, <strong>EVERY</strong>, <strong>EXCEPT</strong>, EXCEPTION, EXCLUDE, EXCLUDING, <strong>EXEC</strong>, <strong>EXECUTE</strong>, <strong>EXISTS</strong>, <strong>EXP</strong>, <strong>EXPLAIN</strong>, <strong>EXTEND</strong>, <strong>EXTERNAL</strong>, <strong>EXTRACT</strong>, <strong>FALSE</strong>, <strong>FETCH</strong>, <strong>FILTER</strong>, FINAL, FIRST, <strong>FIRST_VALUE</strong>, <strong>FLOAT</strong>, <strong>FLOOR</strong>, FOLLOWING, <strong>FOR</strong>, <strong>FOREIGN</strong>, FORMAT, FORTRAN, FOUND, FRAC_SECOND, <strong>FRAME_ROW</strong>, <strong>FREE</strong>, <strong>FRIDAY</strong>, <strong>FROM</strong>, <strong>FULL</strong>, <strong>FUNCTION</strong>, <strong>FUSION</strong>, G, GENERAL, GENERATED, GEOMETRY, <strong>GET</strong>, <strong>GLOBAL</strong>, GO, GOTO, <strong>GRANT</strong>, GRANTED, <strong>GROUP</strong>, <strong>GROUPING</strong>, <strong>GROUPS</strong>, GROUP_CONCAT, <strong>HAVING</strong>, HIERARCHY, <strong>HOLD</strong>, HOP, <strong>HOUR</strong>, HOURS, <strong>IDENTITY</strong>, IGNORE, ILIKE, IMMEDIATE, IMMEDIATELY, IMPLEMENTATION, <strong>IMPORT</strong>, <strong>IN</strong>, INCLUDE, INCLUDING, INCREMENT, <strong>INDICATOR</strong>, <strong>INITIAL</strong>, INITIALLY, <strong>INNER</strong>, <strong>INOUT</strong>, INPUT, <strong>INSENSITIVE</strong>, <strong>INSERT</strong>, INSTANCE, INSTANTIABLE, <strong>INT</strong>, <strong>INTEGER</strong>, <strong>INTERSECT</strong>, <strong>INTERSECTION</strong>, <strong>INTERVAL</strong>, <strong>INTO</strong>, INVOKER, <strong>IS</strong>, ISODOW, ISOLATION, ISOYEAR, JAVA, <strong>JOIN</strong>, JSON, <strong>JSON_ARRAY</strong>, <strong>JSON_ARRAYAGG</strong>, <strong>JSON_EXISTS</strong>, <strong>JSON_OBJECT</strong>, <strong>JSON_OBJECTAGG</strong>, <strong>JSON_QUERY</strong>, <strong>JSON_SCOPE</strong>, <strong>JSON_VALUE</strong>, K, KEY, KEY_MEMBER, KEY_TYPE, LABEL, <strong>LAG</strong>, <strong>LANGUAGE</strong>, <strong>LARGE</strong>, LAST, <strong>LAST_VALUE</strong>, <strong>LATERAL</strong>, <strong>LEAD</strong>, <strong>LEADING</strong>, <strong>LEFT</strong>, LENGTH, LEVEL, LIBRARY, <strong>LIKE</strong>, <strong>LIKE_REGEX</strong>, <strong>LIMIT</strong>, <strong>LN</strong>, <strong>LOCAL</strong>, <strong>LOCALTIME</strong>, <strong>LOCALTIMESTAMP</strong>, LOCATOR, <strong>LOWER</strong>, M, MAP, <strong>MATCH</strong>, MATCHED, <strong>MATCHES</strong>, <strong>MATCH_NUMBER</strong>, <strong>MATCH_RECOGNIZE</strong>, <strong>MAX</strong>, MAXVALUE, <strong>MEASURES</strong>, <strong>MEMBER</strong>, <strong>MERGE</strong>, MESSAGE_LENGTH, MESSAGE_OCTET_LENGTH, MESSAGE_TEXT, <strong>METHOD</strong>, MICROSECOND, MILLENNIUM, MILLISECOND, <strong>MIN</strong>, <strong>MINUS</strong>, <strong>MINUTE</strong>, MINUTES, MINVALUE, <strong>MOD</strong>, <strong>MODIFIES</strong>, <strong>MODULE</strong>, <strong>MONDAY</strong>, <strong>MONTH</strong>, MONTHS, MORE, <strong>MULTISET</strong>, MUMPS, NAME, NAMES, NANOSECOND, <strong>NATIONAL</strong>, <strong>NATURAL</strong>, <strong>NCHAR</strong>, <strong>NCLOB</strong>, NESTING, <strong>NEW</strong>, <strong>NEXT</strong>, <strong>NO</strong>, <strong>NONE</strong>, <strong>NORMALIZE</strong>, NORMALIZED, <strong>NOT</strong>, <strong>NTH_VALUE</strong>, <strong>NTILE</strong>, <strong>NULL</strong>, NULLABLE, <strong>NULLIF</strong>, NULLS, NUMBER, <strong>NUMERIC</strong>, OBJECT, <strong>OCCURRENCES_REGEX</strong>, OCTETS, <strong>OCTET_LENGTH</strong>, <strong>OF</strong>, <strong>OFFSET</strong>, <strong>OLD</strong>, <strong>OMIT</strong>, <strong>ON</strong>, <strong>ONE</strong>, <strong>ONLY</strong>, <strong>OPEN</strong>, OPTION, OPTIONS, <strong>OR</strong>, <strong>ORDER</strong>, ORDERING, <strong>ORDINAL</strong>, ORDINALITY, OTHERS, <strong>OUT</strong>, <strong>OUTER</strong>, OUTPUT, <strong>OVER</strong>, <strong>OVERLAPS</strong>, <strong>OVERLAY</strong>, OVERRIDING, PAD, <strong>PARAMETER</strong>, PARAMETER_MODE, PARAMETER_NAME, PARAMETER_ORDINAL_POSITION, PARAMETER_SPECIFIC_CATALOG, PARAMETER_SPECIFIC_NAME, PARAMETER_SPECIFIC_SCHEMA, PARTIAL, <strong>PARTITION</strong>, PASCAL, PASSING, PASSTHROUGH, PAST, PATH, <strong>PATTERN</strong>, <strong>PER</strong>, <strong>PERCENT</strong>, <strong>PERCENTILE_CONT</strong>, <strong>PERCENTILE_DISC</strong>, <strong>PERCENT_RANK</strong>, <strong>PERIOD</strong>, <strong>PERMUTE</strong>, PIVOT, PLACING, PLAN, PLI, <strong>PORTION</strong>, <strong>POSITION</strong>, <strong>POSITION_REGEX</strong>, <strong>POWER</strong>, <strong>PRECEDES</strong>, PRECEDING, <strong>PRECISION</strong>, <strong>PREPARE</strong>, PRESERVE, <strong>PREV</strong>, <strong>PRIMARY</strong>, PRIOR, PRIVILEGES, <strong>PROCEDURE</strong>, PUBLIC, <strong>QUALIFY</strong>, QUARTER, QUARTERS, <strong>RANGE</strong>, <strong>RANK</strong>, READ, <strong>READS</strong>, <strong>REAL</strong>, <strong>RECURSIVE</strong>, <strong>REF</strong>, <strong>REFERENCES</strong>, <strong>REFERENCING</strong>, <strong>REGR_AVGX</strong>, <strong>REGR_AVGY</strong>, <strong>REGR_COUNT</strong>, <strong>REGR_INTERCEPT</strong>, <strong>REGR_R2</strong>, <strong>REGR_SLOPE</strong>, <strong>REGR_SXX</strong>, <strong>REGR_SXY</strong>, <strong>REGR_SYY</strong>, RELATIVE, <strong>RELEASE</strong>, REPEATABLE, REPLACE, <strong>RESET</strong>, RESPECT, RESTART, RESTRICT, <strong>RESULT</strong>, <strong>RETURN</strong>, RETURNED_CARDINALITY, RETURNED_LENGTH, RETURNED_OCTET_LENGTH, RETURNED_SQLSTATE, RETURNING, <strong>RETURNS</strong>, <strong>REVOKE</strong>, <strong>RIGHT</strong>, RLIKE, ROLE, <strong>ROLLBACK</strong>, <strong>ROLLUP</strong>, ROUTINE, ROUTINE_CATALOG, ROUTINE_NAME, ROUTINE_SCHEMA, <strong>ROW</strong>, <strong>ROWS</strong>, ROW_COUNT, <strong>ROW_NUMBER</strong>, <strong>RUNNING</strong>, <strong>SAFE_CAST</strong>, <strong>SAFE_OFFSET</strong>, <strong>SAFE_ORDINAL</strong>, <strong>SATURDAY</strong>, <strong>SAVEPOINT</strong>, SCALAR, SCALE, SCHEMA, SCHEMA_NAME, <strong>SCOPE</strong>, SCOPE_CATALOGS, SCOPE_NAME, SCOPE_SCHEMA, <strong>SCROLL</strong>, <strong>SEARCH</strong>, <strong>SECOND</strong>, SECONDS, SECTION, SECURITY, <strong>SEEK</strong>, <strong>SELECT</strong>, SELF, <strong>SENSITIVE</strong>, SEPARATOR, SEQUENCE, SERIALIZABLE, SERVER, SERVER_NAME, SESSION, <strong>SESSION_USER</strong>, <strong>SET</strong>, SETS, <strong>SHOW</strong>, <strong>SIMILAR</strong>, SIMPLE, SIZE, <strong>SKIP</strong>, <strong>SMALLINT</strong>, <strong>SOME</strong>, SOURCE, SPACE, <strong>SPECIFIC</strong>, <strong>SPECIFICTYPE</strong>, SPECIFIC_NAME, <strong>SQL</strong>, <strong>SQLEXCEPTION</strong>, <strong>SQLSTATE</strong>, <strong>SQLWARNING</strong>, SQL_BIGINT, SQL_BINARY, SQL_BIT, SQL_BLOB, SQL_BOOLEAN, SQL_CHAR, SQL_CLOB, SQL_DATE, SQL_DECIMAL, SQL_DOUBLE, SQL_FLOAT, SQL_INTEGER, SQL_INTERVAL_DAY, SQL_INTERVAL_DAY_TO_HOUR, SQL_INTERVAL_DAY_TO_MINUTE, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR, SQL_INTERVAL_HOUR_TO_MINUTE, SQL_INTERVAL_HOUR_TO_SECOND, SQL_INTERVAL_MINUTE, SQL_INTERVAL_MINUTE_TO_SECOND, SQL_INTERVAL_MONTH, SQL_INTERVAL_SECOND, SQL_INTERVAL_YEAR, SQL_INTERVAL_YEAR_TO_MONTH, SQL_LONGVARBINARY, SQL_LONGVARCHAR, SQL_LONGVARNCHAR, SQL_NCHAR, SQL_NCLOB, SQL_NUMERIC, SQL_NVARCHAR, SQL_REAL, SQL_SMALLINT, SQL_TIME, SQL_TIMESTAMP, SQL_TINYINT, SQL_TSI_DAY, SQL_TSI_FRAC_SECOND, SQL_TSI_HOUR, SQL_TSI_MICROSECOND, SQL_TSI_MINUTE, SQL_TSI_MONTH, SQL_TSI_QUARTER, SQL_TSI_SECOND, SQL_TSI_WEEK, SQL_TSI_YEAR, SQL_VARBINARY, SQL_VARCHAR, <strong>SQRT</strong>, <strong>START</strong>, STATE, STATEMENT, <strong>STATIC</strong>, <strong>STDDEV_POP</strong>, <strong>STDDEV_SAMP</strong>, <strong>STREAM</strong>, STRING_AGG, STRUCTURE, STYLE, SUBCLASS_ORIGIN, <strong>SUBMULTISET</strong>, <strong>SUBSET</strong>, SUBSTITUTE, <strong>SUBSTRING</strong>, <strong>SUBSTRING_REGEX</strong>, <strong>SUCCEEDS</strong>, <strong>SUM</strong>, <strong>SUNDAY</strong>, <strong>SYMMETRIC</strong>, <strong>SYSTEM</strong>, <strong>SYSTEM_TIME</strong>, <strong>SYSTEM_USER</strong>, <strong>TABLE</strong>, <strong>TABLESAMPLE</strong>, TABLE_NAME, TEMPORARY, <strong>THEN</strong>, <strong>THURSDAY</strong>, TIES, <strong>TIME</strong>, <strong>TIMESTAMP</strong>, TIMESTAMPADD, TIMESTAMPDIFF, TIMESTAMP_DIFF, TIMESTAMP_TRUNC, <strong>TIMEZONE_HOUR</strong>, <strong>TIMEZONE_MINUTE</strong>, TIME_DIFF, TIME_TRUNC, <strong>TINYINT</strong>, <strong>TO</strong>, TOP_LEVEL_COUNT, <strong>TRAILING</strong>, TRANSACTION, TRANSACTIONS_ACTIVE, TRANSACTIONS_COMMITTED, TRANSACTIONS_ROLLED_BACK, TRANSFORM, TRANSFORMS, <strong>TRANSLATE</strong>, <strong>TRANSLATE_REGEX</strong>, <strong>TRANSLATION</strong>, <strong>TREAT</strong>, <strong>TRIGGER</strong>, TRIGGER_CATALOG, TRIGGER_NAME, TRIGGER_SCHEMA, <strong>TRIM</strong>, <strong>TRIM_ARRAY</strong>, <strong>TRUE</strong>, <strong>TRUNCATE</strong>, <strong>TRY_CAST</strong>, <strong>TUESDAY</strong>, TUMBLE, TYPE, <strong>UESCAPE</strong>, UNBOUNDED, UNCOMMITTED, UNCONDITIONAL, UNDER, <strong>UNION</strong>, <strong>UNIQUE</strong>, <strong>UNKNOWN</strong>, UNNAMED, <strong>UNNEST</strong>, UNPIVOT, <strong>UPDATE</strong>, <strong>UPPER</strong>, <strong>UPSERT</strong>, USAGE, <strong>USER</strong>, USER_DEFINED_TYPE_CATALOG, USER_DEFINED_TYPE_CODE, USER_DEFINED_TYPE_NAME, USER_DEFINED_TYPE_SCHEMA, <strong>USING</strong>, UTF16, UTF32, UTF8, <strong>VALUE</strong>, <strong>VALUES</strong>, <strong>VALUE_OF</strong>, <strong>VARBINARY</strong>, <strong>VARCHAR</strong>, <strong>VARYING</strong>, <strong>VAR_POP</strong>, <strong>VAR_SAMP</strong>, VERSION, <strong>VERSIONING</strong>, VIEW, <strong>WEDNESDAY</strong>, WEEK, WEEKS, <strong>WHEN</strong>, <strong>WHENEVER</strong>, <strong>WHERE</strong>, <strong>WIDTH_BUCKET</strong>, <strong>WINDOW</strong>, <strong>WITH</strong>, <strong>WITHIN</strong>, <strong>WITHOUT</strong>, WORK, WRAPPER, WRITE, XML, <strong>YEAR</strong>, YEARS, ZONE.</p><div class="article-inline-ad-wrapper"><div class="article-inline-ad-container"><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9880881761323734" data-ad-slot="7617691942"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="article-inline-ad-label">赞助商</div></div><h2 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h2><p>标识符是 SQL 查询中使用的表、列和其他元数据元素的名称。</p><p>不带引号的标识符（例如 emp）必须以字母开头，并且只能包含字母、数字和下划线。它们被隐式转换为大写。</p><p>带引号的标识符，例如 <code>&quot;Employee Name&quot;</code> ，以双引号开头和结尾。它们几乎可以包含任何字符，包括空格和其他标点符号。如果你希望在标识符中包含双引号，请使用另一个双引号对其进行转义，例如：<code>&quot;An employee called &quot;&quot;Fred&quot;&quot;.&quot;</code>。</p><p>在 Calcite 中，将标识符与引用对象的名称匹配是区分大小写的。但请记住，未加引号的标识符在匹配之前会隐式转换为大写，并且如果它引用的对象是使用未加引号的标识符作为其名称创建的，则其名称也将转换为大写。</p><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><h3 id="标量类型"><a class="markdownIt-Anchor" href="#标量类型"></a> 标量类型</h3><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">描述</th><th style="text-align:left">范围和示例字面量</th></tr></thead><tbody><tr><td style="text-align:left">BOOLEAN</td><td style="text-align:left">逻辑值</td><td style="text-align:left">值：TRUE, FALSE, UNKNOWN</td></tr><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1 字节有符号整数</td><td style="text-align:left">范围是 -128 到 127</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2 字节有符号整数</td><td style="text-align:left">范围为 -32768 至 32767</td></tr><tr><td style="text-align:left">INTEGER, INT</td><td style="text-align:left">4 字节有符号整数</td><td style="text-align:left">范围为 -2147483648 至 2147483647</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8 字节有符号整数</td><td style="text-align:left">范围为 -9223372036854775808 至 9223372036854775807</td></tr><tr><td style="text-align:left">DECIMAL(p, s)</td><td style="text-align:left">定点数（即：小数点位置固定）</td><td style="text-align:left">示例：123.45 和 DECIMAL ‘123.45’ 是相同的值，并且类型为 DECIMAL(5, 2)</td></tr><tr><td style="text-align:left">NUMERIC(p, s)</td><td style="text-align:left">定点数（即：小数点位置固定）</td><td style="text-align:left">DECIMAL 的同义词</td></tr><tr><td style="text-align:left">REAL</td><td style="text-align:left">4 字节浮点数</td><td style="text-align:left">6 位小数精度；示例：CAST(1.2 AS REAL)、CAST(‘Infinity’ AS REAL)</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">8 字节浮点数</td><td style="text-align:left">15 位小数精度；示例：1.4E2、CAST(‘-Infinity’ AS DOUBLE)、CAST(‘NaN’ AS DOUBLE)</td></tr><tr><td style="text-align:left">FLOAT</td><td style="text-align:left">8 字节浮点数</td><td style="text-align:left">DOUBLE 的同义词</td></tr><tr><td style="text-align:left">CHAR(n), CHARACTER(n)</td><td style="text-align:left">定长字符串</td><td style="text-align:left">‘Hello’、‘’（空字符串）、_latin1’Hello’、n’Hello’、_UTF16’Hello’、‘Hello’ ‘there’（字面量分为多个部分）、e’Hello\nthere’（字面量包含 C 风格的转义符）</td></tr><tr><td style="text-align:left">VARCHAR(n), CHARACTER VARYING(n)</td><td style="text-align:left">变长字符串</td><td style="text-align:left">作为 CHAR(n)</td></tr><tr><td style="text-align:left">BINARY(n)</td><td style="text-align:left">固定宽度的二进制字符串</td><td style="text-align:left">x’45F0AB’、x’‘（空二进制字符串）、x’AB’ ‘CD’（多部分二进制字符串字面量）</td></tr><tr><td style="text-align:left">VARBINARY(n), BINARY VARYING(n)</td><td style="text-align:left">变长二进制字符串</td><td style="text-align:left">作为 BINARY(n)</td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:left">日期</td><td style="text-align:left">示例：DATE “1969-07-20”</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">一天中的时间</td><td style="text-align:left">示例：TIME “20:17:40”</td></tr><tr><td style="text-align:left">TIMESTAMP [ WITHOUT TIME ZONE ]</td><td style="text-align:left">日期和时间</td><td style="text-align:left">示例：TIMESTAMP ‘1969-07-20 20:17:40’</td></tr><tr><td style="text-align:left">TIMESTAMP WITH LOCAL TIME ZONE</td><td style="text-align:left">带有当地时区的日期和时间</td><td style="text-align:left">示例：TIMESTAMP ‘1969-07-20 20:17:40 America/Los Angeles’</td></tr><tr><td style="text-align:left">TIMESTAMP WITH TIME ZONE</td><td style="text-align:left">带时区的日期和时间</td><td style="text-align:left">示例：TIMESTAMP ‘1969-07-20 20:17:40 America/Los Angeles’</td></tr><tr><td style="text-align:left">INTERVAL timeUnit [ TO timeUnit ]</td><td style="text-align:left">日期时间间隔</td><td style="text-align:left">示例：INTERVAL ‘1-5’ YEAR TO MONTH, INTERVAL ‘45’ DAY, INTERVAL ‘1 2:34:56.789’ DAY TO SECOND</td></tr><tr><td style="text-align:left">GEOMETRY</td><td style="text-align:left">几何类型</td><td style="text-align:left">示例： ST_GeomFromText(‘POINT (30 10)’)</td></tr></tbody></table><p><code>timeUnit</code> 包含了以下可选值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeUnit:</span><br><span class="line">  MILLENNIUM <span class="operator">|</span> CENTURY <span class="operator">|</span> DECADE <span class="operator">|</span> <span class="keyword">YEAR</span> <span class="operator">|</span> QUARTER <span class="operator">|</span> <span class="keyword">MONTH</span> <span class="operator">|</span> WEEK <span class="operator">|</span> DOY <span class="operator">|</span> DOW <span class="operator">|</span> <span class="keyword">DAY</span> <span class="operator">|</span> <span class="keyword">HOUR</span> <span class="operator">|</span> <span class="keyword">MINUTE</span> <span class="operator">|</span> <span class="keyword">SECOND</span> <span class="operator">|</span> EPOCH</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>DATE、TIME 和 TIMESTAMP 没有时区。对于这些类型，甚至没有隐式时区，例如 UTC（如 Java 中）或本地时区。由用户或应用程序提供时区。反过来，TIMESTAMP WITH LOCAL TIME ZONE 不会在内部存储时区，但它将依赖于提供的时区来提供正确的语义。</li><li>仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#allowGeometry--">一致性级别</a>中才允许使用几何类型。</li><li>间隔字面量只能使用时间单位 YEAR、QUARTER、MONTH、WEEK、DAY、HOUR、MINUTE 和 SECOND。在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#allowPluralTimeUnits--">一致性级别</a>中，我们还允许使用复数形式：YEARS、QUARTERS、MONTHS、WEEKS、DAYS、HOURS、MINUTES 和 SECONDS。</li></ul><h3 id="非标量类型"><a class="markdownIt-Anchor" href="#非标量类型"></a> 非标量类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">示例字面量</th></tr></thead><tbody><tr><td style="text-align:left">ANY</td><td style="text-align:left">所有类型的联合</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">UNKNOWN</td><td style="text-align:left">未知类型的值，用作占位符</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">ROW</td><td style="text-align:left">具有 1 列或多列的行</td><td style="text-align:left">示例：row(f0 int null, f1 varchar)</td></tr><tr><td style="text-align:left">MAP</td><td style="text-align:left">键值对集合</td><td style="text-align:left">示例：(int, varchar) map</td></tr><tr><td style="text-align:left">MULTISET</td><td style="text-align:left">可能包含重复项的无序集合</td><td style="text-align:left">示例：int multiset</td></tr><tr><td style="text-align:left">ARRAY</td><td style="text-align:left">可能包含重复项的有序连续集合</td><td style="text-align:left">示例：varchar(10) array</td></tr><tr><td style="text-align:left">CURSOR</td><td style="text-align:left">执行结果之上的游标</td><td style="text-align:left"></td></tr></tbody></table><p>注意：</p><ul><li>每个 <code>ROW</code> 列类型，都可以有一个可选的 <code>[ NULL | NOT NULL ]</code> 后缀，用来声明此列类型是否可为空，默认值是不可为空。</li></ul><h3 id="空间类型"><a class="markdownIt-Anchor" href="#空间类型"></a> 空间类型</h3><p>空间数据使用字符串（众所周知的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Well-known_text">text (WKT)</a> 编码）或者二进制字符串进行表示（众所周知的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Well-known_binary">binary (WKB)</a> 编码）。</p><p>在要使用字面量的地方，应用 <code>ST_GeomFromText</code> 函数，例如 <code>ST_GeomFromText('POINT (30 10)')</code> 。</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">类型编码</th><th style="text-align:left">WKT 中的示例</th></tr></thead><tbody><tr><td style="text-align:left">GEOMETRY</td><td style="text-align:left">0</td><td style="text-align:left">点、曲线、曲面、几何集合的泛化</td></tr><tr><td style="text-align:left">POINT</td><td style="text-align:left">1</td><td style="text-align:left"><code>ST_GeomFromText('POINT (30 10)')</code> 是 2D 空间中的点； <code>ST_GeomFromText('POINT Z(30 10 2)')</code> 是 3D 空间中的点</td></tr><tr><td style="text-align:left">CURVE</td><td style="text-align:left">13</td><td style="text-align:left">LINESTRING 的泛化</td></tr><tr><td style="text-align:left">LINESTRING</td><td style="text-align:left">2</td><td style="text-align:left"><code>ST_GeomFromText('LINESTRING (30 10, 10 30, 40 40)')</code></td></tr><tr><td style="text-align:left">SURFACE</td><td style="text-align:left">14</td><td style="text-align:left">多边形、多面体曲面的泛化</td></tr><tr><td style="text-align:left">POLYGON</td><td style="text-align:left">3</td><td style="text-align:left"><code>ST_GeomFromText('POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))')</code> 是五边形； <code>ST_GeomFromText('POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))')</code> 是一个有四边形孔的五边形</td></tr><tr><td style="text-align:left">POLYHEDRALSURFACE</td><td style="text-align:left">15</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">GEOMETRYCOLLECTION</td><td style="text-align:left">7</td><td style="text-align:left">零个或多个 GEOMETRY 实例的集合；多点、多线、多多边形的概括</td></tr><tr><td style="text-align:left">MULTIPOINT</td><td style="text-align:left">4</td><td style="text-align:left">ST_GeomFromText(‘MULTIPOINT ((10 40), (40 30), (20 20), (30 10))’) <code>等价于</code>ST_GeomFromText(‘MULTIPOINT (10 40, 40 30, 20 20, 30 10)’)</td></tr><tr><td style="text-align:left">MULTICURVE</td><td style="text-align:left">-</td><td style="text-align:left">MULTILINESTRING 的泛化</td></tr><tr><td style="text-align:left">MULTILINESTRING</td><td style="text-align:left">5</td><td style="text-align:left"><code>ST_GeomFromText('MULTILINESTRING ((10 10, 20 20, 10 40), (40 40, 30 30, 40 20, 30 10))')</code></td></tr><tr><td style="text-align:left">MULTISURFACE</td><td style="text-align:left">-</td><td style="text-align:left">MULTIPOLYGON 的泛化</td></tr><tr><td style="text-align:left">MULTIPOLYGON</td><td style="text-align:left">6</td><td style="text-align:left"><code>ST_GeomFromText('MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)))')</code></td></tr></tbody></table><h2 id="运算符和函数"><a class="markdownIt-Anchor" href="#运算符和函数"></a> 运算符和函数</h2><h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h3><p>运算符优先级和结合性，从高到低。</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">结合性</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">::</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">[ ]（集合元素）</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">+ -（一元加、减）</td><td style="text-align:left">右</td></tr><tr><td style="text-align:left">* / % ||</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">BETWEEN, IN, LIKE, SIMILAR, OVERLAPS, CONTAINS 等</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">&lt; &gt; = &lt;= &gt;= &lt;&gt; != &lt;=&gt;</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">IS NULL, IS FALSE, IS NOT TRUE 等</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">NOT</td><td style="text-align:left">右</td></tr><tr><td style="text-align:left">AND</td><td style="text-align:left">左</td></tr><tr><td style="text-align:left">OR</td><td style="text-align:left">左</td></tr></tbody></table><p>注意：<code>::</code> 、 <code>&lt;=&gt;</code> 是特定于方言的，但为了完整性起见在此表中显示。</p><h3 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> 比较运算符</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">value1 = value2</td><td style="text-align:left">等于</td></tr><tr><td style="text-align:left">value1 &lt;&gt; value2</td><td style="text-align:left">不等于</td></tr><tr><td style="text-align:left">value1 != value2</td><td style="text-align:left">不相等（仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isBangEqualAllowed--">一致性级别</a>）</td></tr><tr><td style="text-align:left">value1 &gt; value2</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">value1 &gt;= value2</td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left">value1 &lt; value2</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">value1 &lt;= value2</td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left">value1 &lt;=&gt; value2</td><td style="text-align:left">两个值是否相等，将 null 值视为相同</td></tr><tr><td style="text-align:left">value IS NULL</td><td style="text-align:left">值是否为 null</td></tr><tr><td style="text-align:left">value IS NOT NULL</td><td style="text-align:left">值是否不为 null</td></tr><tr><td style="text-align:left">value1 IS DISTINCT FROM value2</td><td style="text-align:left">两个值是否不相等，将 null 值视为相同</td></tr><tr><td style="text-align:left">value1 IS NOT DISTINCT FROM value2</td><td style="text-align:left">两个值是否相等，将 null 值视为相同</td></tr><tr><td style="text-align:left">value1 BETWEEN value2 AND value3</td><td style="text-align:left">value1 是否大于等于 value2 且小于等于 value3</td></tr><tr><td style="text-align:left">value1 NOT BETWEEN value2 AND value3</td><td style="text-align:left">value1 是否小于 value2 并且大于 value3</td></tr><tr><td style="text-align:left">string1 LIKE string2 [ ESCAPE string3 ]</td><td style="text-align:left">string1 是否与模式 string2 匹配</td></tr><tr><td style="text-align:left">string1 NOT LIKE string2 [ ESCAPE string3 ]</td><td style="text-align:left">string1 是否与模式 string2 不匹配</td></tr><tr><td style="text-align:left">string1 SIMILAR TO string2 [ ESCAPE string3 ]</td><td style="text-align:left">string1 是否与正则表达式 string2 匹配</td></tr><tr><td style="text-align:left">string1 NOT SIMILAR TO string2 [ ESCAPE string3 ]</td><td style="text-align:left">string1 是否与正则表达式 string2 不匹配</td></tr><tr><td style="text-align:left">value IN (value [, value ]*)</td><td style="text-align:left">value 是否等于列表中的值</td></tr><tr><td style="text-align:left">value NOT IN (value [, value ]*)</td><td style="text-align:left">value 是否不等于列表中的每个值</td></tr><tr><td style="text-align:left">value IN (sub-query)</td><td style="text-align:left">value 是否等于子查询返回的行</td></tr><tr><td style="text-align:left">value NOT IN (sub-query)</td><td style="text-align:left">value 是否不等于子查询返回的每一行</td></tr><tr><td style="text-align:left">value comparison SOME (sub-query or collection)</td><td style="text-align:left">是否值比较 SOME 的子查询或集合至少返回一行</td></tr><tr><td style="text-align:left">value comparison ANY (sub-query or collection)</td><td style="text-align:left"><code>SOME</code> 的同义词</td></tr><tr><td style="text-align:left">value comparison ALL (sub-query or collection)</td><td style="text-align:left">是否值比较 ALL 的子查询或集合返回所有值</td></tr><tr><td style="text-align:left">EXISTS (sub-query)</td><td style="text-align:left">子查询是否至少返回一行</td></tr><tr><td style="text-align:left">UNIQUE (sub-query)</td><td style="text-align:left">子查询返回的行是否唯一（忽略空值）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comp:</span><br><span class="line">      <span class="operator">=</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&lt;&gt;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&gt;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&gt;=</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&lt;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&lt;=</span></span><br><span class="line">  <span class="operator">|</span>   <span class="operator">&lt;=&gt;</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">boolean1 OR boolean2</td><td style="text-align:left">boolean1 为 TRUE 或者 boolean2 为 TRUE</td></tr><tr><td style="text-align:left">boolean1 AND boolean2</td><td style="text-align:left">boolean1 为 TRUE 并且 boolean2 为 TRUE</td></tr><tr><td style="text-align:left">NOT boolean</td><td style="text-align:left">布尔值是否不为 TRUE；如果布尔值未知，则返回 UNKNOWN</td></tr><tr><td style="text-align:left">boolean IS FALSE</td><td style="text-align:left">布尔值是否为FALSE；如果布尔值未知则返回 FALSE</td></tr><tr><td style="text-align:left">boolean IS NOT FALSE</td><td style="text-align:left">布尔值是否不为 FALSE；如果布尔值未知则返回 TRUE</td></tr><tr><td style="text-align:left">boolean IS TRUE</td><td style="text-align:left">布尔值是否为 TRUE；如果布尔值未知则返回 FALSE</td></tr><tr><td style="text-align:left">boolean IS NOT TRUE</td><td style="text-align:left">布尔值是否不为 TRUE；如果布尔值未知则返回 TRUE</td></tr><tr><td style="text-align:left">boolean IS UNKNOWN</td><td style="text-align:left">布尔值是否未知</td></tr><tr><td style="text-align:left">boolean IS NOT UNKNOWN</td><td style="text-align:left">布尔值是否不为 UNKNOWN</td></tr></tbody></table><h3 id="算术运算符和函数"><a class="markdownIt-Anchor" href="#算术运算符和函数"></a> 算术运算符和函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">+ numeric</td><td style="text-align:left">返回数字</td></tr><tr><td style="text-align:left">- numeric</td><td style="text-align:left">返回负数</td></tr><tr><td style="text-align:left">numeric1 + numeric2</td><td style="text-align:left">返回 numeric1 加 numeric2</td></tr><tr><td style="text-align:left">numeric1 - numeric2</td><td style="text-align:left">返回 numeric1 减去 numeric2</td></tr><tr><td style="text-align:left">numeric1 * numeric2</td><td style="text-align:left">返回 numeric1 乘以 numeric2</td></tr><tr><td style="text-align:left">numeric1 / numeric2</td><td style="text-align:left">返回 numeric1 除以 numeric2</td></tr><tr><td style="text-align:left">numeric1 % numeric2</td><td style="text-align:left">作为 MOD(numeric1, numeric2)（仅在某些<a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/validate/SqlConformance.html#isPercentRemainderAllowed--">一致性级别</a>）</td></tr><tr><td style="text-align:left">POWER(numeric1, numeric2)</td><td style="text-align:left">返回 numeric1 的 numeric2 次方</td></tr><tr><td style="text-align:left">ABS(numeric)</td><td style="text-align:left">返回数字的绝对值</td></tr><tr><td style="text-align:left">MOD(numeric1, numeric2)</td><td style="text-align:left">返回 numeric1 除以 numeric2 的余数（模）。仅当 numeric1 为负数时结果才为负数</td></tr><tr><td style="text-align:left">SQRT(numeric)</td><td style="text-align:left">返回数字的平方根</td></tr><tr><td style="text-align:left">LN(numeric)</td><td style="text-align:left">返回数值的自然对数（以 e 为底）</td></tr><tr><td style="text-align:left">LOG10(numeric)</td><td style="text-align:left">返回 numeric 以 10 为底的对数</td></tr><tr><td style="text-align:left">EXP(numeric)</td><td style="text-align:left">返回 e 的数值次方</td></tr><tr><td style="text-align:left">CEIL(numeric)</td><td style="text-align:left">将 numeric 向上舍入，返回大于或等于 numeric 的最小整数</td></tr><tr><td style="text-align:left">FLOOR(numeric)</td><td style="text-align:left">将数字向下舍入，返回小于或等于数字的最大整数</td></tr><tr><td style="text-align:left">RAND([seed])</td><td style="text-align:left">生成 0 到 1（含）之间的随机双精度数，可选择使用种子初始化随机数生成器</td></tr><tr><td style="text-align:left">RAND_INTEGER([seed, ] numeric)</td><td style="text-align:left">生成 0 到 numeric - 1（含）之间的随机整数，可选择使用种子初始化随机数生成器</td></tr><tr><td style="text-align:left">ACOS(numeric)</td><td style="text-align:left">返回数值的反余弦</td></tr><tr><td style="text-align:left">ASIN(numeric)</td><td style="text-align:left">返回数字的反正弦值</td></tr><tr><td style="text-align:left">ATAN(numeric)</td><td style="text-align:left">返回数值的反正切值</td></tr><tr><td style="text-align:left">ATAN2(numeric, numeric)</td><td style="text-align:left">返回数字坐标的反正切值</td></tr><tr><td style="text-align:left">CBRT(numeric)</td><td style="text-align:left">返回数字的立方根</td></tr><tr><td style="text-align:left">COS(numeric)</td><td style="text-align:left">返回数字的余弦值</td></tr><tr><td style="text-align:left">COT(numeric)</td><td style="text-align:left">返回数值的余切值</td></tr><tr><td style="text-align:left">DEGREES(numeric)</td><td style="text-align:left">将数值从弧度转换为度数</td></tr><tr><td style="text-align:left">PI()</td><td style="text-align:left">返回比任何其他值更接近 pi 的值</td></tr><tr><td style="text-align:left">RADIANS(numeric)</td><td style="text-align:left">将数值从度数转换为弧度</td></tr><tr><td style="text-align:left">ROUND(numeric1 [, numeric2])</td><td style="text-align:left">将 numeric1 舍入到小数点右边可选的 numeric2（如果未指定 0）位</td></tr><tr><td style="text-align:left">SIGN(numeric)</td><td style="text-align:left">返回数字的符号</td></tr><tr><td style="text-align:left">SIN(numeric)</td><td style="text-align:left">返回数字的正弦值</td></tr><tr><td style="text-align:left">TAN(numeric)</td><td style="text-align:left">返回数字的正切值</td></tr><tr><td style="text-align:left">TRUNCATE(numeric1 [, numeric2])</td><td style="text-align:left">将 numeric1 截断为可选的 numeric2（如果未指定 0）小数点右边的位置</td></tr></tbody></table><h3 id="字符串运算符和函数"><a class="markdownIt-Anchor" href="#字符串运算符和函数"></a> 字符串运算符和函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">string || string</td><td style="text-align:left">连接两个字符串</td></tr><tr><td style="text-align:left">CHAR_LENGTH(string)</td><td style="text-align:left">返回字符串中的字符数</td></tr><tr><td style="text-align:left">CHARACTER_LENGTH(string)</td><td style="text-align:left">像 CHAR_LENGTH(string) 一样，返回字符串中的字符数</td></tr><tr><td style="text-align:left">UPPER(string)</td><td style="text-align:left">返回转换为大写字母的字符串</td></tr><tr><td style="text-align:left">LOWER(string)</td><td style="text-align:left">返回转换为小写字母的字符串</td></tr><tr><td style="text-align:left">POSITION(substring IN string)</td><td style="text-align:left">返回 <em>string</em> 中 <em>substring</em> 第一次出现的位置</td></tr><tr><td style="text-align:left">POSITION(substring IN string FROM integer)</td><td style="text-align:left">返回从给定点开始在 <em>string</em> 中第一次出现 <em>substring</em> 的位置（非标准 SQL）</td></tr><tr><td style="text-align:left">TRIM( { BOTH | LEADING | TRAILING } string1 FROM string2)</td><td style="text-align:left">从 <em>string1</em> 的<strong>开始/结束/两端</strong>删除仅包含 <em>string1</em> 中字符的最长字符串</td></tr><tr><td style="text-align:left">OVERLAY(string1 PLACING string2 FROM integer [ FOR integer2 ])</td><td style="text-align:left">用 <em>string2</em> 替换 <em>string1</em> 的子字符串</td></tr><tr><td style="text-align:left">SUBSTRING(string FROM integer)</td><td style="text-align:left">返回从给定点开始的字符串的子字符串</td></tr><tr><td style="text-align:left">SUBSTRING(string FROM integer FOR integer)</td><td style="text-align:left">返回从给定点开始、具有给定长度的字符串子字符串。</td></tr><tr><td style="text-align:left">INITCAP(string)</td><td style="text-align:left">返回 <em>string</em>，其中每个单词的首字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。</td></tr></tbody></table><p>未实现：</p><ul><li><code>SUBSTRING(string FROM regexp FOR regexp)</code></li></ul><h3 id="二进制字符串运算符和函数"><a class="markdownIt-Anchor" href="#二进制字符串运算符和函数"></a> 二进制字符串运算符和函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">binary || binary</td><td style="text-align:left">连接两个二进制字符串</td></tr><tr><td style="text-align:left">OCTET_LENGTH(binary)</td><td style="text-align:left">返回<em>二进制</em>的字节数</td></tr><tr><td style="text-align:left">POSITION(binary1 IN binary2)</td><td style="text-align:left">返回 <em>binary1</em> 在 <em>binary2</em> 中第一次出现的位置</td></tr><tr><td style="text-align:left">POSITION(binary1 IN binary2 FROM integer)</td><td style="text-align:left">返回从给定点开始 <em>binary1</em> 在 <em>binary2</em> 中第一次出现的位置（非标准 SQL）</td></tr><tr><td style="text-align:left">OVERLAY(binary1 PLACING binary2 FROM integer [ FOR integer2 ])</td><td style="text-align:left">用 <em>binary2</em> 替换 <em>binary1</em> 的子字符串</td></tr><tr><td style="text-align:left">SUBSTRING(binary FROM integer)</td><td style="text-align:left">返回从给定点开始的 <em>binary</em> 子字符串</td></tr><tr><td style="text-align:left">SUBSTRING(binary FROM integer FOR integer)</td><td style="text-align:left">返回从给定点开始、具有给定长度的 <em>binary</em> 子字符串</td></tr></tbody></table><h3 id="日期时间函数"><a class="markdownIt-Anchor" href="#日期时间函数"></a> 日期/时间函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">LOCALTIME</td><td style="text-align:left">以 TIME 数据类型的值返回会话时区的当前日期和时间</td></tr><tr><td style="text-align:left">LOCALTIME(precision)</td><td style="text-align:left">以 TIME 数据类型的值返回会话时区中的当前日期和时间，精度为 <em>precision</em> 位</td></tr><tr><td style="text-align:left">LOCALTIMESTAMP</td><td style="text-align:left">以 TIMESTAMP 数据类型的值返回会话时区的当前日期和时间</td></tr><tr><td style="text-align:left">LOCALTIMESTAMP(precision)</td><td style="text-align:left">以 TIMESTAMP 数据类型的值返回会话时区中的当前日期和时间，精度为 precision 位</td></tr><tr><td style="text-align:left">CURRENT_TIME</td><td style="text-align:left">返回会话时区中的当前时间，数据类型为 TIMESTAMP WITH TIME ZONE</td></tr><tr><td style="text-align:left">CURRENT_DATE</td><td style="text-align:left">以 DATE 数据类型的值返回会话时区的当前日期</td></tr><tr><td style="text-align:left">CURRENT_TIMESTAMP</td><td style="text-align:left">返回会话时区中的当前日期和时间，数据类型为 TIMESTAMP WITH TIME ZONE</td></tr><tr><td style="text-align:left">EXTRACT(timeUnit FROM datetime)</td><td style="text-align:left">从日期时间值表达式中提取并返回指定日期时间字段的值</td></tr><tr><td style="text-align:left">FLOOR(datetime TO timeUnit)</td><td style="text-align:left">将日期时间向下舍入为时间单位</td></tr><tr><td style="text-align:left">CEIL(datetime TO timeUnit)</td><td style="text-align:left">将日期时间向上舍入为时间单位</td></tr><tr><td style="text-align:left">YEAR(date)</td><td style="text-align:left">等价于 EXTRACT(YEAR FROM date)，返回一个整数</td></tr><tr><td style="text-align:left">QUARTER(date)</td><td style="text-align:left">等价于 EXTRACT(QUARTER FROM date)，返回 1 到 4 之间的整数</td></tr><tr><td style="text-align:left">MONTH(date)</td><td style="text-align:left">等价于 EXTRACT(MONTH FROM date)。返回 1 到 12 之间的整数</td></tr><tr><td style="text-align:left">WEEK(date)</td><td style="text-align:left">等价于 EXTRACT(WEEK FROM date)。返回 1 到 53 之间的整数</td></tr><tr><td style="text-align:left">DAYOFYEAR(date)</td><td style="text-align:left">等价于 EXTRACT(DOY FROM date)。返回 1 到 366 之间的整数</td></tr><tr><td style="text-align:left">DAYOFMONTH(date)</td><td style="text-align:left">等价于 EXTRACT(DAY FROM date)。返回 1 到 31 之间的整数</td></tr><tr><td style="text-align:left">DAYOFWEEK(date)</td><td style="text-align:left">等价于 EXTRACT(DOW FROM date)。返回 1 到 7 之间的整数</td></tr><tr><td style="text-align:left">HOUR(date)</td><td style="text-align:left">等价于 EXTRACT(HOUR FROM date)。返回 0 到 23 之间的整数</td></tr><tr><td style="text-align:left">MINUTE(date)</td><td style="text-align:left">等价于 EXTRACT(MINUTE FROM date)。返回 0 到 59 之间的整数</td></tr><tr><td style="text-align:left">SECOND(date)</td><td style="text-align:left">等价于 EXTRACT(SECOND FROM date)。返回 0 到 59 之间的整数</td></tr><tr><td style="text-align:left">TIMESTAMPADD(timeUnit, integer, datetime)</td><td style="text-align:left">返回添加了（有符号）整数时间单位间隔的日期时间。等价于 <code>datetime + INTERVAL 'integer' timeUnit</code></td></tr><tr><td style="text-align:left">TIMESTAMPDIFF(timeUnit, datetime, datetime2)</td><td style="text-align:left">返回 datetime 和 datetime2 之间的 timeUnit 间隔数（有符号）。等价于 <code>(datetime2 - datetime) timeUnit</code></td></tr><tr><td style="text-align:left">LAST_DAY(date)</td><td style="text-align:left">以 DATE 数据类型的值返回月份最后一天的日期；例如，对于 DATE’2020-02-10’ 和 TIMESTAMP’2020-02-10 10:10:10’，它均返回 DATE’2020-02-29’</td></tr></tbody></table><p>在标准 SQL 中，对 niladic 函数（例如 CURRENT_DATE）的调用不接受括号。在某些一致性级别中，可以接受带括号的调用（例如 CURRENT_DATE()）。</p><p>未实现：</p><ul><li><code>CEIL(interval)</code></li><li><code>FLOOR(interval)</code></li><li><code>+ interval</code></li><li><code>- interval</code></li><li><code>interval + interval</code></li><li><code>interval - interval</code></li><li><code>interval / interval</code></li></ul><h3 id="系统函数"><a class="markdownIt-Anchor" href="#系统函数"></a> 系统函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">USER</td><td style="text-align:left">等价于 CURRENT_USER</td></tr><tr><td style="text-align:left">CURRENT_USER</td><td style="text-align:left">当前执行上下文的用户名</td></tr><tr><td style="text-align:left">SESSION_USER</td><td style="text-align:left">会话用户名</td></tr><tr><td style="text-align:left">SYSTEM_USER</td><td style="text-align:left">返回操作系统识别的当前数据存储用户的名称</td></tr><tr><td style="text-align:left">CURRENT_PATH</td><td style="text-align:left">返回一个字符串，表示当前查找范围以引用用户定义的例程和类型</td></tr><tr><td style="text-align:left">CURRENT_ROLE</td><td style="text-align:left">返回当前活动角色</td></tr><tr><td style="text-align:left">CURRENT_SCHEMA</td><td style="text-align:left">返回当前模式</td></tr></tbody></table><h3 id="条件函数和运算符"><a class="markdownIt-Anchor" href="#条件函数和运算符"></a> 条件函数和运算符</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CASE value<br>WHEN value1 [, value11 ]* THEN result1<br>[ WHEN valueN [, valueN1 ]* THEN resultN ]*<br>[ ELSE resultZ ]<br>END</td><td style="text-align:left">简单案例</td></tr><tr><td style="text-align:left">CASE<br>WHEN condition1 THEN result1<br>[ WHEN conditionN THEN resultN ]*<br>[ ELSE resultZ ]<br>END</td><td style="text-align:left">搜索案例</td></tr><tr><td style="text-align:left">NULLIF(value, value)</td><td style="text-align:left">如果值相同则返回 NULL。例如，<code>NULLIF(5, 5)</code> 返回NULL；<code>NULLIF(5, 0)</code> 返回 5。</td></tr><tr><td style="text-align:left">COALESCE(value, value [, value ]*)</td><td style="text-align:left">如果第一个值为 null，则提供一个值。 例如，<code>COALESCE(NULL, 5)</code> 返回 5。</td></tr></tbody></table><h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3><p>通常，表达式不能包含不同数据类型的值。例如，表达式不能将 5 乘以 10，然后添加 <code>JULIAN</code>。但是，Calcite 支持将值从一种数据类型隐式和显式转换为另一种数据类型。</p><h4 id="隐式和显式类型转换"><a class="markdownIt-Anchor" href="#隐式和显式类型转换"></a> 隐式和显式类型转换</h4><p>Calcite 建议你指定显式转换，而不是依赖隐式或自动转换，原因如下：</p><ul><li>使用显式数据类型转换函数时，SQL 语句更容易理解；</li><li>隐式数据类型转换可能会对性能产生负面影响，尤其是当列值的数据类型转换为常量数据类型而不是与之相反时；</li><li>隐式转换取决于它发生的上下文，并且在每种情况下可能不会以相同的方式工作。例如，从日期时间值到 VARCHAR 值的隐式转换可能会返回意外的格式。</li></ul><p>隐式转换的算法可能会在 Calcite 版本之间发生变化，显式转换的行为更可预测。</p><h4 id="显式类型转换"><a class="markdownIt-Anchor" href="#显式类型转换"></a> 显式类型转换</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CAST(value AS type)</td><td style="text-align:left">将值转换为给定类型。整数类型之间的转换会向 0 截断</td></tr><tr><td style="text-align:left">CONVERT(string, charSet1, charSet2)</td><td style="text-align:left">将字符串从 charSet1 转换为 charSet2</td></tr><tr><td style="text-align:left">CONVERT(value USING transcodingName)</td><td style="text-align:left">将值从一个基本字符集更改为 transcodingName</td></tr><tr><td style="text-align:left">TRANSLATE(value USING transcodingName)</td><td style="text-align:left">将值从一个基本字符集更改为 transcodingName</td></tr></tbody></table><p>将字符串转换为 BINARY 或 VARBINARY 类型会生成字符串字符集中字符串编码的字节列表。如果字符串的字符无法使用其字符集表示，则会产生运行时错误。</p><p>支持的数据类型语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">type:</span><br><span class="line">      typeName</span><br><span class="line">      [ collectionsTypeName ]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line">typeName:</span><br><span class="line">      sqlTypeName</span><br><span class="line">  <span class="operator">|</span>   rowTypeName</span><br><span class="line">  <span class="operator">|</span>   compoundIdentifier</span><br><span class="line"></span><br><span class="line">sqlTypeName:</span><br><span class="line">      <span class="type">char</span> [ <span class="keyword">precision</span> ] [ charSet ]</span><br><span class="line">  <span class="operator">|</span>   <span class="type">varchar</span> [ <span class="keyword">precision</span> ] [ charSet ]</span><br><span class="line">  <span class="operator">|</span>   <span class="type">DATE</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">time</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">timestamp</span></span><br><span class="line">  <span class="operator">|</span>   GEOMETRY</span><br><span class="line">  <span class="operator">|</span>   <span class="type">decimal</span> [ <span class="keyword">precision</span> [, scale] ]</span><br><span class="line">  <span class="operator">|</span>   <span class="type">BOOLEAN</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">integer</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">BINARY</span> [ <span class="keyword">precision</span> ]</span><br><span class="line">  <span class="operator">|</span>   <span class="type">varbinary</span> [ <span class="keyword">precision</span> ]</span><br><span class="line">  <span class="operator">|</span>   TINYINT</span><br><span class="line">  <span class="operator">|</span>   <span class="type">SMALLINT</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">BIGINT</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">REAL</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">double</span></span><br><span class="line">  <span class="operator">|</span>   <span class="type">FLOAT</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">ANY</span> [ <span class="keyword">precision</span> [, scale] ]</span><br><span class="line"></span><br><span class="line">collectionsTypeName:</span><br><span class="line">      <span class="keyword">ARRAY</span> <span class="operator">|</span> <span class="keyword">MULTISET</span></span><br><span class="line"></span><br><span class="line">rowTypeName:</span><br><span class="line">      <span class="type">ROW</span> <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      fieldName1 fieldType1 [ <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NOT NULL</span> ]</span><br><span class="line">      [ , fieldName2 fieldType2 [ <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NOT NULL</span> ] ]<span class="operator">*</span></span><br><span class="line">      <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>:</span><br><span class="line">      <span class="type">CHARACTER</span> <span class="operator">|</span> <span class="type">CHAR</span></span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>:</span><br><span class="line">      <span class="type">char</span> <span class="type">VARYING</span> <span class="operator">|</span> <span class="type">VARCHAR</span></span><br><span class="line"></span><br><span class="line"><span class="type">decimal</span>:</span><br><span class="line">      <span class="type">DECIMAL</span> <span class="operator">|</span> <span class="type">DEC</span> <span class="operator">|</span> <span class="type">NUMERIC</span></span><br><span class="line"></span><br><span class="line"><span class="type">integer</span>:</span><br><span class="line">      <span class="type">INTEGER</span> <span class="operator">|</span> <span class="type">INT</span></span><br><span class="line"></span><br><span class="line"><span class="type">varbinary</span>:</span><br><span class="line">      <span class="type">BINARY</span> <span class="type">VARYING</span> <span class="operator">|</span> <span class="type">VARBINARY</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>:</span><br><span class="line">      <span class="keyword">DOUBLE</span> [ <span class="keyword">PRECISION</span> ]</span><br><span class="line"></span><br><span class="line"><span class="type">time</span>:</span><br><span class="line">      <span class="type">TIME</span> [ <span class="keyword">precision</span> ] [ timeZone ]</span><br><span class="line"></span><br><span class="line"><span class="type">timestamp</span>:</span><br><span class="line">      <span class="type">TIMESTAMP</span> [ <span class="keyword">precision</span> ] [ timeZone ]</span><br><span class="line"></span><br><span class="line">charSet:</span><br><span class="line">      <span class="keyword">CHARACTER SET</span> charSetName</span><br><span class="line"></span><br><span class="line">timeZone:</span><br><span class="line">      <span class="keyword">WITHOUT</span> <span class="type">TIME</span> ZONE</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">WITH</span> <span class="keyword">LOCAL</span> <span class="type">TIME</span> ZONE</span><br></pre></td></tr></table></figure><h4 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h4><p>当这种转换有意义时，Calcite 会自动将值从一种数据类型转换为另一种数据类型。下表是 Calcite 类型转换矩阵，该表显示了所有可能的转换，而不考虑转换的上下文。管理这些细节的规则遵循该表。</p><table><thead><tr><th style="text-align:left">从 - 到</th><th style="text-align:left">NULL</th><th style="text-align:left">BOOLEAN</th><th style="text-align:left">TINYINT</th><th style="text-align:left">SMALLINT</th><th style="text-align:left">INT</th><th style="text-align:left">BIGINT</th><th style="text-align:left">DECIMAL</th><th style="text-align:left">FLOAT OR REAL</th><th style="text-align:left">DOUBLE</th><th style="text-align:left">INTERVAL</th><th style="text-align:left">DATE</th><th style="text-align:left">TIME</th><th style="text-align:left">TIMESTAMP</th><th style="text-align:left">CHAR OR VARCHAR</th><th style="text-align:left">BINARY OR VARBINARY</th><th style="text-align:left">GEOMETRY</th><th style="text-align:left">ARRAY</th></tr></thead><tbody><tr><td style="text-align:left">NULL</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">BOOLEAN</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">DECIMAL</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">FLOAT/REAL</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">INTERVAL</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">CHAR or VARCHAR</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">i</td></tr><tr><td style="text-align:left">BINARY or VARBINARY</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">e</td><td style="text-align:left">i</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">GEOMETRY</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td><td style="text-align:left">i</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">ARRAY</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">i</td></tr></tbody></table><p><code>i</code>：隐式转换 / <code>e</code>：显式转换 / <code>x</code>：不允许</p><h5 id="转化条件和策略"><a class="markdownIt-Anchor" href="#转化条件和策略"></a> 转化条件和策略</h5><ul><li>集合运算（<code>UNION</code>、<code>EXCEPT</code>、<code>INTERSECT</code>）：比较各分支行的数据类型，找出各字段对的公共类型；</li><li>二进制算术表达式（<code>+</code>、<code>-</code>、<code>&amp;</code>、<code>^</code>、<code>/</code>、<code>%</code>）：将字符串操作数提升为另一个数字操作数的数据类型；</li><li>二进制比较（<code>=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>）：如果操作数为 <code>STRING</code> 和 <code>TIMESTAMP</code>，则提升为 <code>TIMESTAMP</code>；使 <code>1 = true</code> 和 <code>0 = false</code> 始终计算为 <code>TRUE</code>；如果有数字类型操作数，则为两个操作数找到共同的类型。</li><li><code>IN</code> 子查询：比较 LHS 和 RHS 的类型，找出共同的类型；如果是结构体类型，则为每个字段找到更宽的类型；</li><li><code>IN</code> 表达式列表：比较每个表达式以找到共同类型；</li><li><code>CASE WHEN</code> 表达式或 <code>COALESCE</code>：找到 <code>THEN</code> 和 <code>ELSE</code> 操作数的共同更宽类型；</li><li>字符 + <code>INTERVAL</code> 或字符 - <code>INTERVAL</code> ：将字符提升为 <code>TIMESTAMP</code>；</li><li>内置函数：查找检查器中注册的类型系列，如果检查器规则允许，则查找系列默认类型；</li><li>用户定义函数（UDF）：根据 <code>eval()</code> 方法声明的参数类型进行强制转换；</li><li><code>INSERT</code> 和 <code>UPDATE</code>：如果两个字段的类型名称或精度（比例）不同，则将源字段强制转换为对应的目标表字段的类型。</li></ul><p>注意：</p><p>以下情况的隐式类型强制将被忽略：</p><ul><li>其中一个类型是 <code>ANY</code>；</li><li><code>CHARACTER</code> 类型中的类型强制始终被忽略，即从 <code>CHAR(20)</code> 到 <code>VARCHAR(30)</code>；</li><li>从一个数字到另一个具有更高优先级的类型强制将被忽略，即从 <code>INT</code> 到 <code>LONG</code>。</li></ul><h5 id="寻找相同类型的策略"><a class="markdownIt-Anchor" href="#寻找相同类型的策略"></a> 寻找相同类型的策略</h5><ul><li>如果操作符有预期的数据类型，则直接将其作为所需类型。（例如，UDF 会有 <code>eval()</code> 方法，该方法有反射参数类型）；</li><li>如果没有预期的数据类型，但已注册数据类型系列，则尝试将参数强制转换为系列的默认数据类型，即 String 系列将具有 <code>VARCHAR</code> 类型；</li><li>如果既未指定预期的数据类型也未指定系列，则尝试找到节点类型中最紧密的公共类型，即 <code>INTEGER</code> 和 <code>DOUBLE</code> 将返回 <code>DOUBLE</code>，这种情况下数字精度不会丢失；</li><li>如果没有找到最紧密的公共类型，则尝试找到更宽的类型，即 <code>VARCHAR</code> 和 <code>INTEGER</code> 将返回 <code>INTEGER</code>，在将小数扩展为小数时，我们允许一些精度损失，或者提升为 <code>VARCHAR</code> 类型。</li></ul><h3 id="值构造函数"><a class="markdownIt-Anchor" href="#值构造函数"></a> 值构造函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ROW (value [, value ]*)</td><td style="text-align:left">根据值列表创建一行。</td></tr><tr><td style="text-align:left">(value [, value ]* )</td><td style="text-align:left">根据值列表创建一行。</td></tr><tr><td style="text-align:left">row ‘[’ index ‘]’</td><td style="text-align:left">返回行中特定位置的元素（从 1 开始的索引）。</td></tr><tr><td style="text-align:left">row ‘[’ name ‘]’</td><td style="text-align:left">返回具有特定名称的行元素。</td></tr><tr><td style="text-align:left">map ‘[’ key ‘]’</td><td style="text-align:left">返回具有特定键的映射元素。</td></tr><tr><td style="text-align:left">array ‘[’ index ‘]’</td><td style="text-align:left">返回数组中特定位置的元素（从 1 开始的索引）。</td></tr><tr><td style="text-align:left">ARRAY ‘[’ value [, value ]* ‘]’</td><td style="text-align:left">根据值列表创建一个数组。</td></tr><tr><td style="text-align:left">MAP ‘[’ key, value [, key, value ]* ‘]’</td><td style="text-align:left">根据键值对列表创建映射。</td></tr></tbody></table><h3 id="查询值构造函数"><a class="markdownIt-Anchor" href="#查询值构造函数"></a> 查询值构造函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ARRAY (sub-query)</td><td style="text-align:left">根据子查询的结果创建一个数组。示例：<code>ARRAY(SELECT empno FROM emp ORDER BY empno)</code></td></tr><tr><td style="text-align:left">MAP (sub-query)</td><td style="text-align:left">根据键值对子查询的结果创建映射。示例：<code>MAP(SELECT empno, deptno FROM emp)</code></td></tr><tr><td style="text-align:left">MULTISET (sub-query)</td><td style="text-align:left">从子查询的结果中创建一个多重集。示例：<code>MULTISET(SELECT empno FROM emp)</code></td></tr></tbody></table><h3 id="集合函数"><a class="markdownIt-Anchor" href="#集合函数"></a> 集合函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ELEMENT(value)</td><td style="text-align:left">返回数组或多集的唯一元素；如果集合为空，则返回 null；如果有多个元素，则抛出。</td></tr><tr><td style="text-align:left">CARDINALITY(value)</td><td style="text-align:left">返回数组或多集内的元素数量。</td></tr><tr><td style="text-align:left">value MEMBER OF multiset</td><td style="text-align:left">返回 <em>value</em> 是否是 <em>multiset</em> 的成员。</td></tr><tr><td style="text-align:left">multiset IS A SET</td><td style="text-align:left"><em>multiset</em> 是否是一个集合（没有重复）。</td></tr><tr><td style="text-align:left">multiset IS NOT A SET</td><td style="text-align:left"><em>multiset</em> 是否不是一个集合（有重复）。</td></tr><tr><td style="text-align:left">multiset IS EMPTY</td><td style="text-align:left"><em>multiset</em> 是否包含零个元素。</td></tr><tr><td style="text-align:left">multiset IS NOT EMPTY</td><td style="text-align:left"><em>multiset</em> 是否包含一个或多个元素。</td></tr><tr><td style="text-align:left">multiset SUBMULTISET OF multiset2</td><td style="text-align:left"><em>multiset</em> 是否是 <em>multiset2</em> 的子多集。</td></tr><tr><td style="text-align:left">multiset NOT SUBMULTISET OF multiset2</td><td style="text-align:left"><em>multiset</em> 是否不是 <em>multiset2</em> 的子多集。</td></tr><tr><td style="text-align:left">multiset MULTISET UNION [ ALL | DISTINCT ] multiset2</td><td style="text-align:left">返回并集 <em>multiset</em> 和 <em>multiset2</em>，如果指定了 DISTINCT（ALL 为默认值），则消除重复项。</td></tr><tr><td style="text-align:left">multiset MULTISET INTERSECT [ ALL | DISTINCT ] multiset2</td><td style="text-align:left">返回 <em>multiset</em> 和 <em>multiset2</em> 的交集，如果指定了 DISTINCT（ALL 是默认值），则消除重复项。</td></tr><tr><td style="text-align:left">multiset MULTISET EXCEPT [ ALL | DISTINCT ] multiset2</td><td style="text-align:left">返回 <em>multiset</em> 和 <em>multiset2</em> 的差异，如果指定了 DISTINCT（ALL 是默认值），则消除重复项。</td></tr></tbody></table><p>另请参阅：UNNEST 关系运算符将集合转换为关系。</p><h3 id="时间段谓词"><a class="markdownIt-Anchor" href="#时间段谓词"></a> 时间段谓词</h3><table><thead><tr><th>运算符语法</th><th>描述</th></tr></thead><tbody><tr><td>period1 CONTAINS datetime</td><td>period1 包含 datetime</td></tr><tr><td>period1 CONTAINS period2</td><td>period1 包含 period2</td></tr><tr><td>period1 OVERLAPS period2</td><td>period1 与 period2 重叠</td></tr><tr><td>period1 EQUALS period2</td><td>period1 等于 period2</td></tr><tr><td>period1 PRECEDES period2</td><td>period1 早于 period2</td></tr><tr><td>period1 IMMEDIATELY PRECEDES period2</td><td>period1 早于 period2 并没有间隔</td></tr><tr><td>period1 SUCCEEDS period2</td><td>period1 晚于 period2</td></tr><tr><td>period1 IMMEDIATELY SUCCEEDS period2</td><td>period1 晚于 period2 并没有间隔</td></tr></tbody></table><p>其中 <code>period1</code> 和 <code>period2</code> 是时间段表达式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">period</span>:</span><br><span class="line">      (datetime, datetime)</span><br><span class="line">  <span class="operator">|</span>   (datetime, <span class="type">interval</span>)</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">PERIOD</span> (datetime, datetime)</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">PERIOD</span> (datetime, <span class="type">interval</span>)</span><br></pre></td></tr></table></figure><h3 id="jdbc-函数转义"><a class="markdownIt-Anchor" href="#jdbc-函数转义"></a> JDBC 函数转义</h3><h4 id="数字"><a class="markdownIt-Anchor" href="#数字"></a> 数字</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">{fn ABS(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的绝对值</td></tr><tr><td style="text-align:left">{fn ACOS(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的反余弦</td></tr><tr><td style="text-align:left">{fn ASIN(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的反正弦值</td></tr><tr><td style="text-align:left">{fn ATAN(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的反正切</td></tr><tr><td style="text-align:left">{fn ATAN2(numeric, numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 坐标的反正切</td></tr><tr><td style="text-align:left">{fn CBRT(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的立方根</td></tr><tr><td style="text-align:left">{fn CEILING(numeric)}</td><td style="text-align:left">将 <em>numeric</em> 向上舍入，并返回大于或等于 <em>numeric</em> 的最小数字</td></tr><tr><td style="text-align:left">{fn COS(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的余弦</td></tr><tr><td style="text-align:left">{fn COT(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的余切</td></tr><tr><td style="text-align:left">{fn DEGREES(numeric)}</td><td style="text-align:left">将 <em>numeric</em> 从弧度转换为度</td></tr><tr><td style="text-align:left">{fn EXP(numeric)}</td><td style="text-align:left">返回 <em>e</em> 的 <em>numeric</em> 次方</td></tr><tr><td style="text-align:left">{fn FLOOR(numeric)}</td><td style="text-align:left">将 <em>numeric</em> 向下舍入，并返回小于或等于 <em>numeric</em> 的最大数字</td></tr><tr><td style="text-align:left">{fn LOG(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的自然对数（底数 <em>e</em>）</td></tr><tr><td style="text-align:left">{fn LOG10(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的以 10 为底的对数</td></tr><tr><td style="text-align:left">{fn MOD(numeric1, numeric2)}</td><td style="text-align:left">返回 <em>numeric1</em> 除以 <em>numeric2</em> 的余数（模数），仅当 <em>numeric1</em> 为负数时，结果才为负数</td></tr><tr><td style="text-align:left">{fn PI()}</td><td style="text-align:left">返回一个比任何其他值都更接近 <em>pi</em> 的值</td></tr><tr><td style="text-align:left">{fn POWER(numeric1, numeric2)}</td><td style="text-align:left">返回 <em>numeric1</em> 的 <em>numeric2</em> 次幂</td></tr><tr><td style="text-align:left">{fn RADIANS(numeric)}</td><td style="text-align:left">将 <em>numeric</em> 从度数转换为弧度</td></tr><tr><td style="text-align:left">{fn RAND(numeric)}</td><td style="text-align:left">使用 <em>numeric</em> 作为种子值返回随机双精度值</td></tr><tr><td style="text-align:left">{fn ROUND(numeric1, numeric2)}</td><td style="text-align:left">将 <em>numeric1</em> 四舍五入为 <em>numeric2</em> 位，保留小数点后一位</td></tr><tr><td style="text-align:left">{fn SIGN(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的符号</td></tr><tr><td style="text-align:left">{fn SIN(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的正弦值</td></tr><tr><td style="text-align:left">{fn SQRT(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的平方根</td></tr><tr><td style="text-align:left">{fn TAN(numeric)}</td><td style="text-align:left">返回 <em>numeric</em> 的正切</td></tr><tr><td style="text-align:left">{fn TRUNCATE(numeric1, numeric2)}</td><td style="text-align:left">将 <em>numeric1</em> 截断为 <em>numeric2</em> 位，保留小数点后一位</td></tr></tbody></table><h4 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">{fn ASCII(string)}</td><td style="text-align:left">返回 <em>string</em> 第一个字符的 ASCII 码；如果第一个字符是非 ASCII 字符，则返回其 Unicode 代码点；如果 <em>string</em> 为空，则返回 0</td></tr><tr><td style="text-align:left">{fn CHAR(integer)}</td><td style="text-align:left">返回 ASCII 码为 <em>integer</em> % 256 的字符，如果 <em>integer</em> &lt; 0，则返回 null</td></tr><tr><td style="text-align:left">{fn CONCAT(character, character)}</td><td style="text-align:left">返回字符串的连接</td></tr><tr><td style="text-align:left">{fn INSERT(string1, start, length, string2)}</td><td style="text-align:left">将 <em>string2</em> 插入到 <em>string1</em> 中的插槽中</td></tr><tr><td style="text-align:left">{fn LCASE(string)}</td><td style="text-align:left">返回一个字符串，其中 <em>string</em> 中的所有字母字符都已转换为小写</td></tr><tr><td style="text-align:left">{fn LENGTH(string)}</td><td style="text-align:left">返回字符串中的字符数</td></tr><tr><td style="text-align:left">{fn LOCATE(string1, string2 [, integer])}</td><td style="text-align:left">返回 <em>string1</em> 在 <em>string2</em> 中第一次出现的位置。除非指定了 <em>integer</em>，否则将从 <em>string2</em> 的开头进行搜索。</td></tr><tr><td style="text-align:left">{fn LEFT(string, length)}</td><td style="text-align:left">返回 <em>string</em> 最左边的 <em>length</em> 个字符</td></tr><tr><td style="text-align:left">{fn LTRIM(string)}</td><td style="text-align:left">返回删除了前导空格字符的<em>字符串</em></td></tr><tr><td style="text-align:left">{fn REPLACE(string, search, replacement)}</td><td style="text-align:left">返回一个字符串，其中 <em>string</em> 中出现的所有 <em>search</em> 均被 <em>replacement</em> 替换；如果 <em>replacement</em> 为空字符串，则删除出现的 <em>search</em></td></tr><tr><td style="text-align:left">{fn REVERSE(string)}</td><td style="text-align:left">返回字符顺序颠倒的<em>字符串</em></td></tr><tr><td style="text-align:left">{fn RIGHT(string, length)}</td><td style="text-align:left">返回 <em>string</em> 最右边的 <em>length</em> 个字符</td></tr><tr><td style="text-align:left">{fn RTRIM(string)}</td><td style="text-align:left">返回删除了尾随空格字符的 <em>string</em></td></tr><tr><td style="text-align:left">{fn SUBSTRING(string, offset, length)}</td><td style="text-align:left">返回从 <em>string</em> 开始，由 <em>length</em> 个字符组成的字符串，起始于 <em>offset</em> 位置</td></tr><tr><td style="text-align:left">{fn UCASE(string)}</td><td style="text-align:left">返回一个字符串，其中 <em>string</em> 中的所有字母字符都已转换为大写</td></tr></tbody></table><h4 id="日期时间"><a class="markdownIt-Anchor" href="#日期时间"></a> 日期/时间</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">{fn CURDATE()}</td><td style="text-align:left">相当于 <code>CURRENT_DATE</code></td></tr><tr><td style="text-align:left">{fn CURTIME()}</td><td style="text-align:left">相当于 <code>LOCALTIME</code></td></tr><tr><td style="text-align:left">{fn NOW()}</td><td style="text-align:left">相当于<code>LOCALTIMESTAMP</code></td></tr><tr><td style="text-align:left">{fn YEAR(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(YEAR FROM date)</code>。返回一个整数。</td></tr><tr><td style="text-align:left">{fn QUARTER(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(QUARTER FROM date)</code>。返回 1 到 4 之间的整数。</td></tr><tr><td style="text-align:left">{fn MONTH(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(MONTH FROM date)</code>。返回 1 到 12 之间的整数。</td></tr><tr><td style="text-align:left">{fn WEEK(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(WEEK FROM date)</code>。返回 1 到 53 之间的整数。</td></tr><tr><td style="text-align:left">{fn DAYOFYEAR(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(DOY FROM date)</code>。返回 1 到 366 之间的整数。</td></tr><tr><td style="text-align:left">{fn DAYOFMONTH(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(DAY FROM date)</code>。返回 1 到 31 之间的整数。</td></tr><tr><td style="text-align:left">{fn DAYOFWEEK(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(DOW FROM date)</code>。返回 1 到 7 之间的整数。</td></tr><tr><td style="text-align:left">{fn HOUR(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(HOUR FROM date)</code>。返回 0 到 23 之间的整数。</td></tr><tr><td style="text-align:left">{fn MINUTE(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(MINUTE FROM date)</code>。返回 0 到 59 之间的整数。</td></tr><tr><td style="text-align:left">{fn SECOND(date)}</td><td style="text-align:left">相当于 <code>EXTRACT(SECOND FROM date)</code>。返回 0 到 59 之间的整数。</td></tr><tr><td style="text-align:left">{fn TIMESTAMPADD(timeUnit, count, datetime)}</td><td style="text-align:left">将 <em>count</em> <em>timeUnit</em>s 的间隔添加到日期时间</td></tr><tr><td style="text-align:left">{fn TIMESTAMPDIFF(timeUnit, timestamp1, timestamp2)}</td><td style="text-align:left">从 <em>timestamp2</em> 中减去 <em>timestamp1</em> 并以 <em>timeUnit</em>s 形式返回结果</td></tr></tbody></table><h4 id="系统"><a class="markdownIt-Anchor" href="#系统"></a> 系统</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">{fn DATABASE()}</td><td style="text-align:left">相当于 <code>CURRENT_CATALOG</code></td></tr><tr><td style="text-align:left">{fn IFNULL(value1, value2)}</td><td style="text-align:left">如果 value1 为空，则返回 value2</td></tr><tr><td style="text-align:left">{fn USER()}</td><td style="text-align:left">相当于 <code>CURRENT_USER</code></td></tr></tbody></table><h4 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">{fn CONVERT(value, type)}</td><td style="text-align:left">将 <em>值</em> 转换为 <em>类型</em></td></tr></tbody></table><h3 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aggregateCall:</span><br><span class="line">      agg <span class="string">&#x27;(&#x27;</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] <span class="keyword">value</span> [, <span class="keyword">value</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      [ <span class="keyword">WITHIN</span> <span class="keyword">DISTINCT</span> <span class="string">&#x27;(&#x27;</span> expression [, expression ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      [ <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderItem [, orderItem ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      [ <span class="keyword">FILTER</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">  <span class="operator">|</span>   agg <span class="string">&#x27;(&#x27;</span> <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;)&#x27;</span> [ <span class="keyword">FILTER</span> (<span class="keyword">WHERE</span> <span class="keyword">condition</span>) ]</span><br></pre></td></tr></table></figure><p>其中 <em>agg</em> 是下表中的运算符之一，或者是用户定义的聚合函数。</p><p>如果存在 <code>FILTER</code>，则聚合函数仅考虑<em>条件</em>计算结果为 TRUE 的行。</p><p>如果存在 <code>DISTINCT</code>，则重复的参数值在传递给聚合函数之前会被消除。</p><p>如果存在 <code>WITHIN DISTINCT</code>，则在传递给聚合函数之前，参数值在指定键的每个值内都会有所不同。</p><p>如果存在 <code>WITHIN GROUP</code>，则聚合函数会在聚合值之前根据 <code>WITHIN GROUP</code> 内的 <code>ORDER BY</code> 子句对输入行进行排序。<code>WITHIN GROUP</code> 仅允许用于假设集合函数（<code>RANK</code>、<code>DENSE_RANK</code>、<code>PERCENT_RANK</code> 和 <code>CUME_DIST</code>）、逆分布函数（<code>PERCENTILE_CONT</code> 和 <code>PERCENTILE_DISC</code>）和集合函数（<code>COLLECT</code> 和 <code>LISTAGG</code>）。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ANY_VALUE( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有输入值中的一个值；这在 SQL 标准中没有指定</td></tr><tr><td style="text-align:left">ARG_MAX(value, comp)</td><td style="text-align:left">返回组中 comp 的最大值</td></tr><tr><td style="text-align:left">ARG_MIN(value, comp)</td><td style="text-align:left">返回组中 comp 的最小值</td></tr><tr><td style="text-align:left">APPROX_COUNT_DISTINCT(value [, value ]*)</td><td style="text-align:left">返回 value 的不同值的近似数量；数据库可以使用近似值，但不需要</td></tr><tr><td style="text-align:left">AVG( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">返回所有输入值的平均值（算术平均值）</td></tr><tr><td style="text-align:left">BIT_AND( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有非空输入值的按位与，如果没有则返回空；支持整数和二进制类型</td></tr><tr><td style="text-align:left">BIT_OR( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有非空输入值的按位或，如果没有则返回空；支持整数和二进制类型</td></tr><tr><td style="text-align:left">BIT_XOR( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有非空输入值的按位异或，若无则返回空；支持整数和二进制类型</td></tr><tr><td style="text-align:left">COLLECT( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回值的多集</td></tr><tr><td style="text-align:left">COUNT(*)</td><td style="text-align:left">返回输入行的数量</td></tr><tr><td style="text-align:left">COUNT( [ ALL | DISTINCT ] value [, value ]*)</td><td style="text-align:left">返回值不为空的输入行数（如果值为复合值，则完全不为空）</td></tr><tr><td style="text-align:left">COVAR_POP(numeric1, numeric2)</td><td style="text-align:left">返回所有输入值对 (numeric1, numeric2) 的总体协方差</td></tr><tr><td style="text-align:left">COVAR_SAMP(numeric1, numeric2)</td><td style="text-align:left">返回所有输入值对 (numeric1, numeric2) 的样本协方差</td></tr><tr><td style="text-align:left">EVERY(condition)</td><td style="text-align:left">如果条件的所有值都为 TRUE，则返回 TRUE</td></tr><tr><td style="text-align:left">FUSION(multiset)</td><td style="text-align:left">返回所有输入值的多重集的多重集并集</td></tr><tr><td style="text-align:left">INTERSECTION(multiset)</td><td style="text-align:left">返回所有输入值的多重集的多重集交集</td></tr><tr><td style="text-align:left">LISTAGG( [ ALL | DISTINCT ] value [, separator])</td><td style="text-align:left">返回连接成字符串的值，以分隔符分隔（默认为‘，’）</td></tr><tr><td style="text-align:left">MAX( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有输入值中的最大值</td></tr><tr><td style="text-align:left">MIN( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有输入值中的最小值</td></tr><tr><td style="text-align:left">MODE(value)</td><td style="text-align:left">返回所有输入值中出现频率最高的值</td></tr><tr><td style="text-align:left">REGR_COUNT(numeric1, numeric2)</td><td style="text-align:left">返回依赖表达式和独立表达式均不为空的行数</td></tr><tr><td style="text-align:left">REGR_SXX(numeric1, numeric2)</td><td style="text-align:left">返回线性回归模型中因变量表达式的平方和</td></tr><tr><td style="text-align:left">REGR_SYY(numeric1, numeric2)</td><td style="text-align:left">返回线性回归模型中独立表达式的平方和</td></tr><tr><td style="text-align:left">SOME(condition)</td><td style="text-align:left">如果条件中的一个或多个值为 TRUE，则返回 TRUE</td></tr><tr><td style="text-align:left">STDDEV( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">STDDEV_SAMP 的同义词</td></tr><tr><td style="text-align:left">STDDEV_POP( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">返回所有输入值的总体标准差</td></tr><tr><td style="text-align:left">STDDEV_SAMP( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">返回所有输入值的数字样本标准差</td></tr><tr><td style="text-align:left">SUM( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">返回所有输入值的数字总和</td></tr><tr><td style="text-align:left">VAR_POP( [ ALL | DISTINCT ] value)</td><td style="text-align:left">返回所有输入值的总体方差（总体标准差的平方）</td></tr><tr><td style="text-align:left">VAR_SAMP( [ ALL | DISTINCT ] numeric)</td><td style="text-align:left">返回所有输入值的样本方差（样本标准差的平方）</td></tr></tbody></table><p>未实现的：</p><ul><li>REGR_AVGX(numeric1, numeric2)</li><li>REGR_AVGY(numeric1, numeric2)</li><li>REGR_INTERCEPT(numeric1, numeric2)</li><li>REGR_R2(numeric1, numeric2)</li><li>REGR_SLOPE(numeric1, numeric2)</li><li>REGR_SXY(numeric1, numeric2)</li></ul><h4 id="有序集聚合函数"><a class="markdownIt-Anchor" href="#有序集聚合函数"></a> 有序集聚合函数</h4><p>语法与 <em>aggregateCall</em> 相同，但需要 <code>WITHIN GROUP</code>。</p><p>例如下面的：</p><ul><li><em>分数</em> 是 0 到 1 之间的数字文字（包括 0 和 1），代表百分比；</li></ul><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">PERCENTILE_CONT(fraction) WITHIN GROUP (ORDER BY orderItem)</td><td style="text-align:left">根据列值的连续分布返回百分位数，如果需要，则在相邻的输入项之间进行插值</td></tr><tr><td style="text-align:left">PERCENTILE_DISC(fraction) WITHIN GROUP (ORDER BY orderItem [, orderItem ]*)</td><td style="text-align:left">根据列值的离散分布返回百分位数，返回排序中位置等于或超过指定分数的第一个输入值</td></tr></tbody></table><h3 id="窗口函数"><a class="markdownIt-Anchor" href="#窗口函数"></a> 窗口函数</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">windowedAggregateCall:</span><br><span class="line">      agg <span class="string">&#x27;(&#x27;</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> ] <span class="keyword">value</span> [, <span class="keyword">value</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      [ <span class="keyword">RESPECT NULLS</span> <span class="operator">|</span> <span class="keyword">IGNORE NULLS</span> ]</span><br><span class="line">      [ <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderItem [, orderItem ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      [ <span class="keyword">FILTER</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      <span class="keyword">OVER</span> <span class="keyword">window</span></span><br><span class="line">  <span class="operator">|</span>   agg <span class="string">&#x27;(&#x27;</span> <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      [ <span class="keyword">FILTER</span>  <span class="string">&#x27;(&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      <span class="keyword">OVER</span> <span class="keyword">window</span></span><br></pre></td></tr></table></figure><p>其中 agg 是下表中的运算符之一，或者是用户定义的聚合函数。</p><p><code>DISTINCT</code>、<code>FILTER</code> 和 <code>WITHIN GROUP</code> 与聚合函数的描述一致。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">COUNT(value [, value ]*) OVER window</td><td style="text-align:left">返回 <em>window</em> 中 <em>value</em> 不为空的行数（如果 <em>value</em> 是复合的，则完全不为空）</td></tr><tr><td style="text-align:left">COUNT(*) OVER window</td><td style="text-align:left">返回 <em>window</em> 中的行数</td></tr><tr><td style="text-align:left">AVG(numeric) OVER window</td><td style="text-align:left">返回 <em>window</em> 中所有值的 <em>numeric</em> 的平均值（算术平均值）</td></tr><tr><td style="text-align:left">SUM(numeric) OVER window</td><td style="text-align:left">返回 <em>window</em> 中所有值的 <em>numeric</em> 之和</td></tr><tr><td style="text-align:left">MAX(value) OVER window</td><td style="text-align:left">返回 <em>window</em> 中所有值中 <em>value</em> 的最大值</td></tr><tr><td style="text-align:left">MIN(value) OVER window</td><td style="text-align:left">返回 <em>window</em> 中所有值中 <em>value</em> 的最小值</td></tr><tr><td style="text-align:left">RANK() OVER window</td><td style="text-align:left">返回当前行的排名（有间隙）；与其第一个对等行的 ROW_NUMBER 相同</td></tr><tr><td style="text-align:left">DENSE_RANK() OVER window</td><td style="text-align:left">返回当前行的排名，无间隙；该函数计算同组</td></tr><tr><td style="text-align:left">ROW_NUMBER() OVER window</td><td style="text-align:left">返回分区内当前行的编号，从 1 开始计数</td></tr><tr><td style="text-align:left">FIRST_VALUE(value) OVER window</td><td style="text-align:left">返回在窗口框架第一行计算的值</td></tr><tr><td style="text-align:left">LAST_VALUE(value) OVER window</td><td style="text-align:left">返回在窗口框架最后一行计算的值</td></tr><tr><td style="text-align:left">LEAD(value, offset, default) OVER window</td><td style="text-align:left">返回在分区内当前行之后 <em>offset</em> 行处求值的 <em>value</em>；如果没有这样的行，则返回 <em>default</em>。<em>offset</em> 和 <em>default</em> 都是针对当前行求值的。如果省略，<em>offset</em> 默认为 1，<em>default</em> 默认为 NULL</td></tr><tr><td style="text-align:left">LAG(value, offset, default) OVER window</td><td style="text-align:left">返回在分区内当前行之前 <em>offset</em> 行处求值的 <em>value</em>；如果没有这样的行，则返回 <em>default</em>。<em>offset</em> 和 <em>default</em> 都是针对当前行求值的。如果省略，<em>offset</em> 默认为 1，<em>default</em> 默认为 NULL</td></tr><tr><td style="text-align:left">NTH_VALUE(value, nth) OVER window</td><td style="text-align:left">返回在窗口框架的第 <em>n</em> 行计算的值</td></tr><tr><td style="text-align:left">NTILE(value) OVER window</td><td style="text-align:left">返回从 1 到 <em>value</em> 的整数，尽可能均匀地划分分区</td></tr></tbody></table><p>注意：</p><ul><li>你可以为 FIRST_VALUE、LAST_VALUE、NTH_VALUE、LEAD 和 LAG 函数指定空处理（IGNORE NULLS、RESPECT NULLS）。语法由解析器处理，但只有 RESPECT NULLS 在运行时实现。</li></ul><p>未实现：</p><ul><li>COUNT(DISTINCT value [, value ]*) OVER window</li><li>APPROX_COUNT_DISTINCT(value [, value ]*) OVER window</li><li>PERCENT_RANK(value) OVER window</li><li>CUME_DIST(value) OVER window</li></ul><h3 id="分组函数"><a class="markdownIt-Anchor" href="#分组函数"></a> 分组函数</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GROUPING(expression [, expression ]*)</td><td style="text-align:left">返回给定分组表达式的位向量</td></tr><tr><td style="text-align:left">GROUP_ID()</td><td style="text-align:left">返回唯一标识分组键组合的整数</td></tr><tr><td style="text-align:left">GROUPING_ID(expression [, expression ]*)</td><td style="text-align:left"><code>GROUPING</code> 的同义词</td></tr></tbody></table><h3 id="描述符"><a class="markdownIt-Anchor" href="#描述符"></a> 描述符</h3><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">DESCRIPTOR(name [, name ]*)</td><td style="text-align:left">DESCRIPTOR 作为函数中的参数出现，表示名称列表。名称的解释留给函数。</td></tr></tbody></table><h3 id="表函数"><a class="markdownIt-Anchor" href="#表函数"></a> 表函数</h3><p>表函数出现在 <code>FROM</code> 子句中。</p><p>表函数可能具有通用表参数（即，创建表函数时未声明任何行类型），并且结果的行类型可能取决于输入表的行类型。此外，输入表按三个特征分类。第一个特征是语义。输入表具有行语义或集合语义，如下所示：</p><ul><li>行语义意味着表函数的结果依赖于逐行；</li><li>集合语义意味着函数的结果取决于数据的分区方式。</li></ul><p>第二个特性仅适用于具有集合语义的输入表，即即使输入表为空，表函数是否可以生成结果行。</p><ul><li>如果表函数可以在空输入时生成结果行，则该表被称为<code>空时保留</code>；</li><li>另一种选择是<code>空时修剪</code>，这意味着如果输入表为空，结果将被修剪掉。</li></ul><p>第三个特征是输入表是否支持传递列。传递列是一种机制，允许表函数将输入行的每一列复制到输出行的列中。</p><p>具有集合语义的输入表可以按一列或多列进行分区。具有集合语义的输入表可以按一列或多列进行排序。</p><p>注意：</p><ul><li>具有行语义的输入表可能未被分区或排序；</li><li>多态表函数可能有多个输入表。但是，最多只有一个输入表可以具有行语义。</li></ul><h4 id="tumble"><a class="markdownIt-Anchor" href="#tumble"></a> TUMBLE</h4><p>在流式查询中，TUMBLE 根据时间戳列为关系的每一行分配一个窗口。分配的窗口由其开始和结束指定。所有分配的窗口都具有相同的长度，这就是为什么翻转有时被称为“固定窗口”。TUMBLE 表函数的第一个参数是通用表参数。输入表具有行语义并支持传递列。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TUMBLE(data, DESCRIPTOR(timecol), size [, offset ])</td><td style="text-align:left">表示 timecol 大小间隔的滚动窗口，可选择在偏移处对齐。</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  TUMBLE(</span><br><span class="line">    <span class="keyword">TABLE</span> orders,</span><br><span class="line">    DESCRIPTOR(rowtime),</span><br><span class="line">    <span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MINUTE</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- or with the named params</span></span><br><span class="line"><span class="comment">-- <span class="doctag">note:</span> the DATA param must be the first</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  TUMBLE(</span><br><span class="line">    DATA <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">TABLE</span> orders,</span><br><span class="line">    TIMECOL <span class="operator">=</span><span class="operator">&gt;</span> DESCRIPTOR(rowtime),</span><br><span class="line">    SIZE <span class="operator">=</span><span class="operator">&gt;</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MINUTE</span>));</span><br></pre></td></tr></table></figure><p>将一分钟范围的滚动窗口应用于订单表中的行。rowtime 是订单表的水印列，用于告知数据是否完整。</p><h4 id="hop"><a class="markdownIt-Anchor" href="#hop"></a> HOP</h4><p>在流式查询中，HOP 会分配覆盖大小间隔内的行的窗口，并根据时间戳列移动每个滑动窗口。分配的窗口可能会重叠，因此有时跳跃被称为<code>滑动窗口</code>。HOP 表函数的第一个参数是通用表参数。输入表具有行语义并支持传递列。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">HOP(data, DESCRIPTOR(timecol), slide, size [, offset ])</td><td style="text-align:left">表示 timecol 的跳跃窗口，覆盖 size 间隔内的行，移动每个幻灯片并可选择在偏移处对齐。</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  HOP(</span><br><span class="line">    <span class="keyword">TABLE</span> orders,</span><br><span class="line">    DESCRIPTOR(rowtime),</span><br><span class="line">    <span class="type">INTERVAL</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">MINUTE</span>,</span><br><span class="line">    <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- or with the named params</span></span><br><span class="line"><span class="comment">-- <span class="doctag">note:</span> the DATA param must be the first</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  HOP(</span><br><span class="line">    DATA <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">TABLE</span> orders,</span><br><span class="line">    TIMECOL <span class="operator">=</span><span class="operator">&gt;</span> DESCRIPTOR(rowtime),</span><br><span class="line">    SLIDE <span class="operator">=</span><span class="operator">&gt;</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">MINUTE</span>,</span><br><span class="line">    SIZE <span class="operator">=</span><span class="operator">&gt;</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>));</span><br></pre></td></tr></table></figure><p>对订单表的行应用 5 分钟间隔大小的跳跃，每 2 分钟移动一次。rowtime 是订单表的水印列，用于指示数据的完整性。</p><h4 id="session"><a class="markdownIt-Anchor" href="#session"></a> SESSION</h4><p>在流式查询中，SESSION 根据日期时间分配覆盖行的窗口。在会话窗口内，行之间的距离小于间隔。会话窗口按键应用。SESSION 表函数的第一个参数是通用表参数。输入表具有设置语义并支持传递列。此外，如果输入表为空，SESSION 表函数将不会生成结果行。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">session(data, DESCRIPTOR(timecol), DESCRIPTOR(key), size)</td><td style="text-align:left">表示 timecol 大小为 interval 的会话窗口。会话窗口按键应用。</td></tr></tbody></table><p>下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  SESSION(</span><br><span class="line">    <span class="keyword">TABLE</span> orders <span class="keyword">PARTITION</span> <span class="keyword">BY</span> product,</span><br><span class="line">    DESCRIPTOR(rowtime),</span><br><span class="line">    <span class="type">INTERVAL</span> <span class="string">&#x27;20&#x27;</span> <span class="keyword">MINUTE</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- or with the named params</span></span><br><span class="line"><span class="comment">-- <span class="doctag">note:</span> the DATA param must be the first</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">  SESSION(</span><br><span class="line">    DATA <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">TABLE</span> orders <span class="keyword">PARTITION</span> <span class="keyword">BY</span> product,</span><br><span class="line">    TIMECOL <span class="operator">=</span><span class="operator">&gt;</span> DESCRIPTOR(rowtime),</span><br><span class="line">    SIZE <span class="operator">=</span><span class="operator">&gt;</span> <span class="type">INTERVAL</span> <span class="string">&#x27;20&#x27;</span> <span class="keyword">MINUTE</span>));</span><br></pre></td></tr></table></figure><p>对订单表中的行应用具有 20 分钟非活动间隔的会话。rowtime 是订单表中带水印的列，用于指示数据的完整性。会话按产品应用。</p><p><strong>注意</strong>：Tumble、Hop 和 Session 窗口表函数将原始表中的每一行分配给一个窗口。输出表具有与原始表相同的所有列，以及两个附加列 window_start 和 window_end，分别表示窗口间隔的开始和结束。</p><h3 id="分组窗口函数"><a class="markdownIt-Anchor" href="#分组窗口函数"></a> 分组窗口函数</h3><p><strong>警告</strong>：分组窗口函数已被弃用。</p><p>分组窗口函数出现在 GROUP BY 子句中，并定义一个表示包含多行的窗口的键值。</p><p>在某些窗口函数中，一行可能属于多个窗口。例如，如果使用 <code>HOP(t, INTERVAL '2' HOUR, INTERVAL '1' HOUR)</code> 对查询进行分组，则带有时间戳 <code>10:15:00</code> 的行将同时出现在 <code>10:00 - 11:00</code> 和 <code>11:00 - 12:00</code> 总计中。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">HOP(datetime, slide, size [, time ])</td><td style="text-align:left">表示日期时间的跳跃窗口，覆盖大小间隔内的行，移动每张幻灯片，并可选择在时间上对齐</td></tr><tr><td style="text-align:left">SESSION(datetime, interval [, time ])</td><td style="text-align:left">表示日期时间间隔的会话窗口，可选择在时间上对齐</td></tr><tr><td style="text-align:left">TUMBLE(datetime, interval [, time ])</td><td style="text-align:left">表示日期时间间隔的滚动窗口，可选择在时间上对齐</td></tr></tbody></table><h3 id="分组辅助函数"><a class="markdownIt-Anchor" href="#分组辅助函数"></a> 分组辅助函数</h3><p>分组辅助函数允许您访问由分组窗口函数定义的窗口的属性。</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">HOP_END(expression, slide, size [, time ])</td><td style="text-align:left">返回由 <code>HOP</code> 函数调用定义的窗口末尾的 <em>expression</em> 的值</td></tr><tr><td style="text-align:left">HOP_START(expression, slide, size [, time ])</td><td style="text-align:left">返回由 <code>HOP</code> 函数调用定义的窗口开头的 <em>expression</em> 的值</td></tr><tr><td style="text-align:left">SESSION_END(expression, interval [, time])</td><td style="text-align:left">返回由 <code>SESSION</code> 函数调用定义的窗口末尾的 <em>expression</em> 的值</td></tr><tr><td style="text-align:left">SESSION_START(expression, interval [, time])</td><td style="text-align:left">返回由 <code>SESSION</code> 函数调用定义的窗口开头的 <em>expression</em> 的值</td></tr><tr><td style="text-align:left">TUMBLE_END(expression, interval [, time ])</td><td style="text-align:left">返回由 <code>TUMBLE</code> 函数调用定义的窗口末尾的 <em>expression</em> 的值</td></tr><tr><td style="text-align:left">TUMBLE_START(expression, interval [, time ])</td><td style="text-align:left">返回由 <code>TUMBLE</code> 函数调用定义的窗口开头的 <em>expression</em> 的值</td></tr></tbody></table><h3 id="空间函数"><a class="markdownIt-Anchor" href="#空间函数"></a> 空间函数</h3><p>在以下内容中：</p><ul><li><em>geom</em> 是一个 <code>GEOMETRY</code>；</li><li><em>geomCollection</em> 是一个 <code>GEOMETRYCOLLECTION</code>；</li><li><em>point</em> 是一个 <code>POINT</code>；</li><li><em>lineString</em> 是一个 <code>LINESTRING</code>；</li><li><em>iMatrix</em> 是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DE-9IM">DE-9IM 交叉矩阵</a>；</li><li><em>distance</em>、<em>tolerance</em>、<em>segmentLengthFraction</em>、<em>offsetDistance</em> 都是 double 类型；</li><li><em>dimension</em>、<em>quadSegs</em>、<em>srid</em>、<em>zoom</em> 是整数类型；</li><li><em>layerType</em>是一个字符串；</li><li><em>gml</em> 是包含<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Geography_Markup_Language">地理标记语言 (GML)</a> 的字符串；</li><li><em>wkt</em> 是包含 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Well-known_text">众所周知的文本 (WKT)</a> 的字符串；</li><li><em>wkb</em> 是包含 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Well-known_binary">众所周知的二进制 (WKB)</a> 的二进制字符串。</li></ul><p>在 <code>C</code>（代表<code>兼容性</code>）列中，<code>o</code> 表示该函数实现了 SQL 的 OpenGIS 简单功能实现规范，版本 1.2.1；<code>p</code> 表示该函数是 OpenGIS 的 PostGIS 扩展；<code>h</code> 表示该函数是 H2GIS 扩展。</p><p>TODO</p><h4 id="几何转换函数2d"><a class="markdownIt-Anchor" href="#几何转换函数2d"></a> 几何转换函数（2D）</h4><table><thead><tr><th style="text-align:left">C （兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsBinary(geom)</td><td style="text-align:left"><code>ST_AsWKB</code> 的同义词</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsEWKB(geom)</td><td style="text-align:left"><code>ST_AsWKB</code> 的同义词</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsEWKT(geom)</td><td style="text-align:left">转换 GEOMETRY → EWKT</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsGeoJSON(geom)</td><td style="text-align:left">转换 GEOMETRY → GeoJSON</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsGML(geom)</td><td style="text-align:left">转换 GEOMETRY → GML</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AsText(geom)</td><td style="text-align:left"><code>ST_AsWKT</code> 的同义词</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_AsWKB(geom)</td><td style="text-align:left">转换 GEOMETRY → WKB</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_AsWKT(geom)</td><td style="text-align:left">转换 GEOMETRY → WKT</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Force2D(geom)</td><td style="text-align:left">3D GEOMETRY → 2D GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromEWKB(wkb [, srid ])</td><td style="text-align:left"><code>ST_GeomFromWKB</code> 的同义词</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromEWKT(wkb [, srid ])</td><td style="text-align:left">转换 WKT → GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromGeoJSON(json)</td><td style="text-align:left">转换 GeoJSON → GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromGML(wkb [, srid ])</td><td style="text-align:left">转换 GML → GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromText(wkt [, srid ])</td><td style="text-align:left"><code>ST_GeomFromWKT</code> 的同义词</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromWKB(wkb [, srid ])</td><td style="text-align:left">转换 WKB → GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeomFromWKT(wkb [, srid ])</td><td style="text-align:left">转换 WKT → GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_LineFromText(wkt [, srid ])</td><td style="text-align:left">转换 WKT → LINESTRING</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_LineFromWKB(wkt [, srid ])</td><td style="text-align:left">转换 WKT → LINESTRING</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_MLineFromText(wkt [, srid ])</td><td style="text-align:left">转换 WKT → MULTILINESTRING</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_MPointFromText(wkt [, srid ])</td><td style="text-align:left">转换 WKT → MULTIPOINT</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_MPolyFromText(wkt [, srid ]) Converts WKT → MULTIPOLYGON</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_PointFromText(wkt [, srid ])</td><td style="text-align:left">转换 WKT → POINT</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_PointFromWKB(wkt [, srid ])</td><td style="text-align:left">转换 WKB → POINT</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_PolyFromText(wkt [, srid ])</td><td style="text-align:left">转换 WKT → POLYGON</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_PolyFromWKB(wkt [, srid ])</td><td style="text-align:left">转换 WKB → POLYGON</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_ReducePrecision(geom, gridSize)</td><td style="text-align:left">将 <em>geom</em> 的精度降低至提供的 <em>gridSize</em></td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ToMultiPoint(geom)</td><td style="text-align:left">将 <em>geom</em> 的坐标（可能是 GEOMETRYCOLLECTION）转换为 MULTIPOINT</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ToMultiLine(geom)</td><td style="text-align:left">将 <em>geom</em> 的坐标（可能是 GEOMETRYCOLLECTION）转换为 MULTILINESTRING</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ToMultiSegments(geom)</td><td style="text-align:left">将 <em>geom</em>（可能是 GEOMETRYCOLLECTION）转换为存储在 MULTILINESTRING 中的一组不同段</td></tr></tbody></table><p>未实现：</p><ul><li>ST_GoogleMapLink(geom [, layerType [, zoom ]]) GEOMETRY → Google map link</li><li>ST_OSMMapLink(geom [, marker ]) GEOMETRY → OSM map link</li></ul><h4 id="几何转换函数3d"><a class="markdownIt-Anchor" href="#几何转换函数3d"></a> 几何转换函数（3D）</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Force3D(geom)</td><td style="text-align:left">2D GEOMETRY → 3D GEOMETRY</td></tr></tbody></table><h4 id="几何创建函数2d"><a class="markdownIt-Anchor" href="#几何创建函数2d"></a> 几何创建函数（2D）</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">h</td><td style="text-align:left">ST_BoundingCircle(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最小边界圆</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Expand(geom, distance)</td><td style="text-align:left">扩展 <em>geom</em> 的包络</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Expand(geom, deltaX, deltaY)</td><td style="text-align:left">扩展 <em>geom</em> 的包络</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MakeEllipse(point, width, height)</td><td style="text-align:left">构造一个椭圆</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_MakeEnvelope(xMin, yMin, xMax, yMax [, srid ])</td><td style="text-align:left">创建一个矩形 POLYGON</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MakeGrid(geom, deltaX, deltaY)</td><td style="text-align:left">根据 <em>geom</em> 计算多边形的规则网格</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MakeGridPoints(geom, deltaX, deltaY)</td><td style="text-align:left">根据 <em>geom</em> 计算规则的点网格</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_MakeLine(point1 [, point ]*)</td><td style="text-align:left">根据给定的 POINT（或 MULTIPOINT）创建线串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_MakePoint(x, y [, z ])</td><td style="text-align:left"><code>ST_Point</code> 的同义词</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_MakePolygon(lineString [, hole ]*)</td><td style="text-align:left">使用给定的孔（需要封闭的 LINESTRING）从 <em>lineString</em> 创建 POLYGON</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MinimumDiameter(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最小直径</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MinimumRectangle(geom)</td><td style="text-align:left">返回包围 <em>geom</em> 的最小矩形</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_OctogonalEnvelope(geom)</td><td style="text-align:left">返回 <em>geom</em> 的八边形包络</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Point(x, y [, z ])</td><td style="text-align:left">根据两个或三个坐标构造一个点</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_RingBuffer(geom, distance, bufferCount [, endCapStyle [, doDifference]])</code> 返回以 <em>geom</em> 为中心且缓冲区大小不断增加的 MULTIPOLYGON 缓冲区。</li></ul><h3 id="几何创建函数3d"><a class="markdownIt-Anchor" href="#几何创建函数3d"></a> 几何创建函数（3D）</h3><p>未实现：</p><ul><li><code>ST Extrude(from, height [, flag])</code> 挤出几何图形；</li><li><code>ST_Geometry Shadow(geom_point, height)</code> 计算 <em>geom</em> 的阴影足迹；</li><li><code>ST_GeometryShadow(geom, azimuth, elevation, height [, unify ])</code> 计算 <em>geom</em> 的阴影覆盖范围。</li></ul><h4 id="几何属性2d"><a class="markdownIt-Anchor" href="#几何属性2d"></a> 几何属性（2D）</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Boundary(geom [, srid ])</td><td style="text-align:left">返回 <em>geom</em> 的边界</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Centroid(geom)</td><td style="text-align:left">返回 <em>geom</em> 的质心</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_CoordDim(geom)</td><td style="text-align:left">返回 <em>geom</em> 坐标的维度</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Dimension(geom)</td><td style="text-align:left">返回 <em>geom</em> 的维度</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Distance(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom2</em> 之间的距离</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ExteriorRing(geom)</td><td style="text-align:left">返回 <em>geom</em> 的外环，如果 <em>geom</em> 不是多边形，则返回 null</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeometryType(geom)</td><td style="text-align:left">返回 <em>geom</em> 的类型</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_GeometryTypeCode(geom)</td><td style="text-align:left">返回 <em>geom</em> 的 OGC SFS 类型代码</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_EndPoint(lineString)</td><td style="text-align:left">返回 <em>geom</em> 的最后一个坐标</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Envelope(geom [, srid ])</td><td style="text-align:left">返回 <em>geom</em> 的包络（可能是 GEOMETRYCOLLECTION）作为 GEOMETRY</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Extent(geom)</td><td style="text-align:left">Returns the minimum bounding box of <em>geom</em> (which may be a GEOMETRYCOLLECTION)</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_GeometryN(geomCollection, n)</td><td style="text-align:left">返回 <em>geomCollection</em> 的第 <em>n</em> 个 GEOMETRY</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_InteriorRingN(geom)</td><td style="text-align:left">返回 <em>geom</em> 的第 n 个内环，如果 <em>geom</em> 不是多边形，则返回 null</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_IsClosed(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否为封闭的 LINESTRING 或 MULTILINESTRING</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_IsEmpty(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否为空</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_IsRectangle(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否为矩形</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_IsRing(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否为封闭的简单线串或 MULTILINESTRING</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_IsSimple(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否简单</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_IsValid(geom)</td><td style="text-align:left">返回 <em>geom</em> 是否有效</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_NPoints(geom)</td><td style="text-align:left">返回 <em>geom</em> 中的点数</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_NumGeometries(geom)</td><td style="text-align:left">返回 <em>geom</em> 中的几何图形数量（如果不是 GEOMETRYCOLLECTION，则返回 1）</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_NumInteriorRing(geom)</td><td style="text-align:left"><code>ST_NumInteriorRings</code> 的同义词</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_NumInteriorRings(geom)</td><td style="text-align:left">返回 <em>geom</em> 的内部环的数量</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_NumPoints(geom)</td><td style="text-align:left">返回 <em>geom</em> 中的点数</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_PointN(geom, n)</td><td style="text-align:left">返回 <em>geom</em> 的第 <em>n</em> 个点</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_PointOnSurface(geom)</td><td style="text-align:left">返回 <em>geom</em> 的内部或边界点</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_SRID(geom)</td><td style="text-align:left">返回 <em>geom</em> 的 SRID 值，如果没有则返回 0</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_StartPoint(geom)</td><td style="text-align:left">返回 <em>geom</em> 的第一个点</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_X(geom)</td><td style="text-align:left">返回 <em>geom</em> 第一个坐标的 x 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_XMax(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最大 x 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_XMin(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最小 x 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Y(geom)</td><td style="text-align:left">返回 <em>geom</em> 第一个坐标的 y 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_YMax(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最大 y 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_YMin(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最小 y 值</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_CompactnessRatio(polygon)</code> 返回 <em>polygon</em> 面积除以其周长等于其周长的圆的面积的平方根；</li><li><code>ST_Explode(query [, field Name])</code> 将查询的 <em>field Name</em> 列中的<code>GEOMETRY COLLECTIONs</code>分解为多个几何图形；</li><li><code>ST_IsValidDetail(geom [, selfTouchValid ])</code> 返回有效细节作为对象数组；</li><li><code>ST_IsValidReason(geom [, selfTouchValid ])</code> 返回文本说明 <em>geom</em> 是否有效，如果无效，则说明原因。</li></ul><h4 id="几何属性3d"><a class="markdownIt-Anchor" href="#几何属性3d"></a> 几何属性（3D）</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">ST_Is3D(s)</td><td style="text-align:left">返回 <em>geom</em> 是否至少有一个 z 坐标</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Z(geom)</td><td style="text-align:left">返回 <em>geom</em> 第一个坐标的 z 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_ZMax(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最大 z 值</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_ZMin(geom)</td><td style="text-align:left">返回 <em>geom</em> 的最小 z 值</td></tr></tbody></table><h3 id="几何谓词"><a class="markdownIt-Anchor" href="#几何谓词"></a> 几何谓词</h3><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Contains(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否包含 <em>geom2</em></td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_ContainsProperly(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否包含 <em>geom2</em> 但与其边界不相交</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_CoveredBy(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 中是否没有点位于 <em>geom2</em> 之外。</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_Covers(geom1, geom2)</td><td style="text-align:left">返回 <em>geom2</em> 中是否没有点位于 <em>geom1</em> 之外</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Crosses(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否与 <em>geom2</em> 相交</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Disjoint(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom2</em> 是否不相交</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_DWithin(geom1, geom2, distance)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom</em> 是否在彼此的 <em>距离</em> 范围内</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_EnvelopesIntersect(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 的包络线是否与 <em>geom2</em> 的包络线相交</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Equals(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否等于 <em>geom2</em></td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Intersects(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否与 <em>geom2</em> 相交</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Overlaps(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否与 <em>geom2</em> 重叠</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Relate(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom2</em> 的 DE-9IM 交集矩阵</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Relate(geom1, geom2, iMatrix)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom2</em> 是否通过给定的交集矩阵 <em>iMatrix</em> 相关</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Touches(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否接触 <em>geom2</em></td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Within(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 是否在 <em>geom2</em> 内</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_OrderingEquals(geom1, geom2)</code> 返回 <em>geom1</em> 是否等于 <em>geom2</em> 以及它们的坐标和组件几何图形以相同的顺序列出。</li></ul><h4 id="几何运算符2d"><a class="markdownIt-Anchor" href="#几何运算符2d"></a> 几何运算符（2D）</h4><p>以下函数组合了 2D 几何图形。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">ST_Buffer(geom, distance [, quadSegs, endCapStyle ])</td><td style="text-align:left">计算 <em>geom</em> 周围的缓冲区</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_Buffer(geom, distance [, bufferStyle ])</td><td style="text-align:left">计算 <em>geom</em> 周围的缓冲区</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_ConvexHull(geom)</td><td style="text-align:left">计算包含 <em>geom</em> 中所有点的最小凸多边形</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Difference(geom1, geom2)</td><td style="text-align:left">计算两个几何图形之间的差异</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_SymDifference(geom1, geom2)</td><td style="text-align:left">计算两个几何体之间的对称差异</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Intersection(geom1, geom2)</td><td style="text-align:left">计算 <em>geom1</em> 和 <em>geom2</em> 的交集</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_OffsetCurve(geom, distance, bufferStyle)</td><td style="text-align:left">计算 <em>linestring</em> 的偏移线</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Union(geom1, geom2)</td><td style="text-align:left">计算 <em>geom1</em> 和 <em>geom2</em> 的并集</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Union(geomCollection)</td><td style="text-align:left">计算 <em>geomCollection</em> 中几何图形的并集</td></tr></tbody></table><p>另请参考：<code>ST_Union</code> 聚合函数。</p><h4 id="仿射变换函数3d-和-2d"><a class="markdownIt-Anchor" href="#仿射变换函数3d-和-2d"></a> 仿射变换函数（3D 和 2D）</h4><p>以下函数可变换 2D 几何图形。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Rotate(geom, angle [, origin | x, y])</td><td style="text-align:left">将 <em>geom</em> 绕 <em>origin</em> （或点 (<em>x</em>, <em>y</em>)）逆时针旋转 <em>angle</em> （以弧度为单位）</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Scale(geom, xFactor, yFactor)</td><td style="text-align:left">通过将纵坐标乘以指定的比例因子来缩放 <em>geom</em></td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Translate(geom, x, y)</td><td style="text-align:left">将 <em>geom</em> 平移向量 (x, y)</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_Scale(geom, xFactor, yFactor [, zFactor ])</code> 通过将纵坐标乘以指定的比例因子来缩放 <em>geom</em>；</li><li><code>ST_Translate(geom, x, y, [, z])</code> 平移 <em>geom</em>。</li></ul><h4 id="几何编辑功能2d"><a class="markdownIt-Anchor" href="#几何编辑功能2d"></a> 几何编辑功能（2D）</h4><p>以下函数可修改 2D 几何图形。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">ST_AddPoint(linestring, point [, index])</td><td style="text-align:left">将 <em>point</em> 添加到给定 <em>index</em> 处的 <em>linestring</em>（如果未指定 <em>index</em>，则添加到末尾）</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Densify(geom, tolerance)</td><td style="text-align:left">通过沿线段插入额外的顶点来加密 <em>geom</em></td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_FlipCoordinates(geom)</td><td style="text-align:left">翻转 <em>geom</em> 的 X 和 Y 坐标</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Holes(geom)</td><td style="text-align:left">返回 <em>geom</em> 中的孔（可能是 GEOMETRYCOLLECTION）</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Normalize(geom)</td><td style="text-align:left">将 <em>geom</em> 转换为正常形式</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_RemoveRepeatedPoints(geom [, tolerance])</td><td style="text-align:left">从 <em>geom</em> 中删除重复的坐标</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_RemoveHoles(geom)</td><td style="text-align:left">移除 <em>geom</em> 的孔</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_RemovePoint(linestring, index)</td><td style="text-align:left">删除 <em>linestring</em> 中给定 <em>index</em> 处的 <em>point</em></td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Reverse(geom)</td><td style="text-align:left">反转 <em>geom</em> 坐标的顺序</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_CollectionExtract(geom, dimension)</code> 过滤 <em>geom</em>，返回具有给定 <code>dimension (1 = point, 2 = line-string, 3 = polygon)</code> 的成员的多重几何图形。</li></ul><h4 id="几何编辑功能3d"><a class="markdownIt-Anchor" href="#几何编辑功能3d"></a> 几何编辑功能（3D）</h4><p>以下函数可修改 3D 几何图形。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">H</td><td style="text-align:left">ST_AddZ(geom, zToAdd)</td><td style="text-align:left">将 zToAdd 添加到 geom 的 z 坐标</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_Interpolate3DLine(geom)</code> 返回带有 z 值插值的 <em>geom</em>，如果它不是线串或 MULTILINESTRING，则返回 null；</li><li><code>ST_MultiplyZ(geom, zFactor)</code> 返回 <em>geom</em> 的 z 值乘以 <em>zFactor</em>；</li><li><code>ST_Reverse3DLine(geom [, sortOrder ])</code> 可能会根据其第一个和最后一个坐标的 z 值反转 <em>geom</em>；</li><li><code>ST_UpdateZ(geom, newZ [, updateCondition ])</code> 更新 <em>geom</em> 的 z 值；</li><li><code>ST_ZUpdateLineExtremities(geom, startZ, endZ [, interpolate ])</code> 更新 <em>geom</em> 的起始和终止 z 值。</li></ul><h4 id="几何测量功能2d"><a class="markdownIt-Anchor" href="#几何测量功能2d"></a> 几何测量功能（2D）</h4><p>以下函数测量几何形状。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Area(geom)</td><td style="text-align:left">返回 <em>geom</em> 的面积（可能是 GEOMETRYCOLLECTION）</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ClosestCoordinate(point, geom)</td><td style="text-align:left">返回最接近 <em>point</em> 的 <em>geom</em> 坐标</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ClosestPoint(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 最接近 <em>geom2</em> 的点</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_FurthestCoordinate(geom, point)</td><td style="text-align:left">返回距离<em>点</em>最远的<em>几何</em>的坐标</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Length(geom)</td><td style="text-align:left">返回 <em>geom</em> 的长度</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_LocateAlong(geom, segmentLengthFraction, offsetDistance)</td><td style="text-align:left">返回一个 MULTIPOINT，其中包含位于 <em>geom</em> 线段 <em>segmentLengthFraction</em> 和 <em>offsetDistance</em> 处的点</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_LongestLine(geom1, geom2)</td><td style="text-align:left">返回 <em>geom1</em> 和 <em>geom2</em> 点之间的二维最长线串</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_MaxDistance(geom1, geom2)</td><td style="text-align:left">计算 <em>geom1</em> 和 <em>geom2</em> 之间的最大距离</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Perimeter(polygon)</td><td style="text-align:left">返回 <em>polygon</em> (可能是 MULTIPOLYGON) 的周长长度</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ProjectPoint(point, lineString)</td><td style="text-align:left">将 <em>point</em> 投影到 <em>lineString</em> 上（可能是 MULTILINESTRING）</td></tr></tbody></table><h4 id="几何测量功能3d"><a class="markdownIt-Anchor" href="#几何测量功能3d"></a> 几何测量功能（3D）</h4><p>未实现：</p><ul><li><code>ST_3DArea(geom)</code> 返回多边形的三维面积；</li><li><code>ST_3DLength(geom)</code> 返回线串的 3D 长度；</li><li><code>ST_3DPerimeter(geom)</code> 返回多边形或MULTIPOLYGON的三维周长；</li><li><code>ST_SunPosition(point [, timestamp ])</code> 计算 <em>point</em> 和 <em>timestamp</em> 处的太阳位置（现在默认）。</li></ul><h4 id="几何处理功能2d"><a class="markdownIt-Anchor" href="#几何处理功能2d"></a> 几何处理功能（2D）</h4><p>以下函数处理几何图形。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_LineMerge(geom)</td><td style="text-align:left">合并线性组件的集合以形成最大长度的线串</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_MakeValid(geom)</td><td style="text-align:left">将给定的无效几何图形转换为有效几何图形</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Polygonize(geom)</td><td style="text-align:left">从 <em>geom</em> 的边缘创建一个 MULTIPOLYGON</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_PrecisionReducer(geom, n)</td><td style="text-align:left">将 <em>geom</em> 的精度降低至 <em>n</em> 位小数</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Simplify(geom, distance)</td><td style="text-align:left">使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas-Peuker 算法</a> 和 <em>distance</em> 容差来简化 <em>geom</em></td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_SimplifyPreserveTopology(geom, distance)</td><td style="text-align:left">简化 <em>geom</em>，保留其拓扑结构</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Snap(geom1, geom2, tolerance)</td><td style="text-align:left">将 <em>geom1</em> 和 <em>geom2</em> 对齐在一起</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">ST_Split(geom, blade)</td><td style="text-align:left">通过 <em>blade</em> 分割 <em>geom</em></td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_LineIntersector(geom1, geom2)</code> 将 <em>geom1</em> （线串）与 <em>geom2</em> 分割；</li><li><code>ST_LineMerge(geom)</code> 合并线性组件的集合以形成最大长度的线串；</li><li><code>ST_MakeValid(geom [, retainGeomDim [, retainDuplicateCoord [, retainCoordDim]]])</code> 使 <em>geom</em> 有效；</li><li><code>ST_RingSideBuffer(geom, distance, bufferCount [, endCapStyle [, doDifference]])</code> 计算一侧的环形缓冲区；</li><li><code>ST_SideBuffer(geom, distance [, bufferStyle ])</code> 计算一侧的单个缓冲区。</li></ul><h4 id="几何投影函数"><a class="markdownIt-Anchor" href="#几何投影函数"></a> 几何投影函数</h4><p>由于 EPSG 数据集的<a target="_blank" rel="noopener" href="https://epsg.org/terms-of-use.html">使用条款</a>有限制，因此它与 Proj4J 分开发布。为了使用 Apache Calcite 中的投影函数，用户必须在其依赖项中包含 EPSG 数据集。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">o</td><td style="text-align:left">ST_SetSRID(geom, srid)</td><td style="text-align:left">返回具有新 SRID 的 <em>geom</em> 副本</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">ST_Transform(geom, srid)</td><td style="text-align:left">将 <em>geom</em> 从一个坐标参考系统 (CRS) 转换为 <em>srid</em> 指定的 CRS</td></tr></tbody></table><h4 id="三角函数"><a class="markdownIt-Anchor" href="#三角函数"></a> 三角函数</h4><p>未实现：</p><ul><li><code>ST_Azimuth(point1, point2)</code> 返回从 <em>point1</em> 到 <em>point2</em> 的线段的方位角。</li></ul><h4 id="地形函数"><a class="markdownIt-Anchor" href="#地形函数"></a> 地形函数</h4><p>未实现：</p><ul><li><code>ST_TriangleAspect(geom)</code> 返回三角形的纵横比；</li><li><code>ST_TriangleContouring(query [, z1, z2, z3 ][, varArgs ]*)</code> 将三角形按类别分割成更小的三角形；</li><li><code>ST_TriangleDirection(geom)</code> 计算三角形的最陡上升方向并将其以线串形式返回；</li><li><code>ST_TriangleSlope(geom)</code> 以百分比形式计算三角形的斜率；</li><li><code>ST_Voronoi(geom [, outDimension [, envelopePolygon ]])</code> 创建 Voronoi 图。</li></ul><h4 id="三角测量函数"><a class="markdownIt-Anchor" href="#三角测量函数"></a> 三角测量函数</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">h</td><td style="text-align:left">ST_ConstrainedDelaunay(geom [, flag])</td><td style="text-align:left">根据 <em>geom</em> 计算受约束的 Delaunay 三角剖分</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Delaunay(geom [, flag])</td><td style="text-align:left">根据 <em>geom</em> 中的点计算 Delaunay 三角剖分</td></tr></tbody></table><p>未实现：</p><ul><li><code>ST_Tessellate(polygon)</code> 使用自适应三角形对<em>多边形</em> (可能是 MULTIPOLYGON) 进行镶嵌。</li></ul><h4 id="几何聚合函数"><a class="markdownIt-Anchor" href="#几何聚合函数"></a> 几何聚合函数</h4><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Accum(geom)</td><td style="text-align:left">将 <em>geom</em> 累积到数组中</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Collect(geom)</td><td style="text-align:left">将 <em>geom</em> 收集到 GeometryCollection 中</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">ST_Union(geom)</td><td style="text-align:left">计算 <em>geom</em> 中几何的并集</td></tr></tbody></table><h3 id="json-函数"><a class="markdownIt-Anchor" href="#json-函数"></a> JSON 函数</h3><p>在以下内容中：</p><ul><li><em>jsonValue</em> 是包含 JSON 值的字符串；</li><li><em>path</em> 是包含 JSON 路径表达式的字符串；<em>path</em> 的开头应指定模式标志 <code>strict</code> 或 <code>lax</code>。</li></ul><h4 id="查询函数"><a class="markdownIt-Anchor" href="#查询函数"></a> 查询函数</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">JSON_EXISTS(jsonValue, path [ { TRUE | FALSE | UNKNOWN | ERROR } ON ERROR ] )</td><td style="text-align:left"><em>jsonValue</em> 是否满足使用 JSON 路径表达式 <em>path</em> 描述的搜索条件</td></tr><tr><td style="text-align:left">JSON_VALUE(jsonValue, path [ RETURNING type ] [ { ERROR | NULL | DEFAULT expr } ON EMPTY ] [ { ERROR | NULL | DEFAULT expr } ON ERROR ] )</td><td style="text-align:left">使用 JSON 路径表达式 <em>path</em> 从 <em>jsonValue</em> 中提取 SQL 标量</td></tr><tr><td style="text-align:left">JSON_QUERY(jsonValue, path [ { WITHOUT [ ARRAY ] | WITH [ CONDITIONAL | UNCONDITIONAL ] [ ARRAY ] } WRAPPER ] [ { ERROR | NULL | EMPTY ARRAY | EMPTY OBJECT } ON EMPTY ] [ { ERROR | NULL | EMPTY ARRAY | EMPTY OBJECT } ON ERROR ] )</td><td style="text-align:left">使用 <em>path</em> JSON 路径表达式从 <em>jsonValue</em> 中提取 JSON 对象或 JSON 数组</td></tr></tbody></table><p>注意：</p><ul><li><code>ON ERROR</code> 和 <code>ON EMPTY</code> 子句定义当抛出错误或即将返回空值时函数的回退行为；</li><li><code>ARRAY WRAPPER</code> 子句定义如何在 <code>JSON_QUERY</code> 函数中表示 JSON 数组结果。以下示例比较了包装器行为。</li></ul><p>示例数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[1,2]&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hi&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>比较：</p><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">$.A</th><th style="text-align:left">$.B</th><th style="text-align:left">$.C</th></tr></thead><tbody><tr><td style="text-align:left">JSON_VALUE</td><td style="text-align:left">[1, 2]</td><td style="text-align:left">error</td><td style="text-align:left">hi</td></tr><tr><td style="text-align:left">JSON QUERY WITHOUT ARRAY WRAPPER</td><td style="text-align:left">error</td><td style="text-align:left">[1, 2]</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">JSON QUERY WITH UNCONDITIONAL ARRAY WRAPPER</td><td style="text-align:left">[ “[1,2]” ]</td><td style="text-align:left">[ [1,2] ]</td><td style="text-align:left">[ “hi” ]</td></tr><tr><td style="text-align:left">JSON QUERY WITH CONDITIONAL ARRAY WRAPPER</td><td style="text-align:left">[ “[1,2]” ]</td><td style="text-align:left">[1,2]</td><td style="text-align:left">[ “hi” ]</td></tr></tbody></table><p>未实现：</p><ul><li>JSON_TABLE</li></ul><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">JSON_OBJECT( jsonKeyVal [, jsonKeyVal ]* [ nullBehavior ] )</td><td style="text-align:left">使用一系列键值对构造 JSON 对象</td></tr><tr><td style="text-align:left">JSON_OBJECTAGG( jsonKeyVal [ nullBehavior ] )</td><td style="text-align:left">使用键值对构建 JSON 对象的聚合函数</td></tr><tr><td style="text-align:left">JSON_ARRAY( [ jsonVal [, jsonVal ]* ] [ nullBehavior ] )</td><td style="text-align:left">使用一系列值构造 JSON 数组</td></tr><tr><td style="text-align:left">JSON_ARRAYAGG( jsonVal [ ORDER BY orderItem [, orderItem ]* ] [ nullBehavior ] )</td><td style="text-align:left">使用值构建 JSON 数组的聚合函数</td></tr></tbody></table><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonKeyVal<span class="punctuation">:</span></span><br><span class="line">      <span class="punctuation">[</span> KEY <span class="punctuation">]</span> name VALUE value <span class="punctuation">[</span> FORMAT JSON <span class="punctuation">]</span></span><br><span class="line">  |   name <span class="punctuation">:</span> value <span class="punctuation">[</span> FORMAT JSON <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">jsonVal<span class="punctuation">:</span></span><br><span class="line">      value <span class="punctuation">[</span> FORMAT JSON <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">nullBehavior<span class="punctuation">:</span></span><br><span class="line">      NULL ON NULL</span><br><span class="line">  |   ABSENT ON NULL</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>标志 <code>FORMAT JSON</code> 表示值被格式化为 JSON 字符串。当使用 <code>FORMAT JSON</code> 时，该值应该从 JSON 字符串解析为 SQL 结构化值；</li><li><code>ON NULL</code> 子句定义 JSON 输出如何表示空值。<code>JSON_OBJECT</code> 和 <code>JSON_OBJECTAGG</code> 的默认空行为是 <code>NULL ON NULL</code>，而对于 <code>JSON_ARRAY</code> 和 <code>JSON_ARRAYAGG</code>，则为 <code>ABSENT ON NULL</code>；</li><li>如果提供了 <code>ORDER BY</code> 子句，<code>JSON_ARRAYAGG</code> 会在执行聚合之前将输入行按指定顺序排序。</li></ul><h4 id="比较运算符-2"><a class="markdownIt-Anchor" href="#比较运算符-2"></a> 比较运算符</h4><table><thead><tr><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">jsonValue IS JSON [ VALUE ]</td><td style="text-align:left"><em>jsonValue</em> 是否为 JSON 值</td></tr><tr><td style="text-align:left">jsonValue IS NOT JSON [ VALUE ]</td><td style="text-align:left"><em>jsonValue</em> 是否不是 JSON 值</td></tr><tr><td style="text-align:left">jsonValue IS JSON SCALAR</td><td style="text-align:left"><em>jsonValue</em> 是否是 JSON 标量值</td></tr><tr><td style="text-align:left">jsonValue IS NOT JSON SCALAR</td><td style="text-align:left"><em>jsonValue</em> 是否不是 JSON 标量值</td></tr><tr><td style="text-align:left">jsonValue IS JSON OBJECT</td><td style="text-align:left"><em>jsonValue</em> 是否为 JSON 对象</td></tr><tr><td style="text-align:left">jsonValue IS NOT JSON OBJECT</td><td style="text-align:left"><em>jsonValue</em> 是否不是 JSON 对象</td></tr><tr><td style="text-align:left">jsonValue IS JSON ARRAY</td><td style="text-align:left"><em>jsonValue</em> 是否为 JSON 数组</td></tr><tr><td style="text-align:left">jsonValue IS NOT JSON ARRAY</td><td style="text-align:left"><em>jsonValue</em> 是否不是 JSON 数组</td></tr></tbody></table><h3 id="特定方言运算符"><a class="markdownIt-Anchor" href="#特定方言运算符"></a> 特定方言运算符</h3><p>以下运算符不在 SQL 标准中，并且未在 Calcite 的默认运算符表中启用。仅当您的会话启用了额外的运算符表时，它们才可用于查询。</p><p>要启用操作员表，请设置 <a href="/wiki/calcite/adapters.html#jdbc-%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0">fun</a> 连接字符串参数。</p><p>“C”（兼容性）列包含值：</p><ul><li>‘*’ 代表所有库，</li><li>‘b’ 代表 Google BigQuery（连接字符串中为 ‘fun=bigquery’），</li><li>‘c’ 代表 Apache Calcite（连接字符串中为 ‘fun=calcite’），</li><li>‘h’ 代表 Apache Hive（连接字符串中为 ‘fun=hive’），</li><li>‘m’ 代表 MySQL（连接字符串中为 ‘fun=mysql’），</li><li>‘q’ 代表 Microsoft SQL Server（连接字符串中为 ‘fun=mssql’），</li><li>‘o’ 代表 Oracle（连接字符串中为 ‘fun=oracle’），</li><li>‘p’ 代表 PostgreSQL（连接字符串中为 ‘fun=postgresql’），</li><li>‘s’ 代表 Apache Spark（连接字符串中为 ‘fun=spark’）。</li></ul><p>一个操作符名称可能对应多种SQL方言，但语义不同。</p><ul><li><p>BigQuery 的类型系统对类型和函数使用了容易混淆的不同名称：</p></li><li><p>BigQuery 的 <code>DATETIME</code> 类型表示本地日期时间，与 Calcite 的 <code>TIMESTAMP</code> 类型相对应；</p></li><li><p>BigQuery 的 <code>TIMESTAMP</code> 类型表示瞬间，与 Calcite 的 <code>TIMESTAMP WITH LOCAL TIME ZONE</code> 类型相对应；</p></li><li><p><em>timestampLtz</em> 参数（例如 <code>DATE(timestampLtz)</code> 中的参数）具有 Calcite 类型 <code>TIMESTAMP WITH LOCAL TIME ZONE</code>；</p></li><li><p><code>TIMESTAMP(string)</code> 函数旨在与 BigQuery 函数兼容，返回 Calcite <code>TIMESTAMP WITH LOCAL TIME ZONE</code>；</p></li><li><p>类似地，<code>DATETIME(string)</code> 返回 Calcite <code>TIMESTAMP</code>。</p></li></ul><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">expr :: type</td><td style="text-align:left">将 <em>expr</em> 转换为 <em>type</em></td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">expr1 &lt;=&gt; expr2</td><td style="text-align:left">两个值是否相等，将空值视为相同，类似于<code>IS NOT DISTINCT FROM</code></td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">ACOSH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的反双曲余弦值</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY([expr [, expr ]*])</td><td style="text-align:left">在 Apache Spark 中构造一个数组。该函数允许用户使用 <code>ARRAY()</code> 创建一个空数组</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_APPEND(array, element)</td><td style="text-align:left">将一个元素附加到数组末尾并返回结果。元素的类型应与数组元素的类型相似。如果数组为空，则函数将返回空值。如果元素为空，则将空元素添加到数组末尾</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_COMPACT(array)</td><td style="text-align:left">从<em>数组</em>中删除空值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">ARRAY_CONCAT(array [, array ]*)</td><td style="text-align:left">连接一个或多个数组。如果任何输入参数为“NULL”，则函数返回“NULL”</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_CONTAINS(array, element)</td><td style="text-align:left">如果 <em>数组</em> 包含 <em>元素</em>，则返回 true</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_DISTINCT(array)</td><td style="text-align:left">从保持元素排序的数组中删除重复的值</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_EXCEPT(array1, array2)</td><td style="text-align:left">返回 <em>array1</em> 中存在但不存在于 <em>array2</em> 中的元素数组，且无重复</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_INSERT(array, pos, element)</td><td style="text-align:left">将 <em>元素</em> 放入 <em>数组</em> 的索引 <em>pos</em> 中。数组索引从 1 开始，如果索引为负数，则从末尾开始。数组大小之上的索引将使用 <code>NULL</code> 元素附加到数组中，如果索引为负数，则将 <code>NULL</code> 元素添加到数组前面。</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_INTERSECT(array1, array2)</td><td style="text-align:left">返回 <em>array1</em> 和 <em>array2</em> 交集处的元素数组，不包含重复项</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_JOIN(array, delimiter [, nullText ])</td><td style="text-align:left"><code>ARRAY_TO_STRING</code> 的同义词</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">ARRAY_LENGTH(array)</td><td style="text-align:left"><code>CARDINALITY</code> 的同义词</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_MAX(array)</td><td style="text-align:left">返回数组中的最大值</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_MIN(array)</td><td style="text-align:left">返回数组中的最小值</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_POSITION(array, element)</td><td style="text-align:left">返回数组中第一个元素的（从 1 开始）索引</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_REMOVE(array, element)</td><td style="text-align:left">从<em>数组</em>中删除所有等于<em>元素</em>的元素</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_PREPEND(array, element)</td><td style="text-align:left">将一个元素附加到数组的开头并返回结果。元素的类型应与数组元素的类型相似。如果数组为空，则函数将返回空。如果元素为空，则将空元素添加到数组的开头</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_REPEAT(element, count)</td><td style="text-align:left">返回包含元素 count 次的数组。</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">ARRAY_REVERSE(array)</td><td style="text-align:left">反转<em>数组</em>的元素</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_SIZE(array)</td><td style="text-align:left"><code>CARDINALITY</code> 的同义词</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">ARRAY_TO_STRING(array, delimiter [, nullText ])</td><td style="text-align:left">将 <em>array</em> 中元素的连接作为 STRING 返回，并以 <em>delimiter</em> 作为分隔符。如果使用 <em>nullText</em> 参数，则该函数会将数组中的任何 <code>NULL</code> 值替换为 <em>nullText</em> 的值。如果未使用 <em>nullText</em> 参数，则该函数会省略 <code>NULL</code> 值及其前面的分隔符。如果任何参数为 <code>NULL</code>，则返回 <code>NULL</code></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAY_UNION(array1, array2)</td><td style="text-align:left">返回 <em>array1</em> 和 <em>array2</em> 的并集元素数组，不包含重复元素</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAYS_OVERLAP(array1, array2)</td><td style="text-align:left">如果 <em>array1 至少包含一个非空元素，并且该元素也存在于 *array2</em> 中，则返回 true。如果两个数组没有共同元素，且两个数组都非空，并且其中一个数组包含一个空元素，则返回 null，否则返回 false</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">ARRAYS_ZIP(array [, array ]*)</td><td style="text-align:left">返回合并的结构体<em>数组</em>，其中第 N 个结构体包含输入数组的所有第 N 个值</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">SORT_ARRAY(array [, ascendingOrder])</td><td style="text-align:left">根据数组元素的自然顺序，按升序或降序对 <em>数组</em> 进行排序。如果未指定 <em>ascendingOrder</em>，则默认顺序为升序。空元素将按升序放置在返回数组的开头，或按降序放置在返回数组的末尾</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">ASINH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的反双曲正弦值</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">ATANH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的反双曲正切值</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">BITAND_AGG(value)</td><td style="text-align:left">相当于 <code>BIT_AND(value)</code></td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">BITOR_AGG(value)</td><td style="text-align:left">相当于 <code>BIT_OR(value)</code></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">BIT_LENGTH(binary)</td><td style="text-align:left">返回<em>二进制</em>的位长度</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">BIT_LENGTH(string)</td><td style="text-align:left">返回 <em>string</em> 的位长度</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">BIT_GET(value, position)</td><td style="text-align:left">返回数字<em>值</em>指定<em>位置</em>的位（0 或 1）值。位置从右到左编号，从零开始。<em>位置</em>参数不能为负数</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">CEIL(value)</td><td style="text-align:left">与标准 <code>CEIL(value)</code> 类似，除非 <em>value</em> 是整数类型，否则返回类型为双精度</td></tr><tr><td style="text-align:left">m s</td><td style="text-align:left">CHAR(integer)</td><td style="text-align:left">返回 ASCII 码为 <em>integer</em> % 256 的字符，如果 <em>integer</em> &lt; 0，则返回 null</td></tr><tr><td style="text-align:left">b o p</td><td style="text-align:left">CHR(integer)</td><td style="text-align:left">返回 UTF-8 代码为 <em>整数</em> 的字符</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">CODE_POINTS_TO_BYTES(integers)</td><td style="text-align:left">将<em>整数</em>（0 到 255 之间的整数数组，含 0 和 255）转换为字节；如果任何元素超出范围，则会引发错误</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">CODE_POINTS_TO_STRING(integers)</td><td style="text-align:left">将 <em>整数</em>（0 到 0xD7FF 之间或 0xE000 到 0x10FFFF 之间的整数数组）转换为字符串；如果任何元素超出范围，则会引发错误</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">CONCAT(string, string)</td><td style="text-align:left">连接两个字符串，仅当两个字符串参数都为空时才返回空，否则将空视为空字符串</td></tr><tr><td style="text-align:left">b m</td><td style="text-align:left">CONCAT(string [, string ]*)</td><td style="text-align:left">连接一个或多个字符串，如果任何参数为空，则返回空</td></tr><tr><td style="text-align:left">p q</td><td style="text-align:left">CONCAT(string [, string ]*)</td><td style="text-align:left">连接一个或多个字符串，null 被视为空字符串</td></tr><tr><td style="text-align:left">m p</td><td style="text-align:left">CONCAT_WS(separator, str1 [, string ]*)</td><td style="text-align:left">连接一个或多个字符串，仅当分隔符为空时才返回空，否则将空参数视为空字符串</td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">CONCAT_WS(separator, str1, str2 [, string ]*)</td><td style="text-align:left">连接两个或多个字符串，需要至少 3 个参数（最多 254 个），将空参数视为空字符串</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">COMPRESS(string)</td><td style="text-align:left">使用 zlib 压缩来压缩字符串并将结果作为二进制字符串返回</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">CONTAINS_SUBSTR(expression, string [ , json_scope =&gt; json_scope_value ])</td><td style="text-align:left">返回 <em>string</em> 是否作为子字符串存在于 <em>expression</em> 中。可选的 <em>json_scope</em> 参数指定如果 <em>expression</em> 为 JSON 格式，则搜索的范围。如果 <em>expression</em> 中存在 NULL 且不匹配，则返回 NULL</td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">CONVERT(type, expression [ , style ])</td><td style="text-align:left">相当于 <code>CAST(expression AS type)</code>；忽略 <em>style</em> 操作数</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">CONVERT_TIMEZONE(tz1, tz2, datetime)</td><td style="text-align:left">将 <em>datetime</em> 的时区从 <em>tz1</em> 转换为 <em>tz2</em></td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">COSH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲余弦</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">COTH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲余切</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">CSC(numeric)</td><td style="text-align:left">以弧度返回 <em>numeric</em> 的余割</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">CSCH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲余割</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">CURRENT_DATETIME([ timeZone ])</td><td style="text-align:left">从 <em>timezone</em> 返回当前时间作为时间戳</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">DAYNAME(datetime)</td><td style="text-align:left">返回连接语言环境中 <em>datetime</em> 中的星期几名称；例如，对于 DATE ‘2020-02-10’ 和 TIMESTAMP ‘2020-02-10 10:10:10’，它均返回‘星期日’</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE(timestamp)</td><td style="text-align:left">从<em>时间戳</em>中提取日期</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE(timestampLtz)</td><td style="text-align:left">从 <em>timestampLtz</em>（一个瞬间；BigQuery 的 TIMESTAMP 类型）中提取 DATE，假设为 UTC</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE(timestampLtz, timeZone)</td><td style="text-align:left">从 <em>timeZone</em> 中的 <em>timestampLtz</em>（瞬间；BigQuery 的 TIMESTAMP 类型）中提取 DATE</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE(string)</td><td style="text-align:left">相当于 <code>CAST(string AS DATE)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE(year, month, day)</td><td style="text-align:left">返回 <em>year</em>、<em>month</em> 和 <em>day</em> 的 DATE 值（均为 INTEGER 类型）</td></tr><tr><td style="text-align:left">p q</td><td style="text-align:left">DATEADD(timeUnit, integer, datetime)</td><td style="text-align:left">相当于 <code>TIMESTAMPADD(timeUnit, integer, datetime)</code></td></tr><tr><td style="text-align:left">p q</td><td style="text-align:left">DATEDIFF(timeUnit, datetime, datetime2)</td><td style="text-align:left">相当于 <code>TIMESTAMPDIFF(timeUnit, datetime, datetime2)</code></td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">DATEPART(timeUnit, datetime)</td><td style="text-align:left">相当于 <code>EXTRACT(timeUnit FROM datetime)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME(date, time)</td><td style="text-align:left">将<em>日期</em>和<em>时间</em>转换为时间戳</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME(date)</td><td style="text-align:left">将<em>日期</em>转换为时间戳值（午夜）</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME(date, timeZone)</td><td style="text-align:left">将 <em>date</em> 转换为 TIMESTAMP 值（午夜），以 <em>timeZone</em> 为单位</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME(year, month, day, hour, minute, second)</td><td style="text-align:left">为<em>年</em>、<em>月</em>、<em>日</em>、<em>时</em>、<em>分</em>、<em>秒</em> 创建时间戳（所有类型均为 INTEGER）</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME_ADD(timestamp, interval)</td><td style="text-align:left">返回在 <em>timestamp</em> 之后 <em>interval</em> 发生的 TIMESTAMP 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME_DIFF(timestamp, timestamp2, timeUnit)</td><td style="text-align:left">返回 <em>timestamp</em> 和 <em>timestamp2</em> 之间的 <em>timeUnit</em> 的整数</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME_SUB(timestamp, interval)</td><td style="text-align:left">返回在 <em>timestamp</em> 之前 <em>interval</em> 发生的 TIMESTAMP</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATETIME_TRUNC(timestamp, timeUnit)</td><td style="text-align:left">将 <em>timestamp</em> 截断为 <em>timeUnit</em> 的粒度，四舍五入到单位的开头</td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">DATE_FROM_UNIX_DATE(integer)</td><td style="text-align:left">返回 1970-01-01 之后 <em>整数</em> 天的 DATE</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">DATE_PART(timeUnit, datetime)</td><td style="text-align:left">相当于 <code>EXTRACT(timeUnit FROM datetime)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE_ADD(date, interval)</td><td style="text-align:left">返回在 <em>date</em> 之后 <em>interval</em> 发生的 DATE 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE_DIFF(date, date2, timeUnit)</td><td style="text-align:left">返回 <em>date</em> 和 <em>date2</em> 之间的 <em>timeUnit</em> 的整数</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE_SUB(date, interval)</td><td style="text-align:left">返回在 <em>date</em> 之前 <em>interval</em> 发生的 DATE 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">DATE_TRUNC(date, timeUnit)</td><td style="text-align:left">将 <em>date</em> 截断为 <em>timeUnit</em> 的粒度，四舍五入到单位的开头</td></tr><tr><td style="text-align:left">o s</td><td style="text-align:left">DECODE(value, value1, result1 [, valueN, resultN ]* [, default ])</td><td style="text-align:left">将 <em>value</em> 与每个 <em>valueN</em> 值逐一进行比较；如果 <em>value</em> 等于 <em>valueN</em>，则返回相应的 <em>resultN</em>，否则返回 <em>default</em>，如果未指定 <em>default</em>，则返回 NULL</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">DIFFERENCE(string, string)</td><td style="text-align:left">返回两个字符串的相似度度量，即它们的 <code>SOUNDEX</code> 值具有相同的字符位置数：如果 <code>SOUNDEX</code> 值相同，则返回 4；如果 <code>SOUNDEX</code> 值完全不同，则返回 0</td></tr><tr><td style="text-align:left">f s</td><td style="text-align:left">ENDSWITH(string1, string2)</td><td style="text-align:left">返回 <em>string2</em> 是否是 <em>string1</em> 的后缀</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">ENDS_WITH(string1, string2)</td><td style="text-align:left">相当于 <code>ENDSWITH(string1, string2)</code></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">EXISTS(array, func)</td><td style="text-align:left">返回谓词 <em>func</em> 是否对 <em>array</em> 中的一个或多个元素成立</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">EXISTSNODE(xml, xpath, [, namespaces ])</td><td style="text-align:left">确定使用指定的 xpath 遍历 XML 文档是否会产生任何节点。如果在 XPath 表达式匹配的元素或元素的文档片段上应用 XPath 遍历后没有剩余节点，则返回 0。如果剩余任何节点，则返回 1。可选命名空间值，用于指定前缀的默认映射或命名空间映射，在评估 XPath 表达式时使用。</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">EXTRACT(xml, xpath, [, namespaces ])</td><td style="text-align:left">返回与 XPath 表达式匹配的元素的 XML 片段。可选的命名空间值，用于指定前缀的默认映射或命名空间映射，在评估 XPath 表达式时使用</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">EXTRACTVALUE(xml, xpathExpr))</td><td style="text-align:left">返回 XPath 表达式匹配的元素或元素的子元素的第一个文本节点的文本。</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">FACTORIAL(integer)</td><td style="text-align:left">返回<em>integer</em>的阶乘，<em>integer</em>的范围是[0, 20]。否则返回NULL</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">FIND_IN_SET(matchStr, textStr)</td><td style="text-align:left">返回逗号分隔的 <em>textStr</em> 中给定 <em>matchStr</em> 的索引（从 1 开始）。如果未找到给定的 <em>matchStr</em> 或 <em>matchStr</em> 包含逗号，则返回 0。例如，FIND_IN_SET(‘bc’, ‘a,bc,def’) 返回 2</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FLOOR(value)</td><td style="text-align:left">与标准 <code>FLOOR(value)</code> 类似，除非 <em>value</em> 是整数类型，否则返回类型为双精度</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FORMAT_DATE(string, date)</td><td style="text-align:left">根据指定的格式 <em>string</em> 格式化 <em>date</em></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FORMAT_DATETIME(string, timestamp)</td><td style="text-align:left">根据指定的格式 <em>string</em> 格式化 <em>timestamp</em></td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">FORMAT_NUMBER(value, decimalVal)</td><td style="text-align:left">将数字 <em>value</em> 格式化为 ‘#,###,###.##’，四舍五入到小数位 <em>decimalVal</em>。如果 <em>decimalVal</em> 为 0，则结果没有小数点或小数部分</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">FORMAT_NUMBER(value, format)</td><td style="text-align:left">将数字<em>值</em>格式化为 MySQL 的 FORMAT <em>格式</em>，如‘#,###,###.##0.00’</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FORMAT_TIME(string, time)</td><td style="text-align:left">根据指定的格式 <em>string</em> 格式化 <em>time</em></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FORMAT_TIMESTAMP(string timestamp)</td><td style="text-align:left">根据指定的格式 <em>string</em> 格式化 <em>timestamp</em></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">GETBIT(value, position)</td><td style="text-align:left">相当于 <code>BIT_GET(value, position)</code></td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">GREATEST(expr [, expr ]*)</td><td style="text-align:left">返回表达式中最大的一个</td></tr><tr><td style="text-align:left">b h s</td><td style="text-align:left">IF(condition, value1, value2)</td><td style="text-align:left">如果 <em>condition</em> 为 TRUE，则返回 <em>value1</em>，否则返回 <em>value2</em></td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">IFNULL(value1, value2)</td><td style="text-align:left">相当于 <code>NVL(value1, value2)</code></td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">string1 ILIKE string2 [ ESCAPE string3 ]</td><td style="text-align:left"><em>string1</em> 是否与模式 <em>string2</em> 匹配，忽略大小写（类似于 <code>LIKE</code>）</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">string1 NOT ILIKE string2 [ ESCAPE string3 ]</td><td style="text-align:left"><em>string1</em> 是否与模式 <em>string2</em> 不匹配，忽略大小写（类似于 <code>NOT LIKE</code>）</td></tr><tr><td style="text-align:left">b o</td><td style="text-align:left">INSTR(string, substring [, from [, occurrence ] ])</td><td style="text-align:left">返回 <em>string</em> 中 <em>substring</em> 的位置，从 <em>from</em> （默认 1）开始搜索，直到找到 <em>substring</em> 的第 n 次 <em>occurrence</em> （默认 1）</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">INSTR(string, substring)</td><td style="text-align:left">相当于 <code>POSITION(子字符串 IN 字符串)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">IS_INF(value)</td><td style="text-align:left">返回<em>值</em>是否无限</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">IS_NAN(value)</td><td style="text-align:left">返回 <em>value</em> 是否为 NaN</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_TYPE(jsonValue)</td><td style="text-align:left">返回一个字符串值，表示 <em>jsonValue</em> 的类型</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_DEPTH(jsonValue)</td><td style="text-align:left">返回一个整数值，表示 <em>jsonValue</em> 的深度</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_PRETTY(jsonValue)</td><td style="text-align:left">返回 <em>jsonValue</em> 的格式化打印</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_LENGTH(jsonValue [, path ])</td><td style="text-align:left">返回一个整数，表示 <em>jsonValue</em> 的长度</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_INSERT(jsonValue, path, val [, path, val ]*)</td><td style="text-align:left">返回一个 JSON 文档，插入 <em>jsonValue</em>、<em>path</em>、<em>val</em> 的数据。</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_KEYS(jsonValue [, path ])</td><td style="text-align:left">返回表示 JSON <em>jsonValue</em> 的键的字符串</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_REMOVE(jsonValue, path [, path ])</td><td style="text-align:left">使用一系列 <em>path</em> 表达式从 <em>jsonValue</em> 中删除数据并返回结果</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_REPLACE(jsonValue, path, val [, path, val ]*)</td><td style="text-align:left">返回一个 JSON 文档，替换 <em>jsonValue</em>、<em>path</em>、<em>val</em> 的数据。</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_SET(jsonValue, path, val [, path, val ]*)</td><td style="text-align:left">返回一个 JSON 文档，其中包含 <em>jsonValue</em>、<em>path</em>、<em>val</em> 的数据。</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">JSON_STORAGE_SIZE(jsonValue)</td><td style="text-align:left">返回用于存储 <em>jsonValue</em> 二进制表示的字节数</td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">LEAST(expr [, expr ]* )</td><td style="text-align:left">返回表达式中的最小值</td></tr><tr><td style="text-align:left">b m p s</td><td style="text-align:left">LEFT(string, length)</td><td style="text-align:left">返回<em>字符串</em>最左边的<em>长度</em>个字符</td></tr><tr><td style="text-align:left">f s</td><td style="text-align:left">LEN(string)</td><td style="text-align:left">相当于 <code>CHAR_LENGTH(string)</code></td></tr><tr><td style="text-align:left">b f s</td><td style="text-align:left">LENGTH(string)</td><td style="text-align:left">相当于 <code>CHAR_LENGTH(string)</code></td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">LEVENSHTEIN(string1, string2)</td><td style="text-align:left">返回 <em>string1</em> 和 <em>string2</em> 之间的编辑距离</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">LOG(numeric1 [, numeric2 ])</td><td style="text-align:left">返回以 <em>numeric1</em> 为底数 <em>numeric2</em> 的对数，如果 <em>numeric2</em> 不存在，则返回以 e 为底数</td></tr><tr><td style="text-align:left">m s</td><td style="text-align:left">LOG2(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的以 2 为底的对数</td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">LPAD(string, length [, pattern ])</td><td style="text-align:left">返回由 <em>string</em> 和 <em>length</em> 开头且带有 <em>pattern</em> 的字符串或字节值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TO_BASE32(string)</td><td style="text-align:left">将 <em>string</em> 转换为 base-32 编码形式并返回编码字符串</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FROM_BASE32(string)</td><td style="text-align:left">以字符串形式返回 base-32 <em>string</em> 的解码结果</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">TO_BASE64(string)</td><td style="text-align:left">将 <em>string</em> 转换为 base-64 编码形式并返回编码字符串</td></tr><tr><td style="text-align:left">b m</td><td style="text-align:left">FROM_BASE64(string)</td><td style="text-align:left">以字符串形式返回 base-64 <em>string</em> 的解码结果</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TO_HEX(binary)</td><td style="text-align:left">将 <em>binary</em> 转换为十六进制 varchar</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">FROM_HEX(varchar)</td><td style="text-align:left">将十六进制编码的 <em>varchar</em> 转换为字节</td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">LTRIM(string)</td><td style="text-align:left">返回从开头删除所有空格的 <em>string</em></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP()</td><td style="text-align:left">返回空映射</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP(key, value [, key, value]*)</td><td style="text-align:left">返回具有给定 <em>key</em>/<em>value</em> 对的映射</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_CONCAT(map [, map]*)</td><td style="text-align:left">连接一个或多个地图。如果任何输入参数为“NULL”，则函数返回“NULL”。请注意，calcite 使用的是 LAST_WIN 策略</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_CONTAINS_KEY(map, key)</td><td style="text-align:left">返回 <em>map</em> 是否包含 <em>key</em></td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_ENTRIES(map)</td><td style="text-align:left">以数组形式返回 <em>map</em> 的条目，条目的顺序未定义</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_KEYS(map)</td><td style="text-align:left">以数组形式返回 <em>map</em> 的键，条目的顺序未定义。</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_VALUES(map)</td><td style="text-align:left">将 <em>map</em> 的值作为数组返回，条目的顺序未定义</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_FROM_ARRAYS(array1, array2)</td><td style="text-align:left">返回由 <em>array1</em> 和 <em>array2</em> 创建的映射。请注意，两个数组的长度应该相同，并且 calcite 使用 LAST_WIN 策略</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAP_FROM_ENTRIES(arrayOfRows)</td><td style="text-align:left">返回由具有两个字段的行数组创建的映射。请注意，一行中的字段数必须为 2。请注意，calcite 使用 LAST_WIN 策略</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">STR_TO_MAP(string [, stringDelimiter [, keyValueDelimiter]])</td><td style="text-align:left">使用分隔符将 <em>string</em> 拆分为键/值对后返回映射。<em>stringDelimiter</em> 的默认分隔符为‘,’，<em>keyValueDelimiter</em> 的默认分隔符为‘:’。请注意，calcite 使用的是 LAST_WIN 策略</td></tr><tr><td style="text-align:left">b m p s</td><td style="text-align:left">MD5(string)</td><td style="text-align:left">计算 <em>string</em> 的 MD5 128 位校验和并将其作为十六进制字符串返回</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">MONTHNAME(date)</td><td style="text-align:left">返回连接的区域设置中 <em>datetime</em> 月份的名称；例如，对于 DATE ‘2020-02-10’ 和 TIMESTAMP ‘2020-02-10 10:10:10’，它均返回‘二月’</td></tr><tr><td style="text-align:left">o s</td><td style="text-align:left">NVL(value1, value2)</td><td style="text-align:left">如果 <em>value1</em> 不为空，则返回 <em>value1</em>，否则返回 <em>value2</em></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">OFFSET(index)</td><td style="text-align:left">当索引一个数组时，将 <em>index</em> 包装在 <code>OFFSET</code> 中将返回基于 0 的 <em>index</em> 处的值；如果 <em>index</em> 超出范围，则会引发错误</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">ORDINAL(index)</td><td style="text-align:left">与 <code>OFFSET</code> 类似，但 <em>index</em> 从 1 开始</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PARSE_DATE(format, string)</td><td style="text-align:left">使用 <em>format</em> 指定的格式将日期的 <em>string</em> 表示形式转换为 DATE 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PARSE_DATETIME(format, string)</td><td style="text-align:left">使用 <em>format</em> 指定的格式将日期时间的 <em>string</em> 表示形式转换为 TIMESTAMP 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PARSE_TIME(format, string)</td><td style="text-align:left">使用 <em>format</em> 指定的格式将时间的 <em>string</em> 表示形式转换为 TIME 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PARSE_TIMESTAMP(format, string[, timeZone])</td><td style="text-align:left">使用 <em>format</em> 指定的格式将时间戳的 <em>string</em> 表示形式转换为 <em>timeZone</em> 中的 TIMESTAMP WITH LOCAL TIME ZONE 值</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">PARSE_URL(urlString, partToExtract [, keyToExtract] )</td><td style="text-align:left">从 <em>urlString</em> 返回指定的 <em>partToExtract</em>。<em>partToExtract</em> 的有效值包括 HOST、PATH、QUERY、REF、PROTOCOL、AUTHORITY、FILE 和 USERINFO。<em>keyToExtract</em> 指定要提取哪个查询</td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">POW(numeric1, numeric2)</td><td style="text-align:left">返回 <em>numeric1</em> 的 <em>numeric2</em> 次方</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">RANDOM()</td><td style="text-align:left">生成 0 到 1 之间的随机双精度数（含 0 和 1）</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">REGEXP(string, regexp)</td><td style="text-align:left">相当于 <code>string1 RLIKE string2</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">REGEXP_CONTAINS(string, regexp)</td><td style="text-align:left">返回 <em>string</em> 是否与 <em>regexp</em> 部分匹配</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">REGEXP_EXTRACT(string, regexp [, position [, occurrence]])</td><td style="text-align:left">返回 <em>string</em> 中与 <em>regexp</em> 匹配的子字符串，从 <em>position</em>（默认 1）开始搜索，直到找到第 n 次 <em>occurrence</em>（默认 1）。如果没有匹配，则返回 NULL</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">REGEXP_EXTRACT_ALL(string, regexp)</td><td style="text-align:left">返回 <em>string</em> 中与 <em>regexp</em> 匹配的所有子字符串的数组。如果没有匹配，则返回一个空数组</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">REGEXP_INSTR(string, regexp [, position [, occurrence [, occurrence_position]]])</td><td style="text-align:left">返回与 <em>regexp</em> 匹配的 <em>string</em> 中子字符串的最低 1 位置，从 <em>position</em>（默认 1）开始搜索，直到找到第 n 个 <em>occurrence</em>（默认 1）。将 indication_position（默认 0）设置为 1 将返回子字符串的结束位置 + 1。如果没有匹配，则返回 0</td></tr><tr><td style="text-align:left">m o p s</td><td style="text-align:left">REGEXP_LIKE(string, regexp [, flags])</td><td style="text-align:left">相当于 <code>string1 RLIKE string2</code>，但带有一个可选的搜索标志参数。支持的标志包括：<ul><li>i：不区分大小写匹配</li><li>c：区分大小写匹配</li><li>n：区分换行符匹配</li><li>s：不区分换行符匹配</li><li>m：多行</li></ul></td></tr><tr><td style="text-align:left">b m o</td><td style="text-align:left">REGEXP_REPLACE(string, regexp, rep [, pos [, occurrence [, matchType]]])</td><td style="text-align:left">将 <em>string</em> 中与 <em>regexp</em> 匹配的所有子字符串替换为 expr 中起始 <em>pos</em> 处的 <em>rep</em>（如果省略，则默认为 1），<em>occurrence</em> 指定要搜索匹配的哪一次出现（如果省略，则默认为 1），<em>matchType</em> 指定如何执行匹配</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">REGEXP_SUBSTR(string, regexp [, position [, occurrence]])</td><td style="text-align:left">REGEXP_EXTRACT 的同义词</td></tr><tr><td style="text-align:left">b m p s</td><td style="text-align:left">REPEAT(string, integer)</td><td style="text-align:left">返回由重复 <em>integer</em> 次的 <em>string</em> 组成的字符串；如果 <em>integer</em> 小于 1，则返回空字符串</td></tr><tr><td style="text-align:left">b m</td><td style="text-align:left">REVERSE(string)</td><td style="text-align:left">返回字符顺序颠倒的<em>字符串</em></td></tr><tr><td style="text-align:left">b m p s</td><td style="text-align:left">RIGHT(string, length)</td><td style="text-align:left">返回<em>字符串</em>最右边的<em>长度</em>个字符</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">string1 RLIKE string2</td><td style="text-align:left"><em>string1</em> 是否与正则表达式模式 <em>string2</em> 匹配（类似于 <code>LIKE</code>，但使用 Java 正则表达式）</td></tr><tr><td style="text-align:left">h s</td><td style="text-align:left">string1 NOT RLIKE string2</td><td style="text-align:left"><em>string1</em> 是否与正则表达式模式 <em>string2</em> 不匹配（类似于“NOT LIKE”，但使用 Java 正则表达式）</td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">RPAD(string, length[, pattern ])</td><td style="text-align:left">返回由 <em>string</em> 附加到 <em>length</em> 并使用 <em>pattern</em> 组成的字符串或字节值</td></tr><tr><td style="text-align:left">b o s</td><td style="text-align:left">RTRIM(string)</td><td style="text-align:left">返回删除末尾所有空格的 <em>string</em></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_ADD(numeric1, numeric2)</td><td style="text-align:left">返回 <em>numeric1</em> + <em>numeric2</em>，溢出时返回 NULL。参数隐式转换为 BIGINT、DOUBLE 或 DECIMAL 类型之一</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_CAST(value AS type)</td><td style="text-align:left">将 <em>value</em> 转换为 <em>type</em>，如果转换失败则返回 NULL</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_DIVIDE(numeric1, numeric2)</td><td style="text-align:left">返回 <em>numeric1</em> / <em>numeric2</em>，如果溢出或 <em>numeric2</em> 为零，则返回 NULL。参数隐式转换为 BIGINT、DOUBLE 或 DECIMAL 类型之一</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_MULTIPLY(numeric1, numeric2)</td><td style="text-align:left">返回 <em>numeric1</em> * <em>numeric2</em>，或溢出时返回 NULL。参数隐式转换为 BIGINT、DOUBLE 或 DECIMAL 类型之一</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_NEGATE(numeric)</td><td style="text-align:left">返回 <em>numeric</em> * -1，或溢出时返回 NULL。参数隐式转换为 BIGINT、DOUBLE 或 DECIMAL 类型之一</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_OFFSET(index)</td><td style="text-align:left">与 <code>OFFSET</code> 类似，但如果 <em>index</em> 超出范围，则返回 null</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_ORDINAL(index)</td><td style="text-align:left">与 <code>OFFSET</code> 类似，但 <em>index</em> 从 1 开始，并且如果 <em>index</em> 超出范围则返回 null</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SAFE_SUBTRACT(numeric1, numeric2)</td><td style="text-align:left">返回 <em>numeric1</em> - <em>numeric2</em>，或溢出时返回 NULL。参数隐式转换为 BIGINT、DOUBLE 或 DECIMAL 类型之一</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">SEC(numeric)</td><td style="text-align:left">以弧度返回 <em>numeric</em> 的正割</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">SECH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲正割</td></tr><tr><td style="text-align:left">b m p s</td><td style="text-align:left">SHA1(string)</td><td style="text-align:left">计算 <em>string</em> 的 SHA-1 哈希值并将其作为十六进制字符串返回</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">SHA256(string)</td><td style="text-align:left">计算 <em>string</em> 的 SHA-256 哈希值并将其作为十六进制字符串返回</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">SHA512(string)</td><td style="text-align:left">计算 <em>string</em> 的 SHA-512 哈希值并将其作为十六进制字符串返回</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">SINH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲正弦值</td></tr><tr><td style="text-align:left">b m o p</td><td style="text-align:left">SOUNDEX(string)</td><td style="text-align:left">返回 <em>string</em> 的语音表示；如果 <em>string</em> 使用多字节编码（如 UTF-8）进行编码，则抛出</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">SOUNDEX(string)</td><td style="text-align:left">返回 <em>string</em> 的语音表示；如果 <em>string</em> 使用多字节编码（如 UTF-8）编码，则返回原始 <em>string</em></td></tr><tr><td style="text-align:left">m s</td><td style="text-align:left">SPACE(integer)</td><td style="text-align:left">返回一个由 <em>整数</em> 空格组成的字符串；如果 <em>整数</em> 小于 1，则返回一个空字符串</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">SPLIT(string [, delimiter ])</td><td style="text-align:left">返回以 <em>delimiter</em> 分隔的 <em>string</em> 字符串数组（如果省略，则默认为逗号）。如果 <em>string</em> 为空，则返回一个空数组，否则，如果 <em>delimiter</em> 为空，则返回一个包含原始 <em>string</em> 的数组。</td></tr><tr><td style="text-align:left">f s</td><td style="text-align:left">STARTSWITH(string1, string2)</td><td style="text-align:left">返回 <em>string2</em> 是否是 <em>string1</em> 的前缀</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">STARTS_WITH(string1, string2)</td><td style="text-align:left">相当于 <code>STARTSWITH(string1, string2)</code></td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">STRCMP(string, string)</td><td style="text-align:left">如果两个字符串相同则返回 0，如果第一个参数小于第二个参数则返回 -1，如果第二个参数小于第一个参数则返回 1</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">STRPOS(string, substring)</td><td style="text-align:left">相当于 <code>POSITION(子字符串 IN 字符串)</code></td></tr><tr><td style="text-align:left">b m o p</td><td style="text-align:left">SUBSTR(string, position [, substringLength ])</td><td style="text-align:left">返回 <em>string</em> 的一部分，从字符 <em>position</em> 开始，长度为 <em>substringLength</em> 个字符。SUBSTR 使用输入字符集定义的字符计算长度</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">TANH(numeric)</td><td style="text-align:left">返回 <em>numeric</em> 的双曲正切</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME(hour, minute, second)</td><td style="text-align:left">返回 TIME 值 <em>小时</em>、<em>分钟</em>、<em>秒</em>（所有类型为 INTEGER）</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME(timestamp)</td><td style="text-align:left">从 <em>timestamp</em>（本地时间；BigQuery 的 DATETIME 类型）中提取时间</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME(instant)</td><td style="text-align:left">从 <em>timestampLtz</em>（一个瞬间；BigQuery 的 TIMESTAMP 类型）中提取时间，假设为 UTC</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME(instant, timeZone)</td><td style="text-align:left">从 <em>timeZone</em> 中的 <em>timestampLtz</em>（瞬间；BigQuery 的 TIMESTAMP 类型）中提取时间</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(string)</td><td style="text-align:left">相当于 <code>CAST(string AS TIMESTAMP WITH LOCAL TIME ZONE)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(string, timeZone)</td><td style="text-align:left">相当于 <code>CAST(string AS TIMESTAMP WITH LOCAL TIME ZONE)</code>，转换为 <em>timeZone</em></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(date)</td><td style="text-align:left">将<em>日期</em>转换为带有本地时区的时间戳值（午夜）</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(date, timeZone)</td><td style="text-align:left">将 <em>date</em> 转换为带有本地时区的时间戳值（午夜），以 <em>timeZone</em> 为单位</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(timestamp)</td><td style="text-align:left">将 <em>timestamp</em> 转换为带有本地时区的时间戳，假设为 UTC</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP(timestamp, timeZone)</td><td style="text-align:left">将 <em>timestamp</em> 转换为 <em>timeZone</em> 中的带有本地时区的时间戳</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP_ADD(timestamp, interval)</td><td style="text-align:left">返回在 <em>timestamp</em> 之后 <em>interval</em> 发生的 TIMESTAMP 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP_DIFF(timestamp, timestamp2, timeUnit)</td><td style="text-align:left">返回 <em>timestamp</em> 和 <em>timestamp2</em> 之间的 <em>timeUnit</em> 的整数。相当于 <code>TIMESTAMPDIFF(timeUnit, timestamp2, timestamp)</code> 和 <code>(timestamp - timestamp2) timeUnit</code></td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">TIMESTAMP_MICROS(integer)</td><td style="text-align:left">返回 1970-01-01 00:00:00 之后 <em>整数</em> 微秒的 TIMESTAMP</td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">TIMESTAMP_MILLIS(integer)</td><td style="text-align:left">返回 1970-01-01 00:00:00 之后 <em>整数</em> 毫秒的 TIMESTAMP</td></tr><tr><td style="text-align:left">b s</td><td style="text-align:left">TIMESTAMP_SECONDS(integer)</td><td style="text-align:left">返回 1970-01-01 00:00:00 之后 <em>整数</em> 秒的 TIMESTAMP</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP_SUB(timestamp, interval)</td><td style="text-align:left">返回 <em>timestamp</em> 之前 <em>interval</em> 的 TIMESTAMP 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIMESTAMP_TRUNC(timestamp, timeUnit)</td><td style="text-align:left">将 <em>timestamp</em> 截断为 <em>timeUnit</em> 的粒度，四舍五入到单位的开头</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME_ADD(time, interval)</td><td style="text-align:left">将<em>间隔</em>添加到<em>时间</em>，与任何时区无关</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME_DIFF(time, time2, timeUnit)</td><td style="text-align:left">返回 <em>time</em> 和 <em>time2</em> 之间的 <em>timeUnit</em> 的整数</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME_SUB(time, interval)</td><td style="text-align:left">返回 <em>time</em> 之前 <em>interval</em> 的 TIME 值</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TIME_TRUNC(time, timeUnit)</td><td style="text-align:left">将 <em>time</em> 截断为 <em>timeUnit</em> 的粒度，四舍五入到单位的开头</td></tr><tr><td style="text-align:left">m o p</td><td style="text-align:left">TO_CHAR(timestamp, format)</td><td style="text-align:left">使用格式 <em>format</em> 将 <em>timestamp</em> 转换为字符串</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">TO_CODE_POINTS(string)</td><td style="text-align:left">将 <em>string</em> 转换为表示代码点或扩展 ASCII 字符值的整数数组</td></tr><tr><td style="text-align:left">o p</td><td style="text-align:left">TO_DATE(string, format)</td><td style="text-align:left">使用格式 <em>format</em> 将 <em>string</em> 转换为日期</td></tr></tbody></table><p>注意：</p><ul><li><p>Calcite 没有 Redshift 库，因此改用 Postgres 库。函数 <code>DATEADD</code>、<code>DATEDIFF</code> 在 Redshift 中实现，而不是 Postgres，但它们仍然出现在 Calcite 的 Postgres 库中；</p></li><li><p>函数 <code>DATEADD</code>、<code>DATEDIFF</code>、<code>DATE_PART</code> 需要 Babel 解析器；</p></li><li><p>如果参数为 null，则 <code>JSON_TYPE</code> / <code>JSON_DEPTH</code> / <code>JSON_PRETTY</code> / <code>JSON_STORAGE_SIZE</code> 返回 null；</p></li><li><p>如果第一个参数为 null，则 <code>JSON_LENGTH</code> / <code>JSON_KEYS</code> / <code>JSON_REMOVE</code> 返回 null；</p></li><li><p><code>JSON_TYPE</code> 通常返回一个大写字符串标志，指示 JSON 输入的类型。目前支持的类型标志有：</p><ul><li>INTEGER</li><li>STRING</li><li>FLOAT</li><li>DOUBLE</li><li>LONG</li><li>BOOLEAN</li><li>DATE</li><li>OBJECT</li><li>ARRAY</li><li>NULL</li></ul></li><li><p><code>JSON_DEPTH</code> 定义 JSON 值的深度如下：</p><ul><li>空数组、空对象或标量值的深度为 1；</li><li>仅包含深度为 1 的元素的非空数组或仅包含深度为 1 的成员值的非空对象深度为 2；</li><li>否则，JSON 文档的深度大于 2。</li></ul></li><li><p><code>JSON_LENGTH</code> 定义 JSON 值的长度如下：</p><ul><li>标量值的长度为 1；</li><li>数组或对象的长度是其包含的元素数。</li></ul></li></ul><p>特定方言的聚合函数。</p><table><thead><tr><th style="text-align:left">C（兼容性）</th><th style="text-align:left">运算符语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">c</td><td style="text-align:left">AGGREGATE(m)</td><td style="text-align:left">在当前 GROUP BY 键的上下文中计算度量 <em>m</em></td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">ARRAY_AGG( [ ALL | DISTINCT ] value [ RESPECT NULLS | IGNORE NULLS ] [ ORDER BY orderItem [, orderItem ]* ] )</td><td style="text-align:left">将值收集到数组中</td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">ARRAY_CONCAT_AGG( [ ALL | DISTINCT ] value [ ORDER BY orderItem [, orderItem ]* ] )</td><td style="text-align:left">将数组连接成数组</td></tr><tr><td style="text-align:left">p s</td><td style="text-align:left">BOOL_AND(condition)</td><td style="text-align:left"><code>EVERY</code> 的同义词</td></tr><tr><td style="text-align:left">p s</td><td style="text-align:left">BOOL_OR(condition)</td><td style="text-align:left"><code>SOME</code> 的同义词</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">COUNTIF(condition)</td><td style="text-align:left">返回<em>条件</em>为 TRUE 的行数；相当于 <code>COUNT(*) FILTER (WHERE 条件)</code></td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">GROUP_CONCAT( [ ALL | DISTINCT ] value [, value ]* [ ORDER BY orderItem [, orderItem ]* ] [ SEPARATOR separator ] )</td><td style="text-align:left">MySQL 特定的 <code>LISTAGG</code> 变体</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">LOGICAL_AND(condition)</td><td style="text-align:left"><code>EVERY</code> 的同义词</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">LOGICAL_OR(condition)</td><td style="text-align:left"><code>SOME</code> 的同义词</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MAX_BY(value, comp)</td><td style="text-align:left"><code>ARG_MAX</code> 的同义词</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">MIN_BY(value, comp)</td><td style="text-align:left"><code>ARG_MIN</code> 的同义词</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PERCENTILE_CONT(value, fraction [ RESPECT NULLS | IGNORE NULLS ] ) OVER windowSpec</td><td style="text-align:left">标准 <code>PERCENTILE_CONT</code> 的同义词，其中 <code>PERCENTILE_CONT(value,fraction)OVER(ORDER BY value)</code> 相当于标准 <code>PERCENTILE_CONT(fraction)WITHIN GROUP(ORDER BY value)</code></td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">PERCENTILE_DISC(value, fraction [ RESPECT NULLS | IGNORE NULLS ] ) OVER windowSpec</td><td style="text-align:left">标准 <code>PERCENTILE_DISC</code> 的同义词，其中 <code>PERCENTILE_DISC(value,fraction)OVER(ORDER BY value)</code> 相当于标准 <code>PERCENTILE_DISC(fraction)WITHIN GROUP(ORDER BY value)</code></td></tr><tr><td style="text-align:left">b p</td><td style="text-align:left">STRING_AGG( [ ALL | DISTINCT ] value [, separator] [ ORDER BY orderItem [, orderItem ]* ] )</td><td style="text-align:left"><code>LISTAGG</code> 的同义词</td></tr></tbody></table><p>用法示例：</p><h4 id="json_type-示例"><a class="markdownIt-Anchor" href="#json_type-示例"></a> JSON_TYPE 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_TYPE(v) <span class="keyword">AS</span> c1,</span><br><span class="line">  JSON_TYPE(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;lax $.b&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c2,</span><br><span class="line">  JSON_TYPE(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;strict $.a[0]&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c3,</span><br><span class="line">  JSON_TYPE(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;strict $.a[1]&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c4</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;a&quot;: [10, true],&quot;b&quot;: &quot;[10, true]&quot;&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th></tr></thead><tbody><tr><td style="text-align:center">OBJECT</td><td style="text-align:center">ARRAY</td><td style="text-align:center">INTEGER</td><td style="text-align:center">BOOLEAN</td></tr></tbody></table><h4 id="json_depth-示例"><a class="markdownIt-Anchor" href="#json_depth-示例"></a> JSON_DEPTH 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_DEPTH(v) <span class="keyword">AS</span> c1,</span><br><span class="line">  JSON_DEPTH(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;lax $.b&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c2,</span><br><span class="line">  JSON_DEPTH(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;strict $.a[0]&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c3,</span><br><span class="line">  JSON_DEPTH(<span class="built_in">JSON_VALUE</span>(v, <span class="string">&#x27;strict $.a[1]&#x27;</span> ERROR <span class="keyword">ON</span> ERROR)) <span class="keyword">AS</span> c4</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;a&quot;: [10, true],&quot;b&quot;: &quot;[10, true]&quot;&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="json_length-示例"><a class="markdownIt-Anchor" href="#json_length-示例"></a> JSON_LENGTH 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_LENGTH(v) <span class="keyword">AS</span> c1,</span><br><span class="line">  JSON_LENGTH(v, <span class="string">&#x27;lax $.a&#x27;</span>) <span class="keyword">AS</span> c2,</span><br><span class="line">  JSON_LENGTH(v, <span class="string">&#x27;strict $.a[0]&#x27;</span>) <span class="keyword">AS</span> c3,</span><br><span class="line">  JSON_LENGTH(v, <span class="string">&#x27;strict $.a[1]&#x27;</span>) <span class="keyword">AS</span> c4</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;a&quot;: [10, true]&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="json_insert-示例"><a class="markdownIt-Anchor" href="#json_insert-示例"></a> JSON_INSERT 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_INSERT(v, <span class="string">&#x27;$.a&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c1,</span><br><span class="line">  JSON_INSERT(v, <span class="string">&#x27;$&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;a&quot;: [10, true]&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th>C1</th><th>C2</th></tr></thead><tbody><tr><td>{“a”：1，“b”：[2]，“c”：“[1]”}</td><td>{“a”：1，“b”：[2]，“c”：“[1]”}</td></tr></tbody></table><h4 id="json_keys-示例"><a class="markdownIt-Anchor" href="#json_keys-示例"></a> JSON_KEYS 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_KEYS(v) <span class="keyword">AS</span> c1,</span><br><span class="line">  JSON_KEYS(v, <span class="string">&#x27;lax $.a&#x27;</span>) <span class="keyword">AS</span> c2,</span><br><span class="line">  JSON_KEYS(v, <span class="string">&#x27;lax $.b&#x27;</span>) <span class="keyword">AS</span> c2,</span><br><span class="line">  JSON_KEYS(v, <span class="string">&#x27;strict $.a[0]&#x27;</span>) <span class="keyword">AS</span> c3,</span><br><span class="line">  JSON_KEYS(v, <span class="string">&#x27;strict $.a[1]&#x27;</span>) <span class="keyword">AS</span> c4</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;a&quot;: [10, true],&quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th><th style="text-align:center">C5</th></tr></thead><tbody><tr><td style="text-align:center">[“a”, “b”]</td><td style="text-align:center">NULL</td><td style="text-align:center">[“c”]</td><td style="text-align:center">NULL</td><td style="text-align:center">NULL</td></tr></tbody></table><h4 id="json_remove-示例"><a class="markdownIt-Anchor" href="#json_remove-示例"></a> JSON_REMOVE 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JSON_REMOVE(v, <span class="string">&#x27;$[1]&#x27;</span>) <span class="keyword">AS</span> c1</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th></tr></thead><tbody><tr><td style="text-align:center">[“a”, “d”]</td></tr></tbody></table><h4 id="json_replace-示例"><a class="markdownIt-Anchor" href="#json_replace-示例"></a> JSON_REPLACE 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">JSON_REPLACE(v, <span class="string">&#x27;$.a&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c1,</span><br><span class="line">JSON_REPLACE(v, <span class="string">&#x27;$&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;\&quot;a\&quot;: 1,\&quot;b\&quot;:[2]&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th>C1</th><th>C2</th></tr></thead><tbody><tr><td>{“a”：1，“b”：[2]，“c”：“[1]”}</td><td>{“a”:1 , “b”:[2] , “c”:“[1]”}”)</td></tr></tbody></table><h4 id="json_set-示例"><a class="markdownIt-Anchor" href="#json_set-示例"></a> JSON_SET 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">JSON_SET(v, <span class="string">&#x27;$.a&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c1,</span><br><span class="line">JSON_SET(v, <span class="string">&#x27;$&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;$.c&#x27;</span>, <span class="string">&#x27;[1]&#x27;</span>) <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;\&quot;a\&quot;: 1,\&quot;b\&quot;:[2]&#125;&#x27;</span>)) <span class="keyword">AS</span> t(v)</span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th>C1</th><th>C2</th></tr></thead><tbody><tr><td>{“a”：10，“b”：[2]}</td><td>10</td></tr></tbody></table><h4 id="json_storage_size-示例"><a class="markdownIt-Anchor" href="#json_storage_size-示例"></a> JSON_STORAGE_SIZE 示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">JSON_STORAGE_SIZE(<span class="string">&#x27;[100, \&quot;sakila\&quot;, [1, 3, 5], 425.05]&#x27;</span>) <span class="keyword">AS</span> c1,</span><br><span class="line">JSON_STORAGE_SIZE(<span class="string">&#x27;&#123;\&quot;a\&quot;: 10, \&quot;b\&quot;: \&quot;a\&quot;, \&quot;c\&quot;: \&quot;[1, 3, 5, 7]\&quot;&#125;&#x27;</span>) <span class="keyword">AS</span> c2,</span><br><span class="line">JSON_STORAGE_SIZE(<span class="string">&#x27;&#123;\&quot;a\&quot;: 10, \&quot;b\&quot;: \&quot;xyz\&quot;, \&quot;c\&quot;: \&quot;[1, 3, 5, 7]\&quot;&#125;&#x27;</span>) <span class="keyword">AS</span> c3,</span><br><span class="line">JSON_STORAGE_SIZE(<span class="string">&#x27;[100, \&quot;json\&quot;, [[10, 20, 30], 3, 5], 425.05]&#x27;</span>) <span class="keyword">AS</span> c4</span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th></tr></thead><tbody><tr><td style="text-align:center">29</td><td style="text-align:center">35</td><td style="text-align:center">37</td><td style="text-align:center">36</td></tr></tbody></table><h4 id="解码示例"><a class="markdownIt-Anchor" href="#解码示例"></a> 解码示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DECODE(f1, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>) <span class="keyword">as</span> c1,</span><br><span class="line">  DECODE(f2, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>) <span class="keyword">as</span> c2,</span><br><span class="line">  DECODE(f3, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>) <span class="keyword">as</span> c3,</span><br><span class="line">  DECODE(f4, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>) <span class="keyword">as</span> c4,</span><br><span class="line">  DECODE(f5, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>) <span class="keyword">as</span> c5</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="keyword">AS</span> t(f1, f2, f3, f4, f5);</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th><th style="text-align:center">C5</th></tr></thead><tbody><tr><td style="text-align:center">aa</td><td style="text-align:center">bb</td><td style="text-align:center">cc</td><td style="text-align:center">dd</td><td style="text-align:center">ee</td></tr></tbody></table><h4 id="翻译示例"><a class="markdownIt-Anchor" href="#翻译示例"></a> 翻译示例</h4><p>SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRANSLATE</span>(<span class="string">&#x27;Aa*Bb*Cc&#x27;&#x27;D*d&#x27;</span>, <span class="string">&#x27; */&#x27;&#x27;%&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="keyword">as</span> c1,</span><br><span class="line">  <span class="built_in">TRANSLATE</span>(<span class="string">&#x27;Aa/Bb/Cc&#x27;&#x27;D/d&#x27;</span>, <span class="string">&#x27; */&#x27;&#x27;%&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="keyword">as</span> c2,</span><br><span class="line">  <span class="built_in">TRANSLATE</span>(<span class="string">&#x27;Aa Bb Cc&#x27;&#x27;D d&#x27;</span>, <span class="string">&#x27; */&#x27;&#x27;%&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="keyword">as</span> c3,</span><br><span class="line">  <span class="built_in">TRANSLATE</span>(<span class="string">&#x27;Aa%Bb%Cc&#x27;&#x27;D%d&#x27;</span>, <span class="string">&#x27; */&#x27;&#x27;%&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="keyword">as</span> c4</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">VALUES</span> (<span class="literal">true</span>)) <span class="keyword">AS</span> t(f0);</span><br></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th style="text-align:center">C1</th><th style="text-align:center">C2</th><th style="text-align:center">C3</th><th style="text-align:center">C4</th></tr></thead><tbody><tr><td style="text-align:center">Aa_Bb_CcD_d</td><td style="text-align:center">Aa_Bb_CcD_d</td><td style="text-align:center">Aa_Bb_CcD_d</td><td style="text-align:center">Aa_Bb_CcD_d</td></tr></tbody></table><h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lambdaExpression:</span><br><span class="line">      parameters <span class="string">&#x27;-&gt;&#x27;</span> expression</span><br><span class="line"></span><br><span class="line">parameters:</span><br><span class="line">      <span class="string">&#x27;(&#x27;</span> [ identifier [, identifier ] ] <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   identifier</span><br></pre></td></tr></table></figure><p>高阶函数未包含在 SQL 标准中，因此所有函数也将在<a href="#%E6%96%B9%E8%A8%80%E7%89%B9%E5%AE%9A%E8%BF%90%E7%AE%97%E7%AC%A6">方言特定运算符</a>中列出。</p><p>带有 lambda 参数的函数示例为 <em>EXISTS</em>。</p><h3 id="用户定义函数"><a class="markdownIt-Anchor" href="#用户定义函数"></a> 用户定义函数</h3><p>Calcite 是可扩展的。您可以使用用户代码定义每种函数。对于每种函数，通常有几种定义函数的方法，从方便到高效不等。</p><p>要实现<em>标量函数</em>，有 3 个选项：</p><ul><li>创建一个具有公共静态 <code>eval</code> 方法的类，并注册该类；</li><li>创建一个具有公共非静态 <code>eval</code> 方法和无参数公共构造函数的类，并注册该类；</li><li>创建一个具有一个或多个公共静态方法的类，并注册每个类/方法组合。</li></ul><p>要实现<em>聚合函数</em>，有 2 个选项：</p><ul><li>创建一个具有公共静态 <code>init</code>、<code>add</code> 和 <code>result</code> 方法的类，并注册该类；</li><li>创建一个具有公共非静态 <code>init</code>、<code>add</code> 和 <code>result</code> 方法以及无参数的公共构造函数的类，并注册该类。</li></ul><p>可选地，向类添加一个公共 <code>merge</code> 方法；这允许 Calcite 生成合并小计的代码。</p><p>可选地，让您的类实现 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/sql/SqlSplittableAggFunction.html">SqlSplittableAggFunction</a> 接口；这允许 Calcite 跨多个聚合阶段分解函数，从汇总表中汇总，并通过连接推送它。</p><p>要实现 <em>table 函数</em>，有 3 个选项：</p><ul><li>创建一个具有静态 <code>eval</code> 方法的类，该方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/ScannableTable.html">ScannableTable</a> 或 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/QueryableTable.html">QueryableTable</a>，并注册该类；</li><li>创建一个具有非静态 <code>eval</code> 方法的类，该方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/ScannableTable.html">ScannableTable</a> 或 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/QueryableTable.html">QueryableTable</a>，并注册该类；</li><li>创建一个具有一个或多个公共静态方法的类，这些方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/ScannableTable.html">ScannableTable</a> 或 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/QueryableTable.html">QueryableTable</a>，并注册每个类/方法组合。</li></ul><p>要实现 <em>table 宏</em>，有 3 个选项：</p><ul><li>创建一个具有静态 <code>eval</code> 方法的类，该方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/TranslatableTable.html">TranslatableTable</a>，并注册该类；</li><li>创建一个具有非静态 <code>eval</code> 方法的类，该方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/TranslatableTable.html">TranslatableTable</a>，并注册该类；</li><li>创建一个具有一个或多个公共静态方法的类，该方法返回 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/schema/TranslatableTable.html">TranslatableTable</a>，并注册每个类/方法组合。</li></ul><p>Calcite 从实现函数的 Java 方法的参数和返回类型推断出函数的参数类型和结果类型。此外，您可以使用 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/linq4j/function/Parameter.html">Parameter</a> 注释指定每个参数的名称和可选性。</p><h4 id="使用命名参数和可选参数调用函数"><a class="markdownIt-Anchor" href="#使用命名参数和可选参数调用函数"></a> 使用命名参数和可选参数调用函数</h4><p>通常，调用函数时，需要按顺序指定其所有参数。但如果函数有很多参数，尤其是当您想随着时间的推移添加更多参数时，这可能会成为一个问题。</p><p>为了解决这个问题，SQL 标准允许您按名称传递参数，并定义可选参数（即，如果未指定参数，则使用默认值）。</p><p>假设您有一个函数 <code>f</code>，声明如下伪语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FUNCTION</span> f(</span><br><span class="line">  <span class="type">INTEGER</span> a,</span><br><span class="line">  <span class="type">INTEGER</span> b <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="type">INTEGER</span> c,</span><br><span class="line">  <span class="type">INTEGER</span> d <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="type">INTEGER</span> e <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>) <span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br></pre></td></tr></table></figure><p>该函数的所有参数都有名称，并且参数 <code>b</code>、<code>d</code> 和 <code>e</code> 的默认值为 <code>NULL</code>，因此是可选的（在 Calcite 中，<code>NULL</code> 是可选参数唯一允许的默认值；这可能会在<a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/CALCITE-947">未来</a>发生变化）。</p><p>调用带有可选参数的函数时，您可以省略列表末尾的可选参数，或者对任何可选参数使用 <code>DEFAULT</code> 关键字。以下是一些示例：</p><ul><li><code>f(1, 2, 3, 4, 5)</code> 按顺序为每个参数提供一个值；</li><li><code>f(1, 2, 3, 4)</code> 省略 <code>e</code>，获取其默认值 <code>NULL</code>；</li><li><code>f(1, DEFAULT, 3)</code> 省略 <code>d</code> 和 <code>e</code>，并指定使用默认值 <code>b</code>；</li><li><code>f(1, DEFAULT, 3, DEFAULT, DEFAULT)</code> 与上一个示例具有相同的效果；</li><li><code>f(1, 2)</code> 不合法，因为 <code>c</code> 不是可选的；</li><li><code>f(1, 2, DEFAULT, 4)</code> 不合法，因为 <code>c</code> 不是可选的。</li></ul><p>您可以使用 <code>=&gt;</code> 语法按名称指定参数。如果一个参数被命名，则所有参数都必须被命名。参数可以位于任何其他参数中，但不得多次指定任何参数，并且您需要为每个非可选参数提供一个值。以下是一些示例：</p><ul><li><code>f(c =&gt; 3, d =&gt; 1, a =&gt; 0)</code> 等同于 <code>f(0, NULL, 3, 1, NULL)</code>;</li><li><code>f(c =&gt; 3, d =&gt; 1)</code> 不合法，因为您没有为 <code>a</code> 指定值，并且 <code>a</code> 不是可选的。</li></ul><h4 id="sql-hint"><a class="markdownIt-Anchor" href="#sql-hint"></a> SQL Hint</h4><p>提示是给优化器的指令。编写 SQL 时，您可能知道优化器不知道的数据信息。提示使您能够做出通常由优化器做出的决策。</p><ul><li>规划器执行器：没有完美的规划器，因此实施提示以允许用户更好地控制执行是有意义的。例如：“永远不要将此子查询与其他子查询合并”（<code>/*+ no_merge */</code>）；“将这些表视为前导表”（<code>/*+ leading */</code>）以影响连接顺序等；</li><li>附加元数据/统计信息：某些统计信息（如“用于扫描的表索引”或“某些 shuffle 键的倾斜信息”）对于查询而言是动态的，使用提示配置它们会非常方便，因为我们从规划器获得的规划元数据通常不太准确；</li><li>运算符资源约束：在许多情况下，我们会为执行运算符提供默认的资源配置，即最小并行度、内存（消耗资源的 UDF）、特殊资源需求（GPU 或 SSD 磁盘）……使用每个查询（而不是作业）的提示来分析资源会非常灵活。</li></ul><h5 id="语法-2"><a class="markdownIt-Anchor" href="#语法-2"></a> 语法</h5><p>Calcite 支持两个位置的提示：</p><ul><li><p>查询提示：紧跟在 <code>SELECT</code> 关键字之后；</p></li><li><p>表提示：紧跟在引用的表名之后。</p></li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ hint1, hint2(a=1, b=2) */</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  tableName <span class="comment">/*+ hint3(5, &#x27;x&#x27;) */</span></span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">  tableName <span class="comment">/*+ hint4(c=id), hint5 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hintComment:</span><br><span class="line">      <span class="string">&#x27;/*+&#x27;</span> hint [, hint ]<span class="operator">*</span> <span class="string">&#x27;*/&#x27;</span></span><br><span class="line"></span><br><span class="line">hint:</span><br><span class="line">      hintName</span><br><span class="line">  <span class="operator">|</span>   hintName <span class="string">&#x27;(&#x27;</span> optionKey <span class="string">&#x27;=&#x27;</span> optionVal [, optionKey <span class="string">&#x27;=&#x27;</span> optionVal ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   hintName <span class="string">&#x27;(&#x27;</span> hintOption [, hintOption ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">optionKey:</span><br><span class="line">      simpleIdentifier</span><br><span class="line">  <span class="operator">|</span>   stringLiteral</span><br><span class="line"></span><br><span class="line">optionVal:</span><br><span class="line">      stringLiteral</span><br><span class="line"></span><br><span class="line">hintOption:</span><br><span class="line">      simpleIdentifier</span><br><span class="line">   <span class="operator">|</span>  numericLiteral</span><br><span class="line">   <span class="operator">|</span>  stringLiteral</span><br></pre></td></tr></table></figure><p>它在 Calcite 中处于实验阶段，尚未完全实现，我们已实现的内容包括：</p><ul><li>解析器支持上述语法；</li><li><code>RelHint</code> 表示提示项；</li><li>在 sql-to-rel 转换和规划器规划期间传播提示的机制。</li></ul><p>我们尚未添加任何内置提示项，如果我们认为提示足够稳定，我们会引入更多。</p><h4 id="match_recognize"><a class="markdownIt-Anchor" href="#match_recognize"></a> MATCH_RECOGNIZE</h4><p><code>MATCH_RECOGNIZE</code> 是一个 SQL 扩展，用于识别复杂事件处理 (CEP) 中的事件序列。</p><p>它在 Calcite 中处于实验阶段，尚未完全实现。</p><h5 id="语法-3"><a class="markdownIt-Anchor" href="#语法-3"></a> 语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">matchRecognize:</span><br><span class="line">      <span class="keyword">MATCH_RECOGNIZE</span> <span class="string">&#x27;(&#x27;</span></span><br><span class="line">      [ <span class="keyword">PARTITION</span> <span class="keyword">BY</span> expression [, expression ]<span class="operator">*</span> ]</span><br><span class="line">      [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderItem [, orderItem ]<span class="operator">*</span> ]</span><br><span class="line">      [ MEASURES measureColumn [, measureColumn ]<span class="operator">*</span> ]</span><br><span class="line">      [ <span class="keyword">ONE</span> <span class="type">ROW</span> <span class="keyword">PER</span> <span class="keyword">MATCH</span> <span class="operator">|</span> <span class="keyword">ALL</span> <span class="keyword">ROWS</span> <span class="keyword">PER</span> <span class="keyword">MATCH</span> ]</span><br><span class="line">      [ AFTER <span class="keyword">MATCH</span> <span class="keyword">skip</span> ]</span><br><span class="line">      <span class="keyword">PATTERN</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">pattern</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      [ <span class="keyword">WITHIN</span> intervalLiteral ]</span><br><span class="line">      [ <span class="keyword">SUBSET</span> subsetItem [, subsetItem ]<span class="operator">*</span> ]</span><br><span class="line">      <span class="keyword">DEFINE</span> variable <span class="keyword">AS</span> <span class="keyword">condition</span> [, variable <span class="keyword">AS</span> <span class="keyword">condition</span> ]<span class="operator">*</span></span><br><span class="line">      <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">skip</span>:</span><br><span class="line">      <span class="keyword">SKIP</span> <span class="keyword">TO</span> NEXT <span class="type">ROW</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">SKIP</span> PAST <span class="keyword">LAST</span> <span class="type">ROW</span></span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">SKIP</span> <span class="keyword">TO</span> <span class="keyword">FIRST</span> variable</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">SKIP</span> <span class="keyword">TO</span> <span class="keyword">LAST</span> variable</span><br><span class="line">  <span class="operator">|</span>   <span class="keyword">SKIP</span> <span class="keyword">TO</span> variable</span><br><span class="line"></span><br><span class="line">subsetItem:</span><br><span class="line">      variable <span class="operator">=</span> <span class="string">&#x27;(&#x27;</span> variable [, variable ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">measureColumn:</span><br><span class="line">      expression <span class="keyword">AS</span> alias</span><br><span class="line"></span><br><span class="line"><span class="keyword">pattern</span>:</span><br><span class="line">      patternTerm [ <span class="string">&#x27;|&#x27;</span> patternTerm ]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line">patternTerm:</span><br><span class="line">      patternFactor [ patternFactor ]<span class="operator">*</span></span><br><span class="line"></span><br><span class="line">patternFactor:</span><br><span class="line">      patternPrimary [ patternQuantifier ]</span><br><span class="line"></span><br><span class="line">patternPrimary:</span><br><span class="line">      variable</span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;$&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;^&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> [ <span class="keyword">pattern</span> ] <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;&#123;-&#x27;</span> <span class="keyword">pattern</span> <span class="string">&#x27;-&#125;&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   PERMUTE <span class="string">&#x27;(&#x27;</span> <span class="keyword">pattern</span> [, <span class="keyword">pattern</span> ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">patternQuantifier:</span><br><span class="line">      <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;*?&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;+&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;+?&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;?&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;??&#x27;</span></span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;&#123;&#x27;</span> &#123; [ minRepeat ], [ maxRepeat ] &#125; <span class="string">&#x27;&#125;&#x27;</span> [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">  <span class="operator">|</span>   <span class="string">&#x27;&#123;&#x27;</span> repeat <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">intervalLiteral:</span><br><span class="line">      <span class="type">INTERVAL</span> <span class="string">&#x27;string&#x27;</span> timeUnit [ <span class="keyword">TO</span> timeUnit ]</span><br></pre></td></tr></table></figure><p>在 patternQuantifier 中，repeat 是正整数，minRepeat 和 maxRepeat 是非负整数。</p><h2 id="ddl-扩展"><a class="markdownIt-Anchor" href="#ddl-扩展"></a> DDL 扩展</h2><p>DDL 扩展仅在 calcite-server 模块中可用。要启用，请在类路径中包含 <code>calcite-server.jar</code>，并将 <code>parserFactory=org.apache.calcite.sql.parser.ddl.SqlDdlParserImpl#FACTORY</code> 添加到 JDBC 连接字符串（请参阅连接字符串属性 <a target="_blank" rel="noopener" href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/config/CalciteConnectionProperty.html#PARSER_FACTORY">parserFactory</a>）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">ddlStatement:</span><br><span class="line">      createSchemaStatement</span><br><span class="line">  <span class="operator">|</span>   createForeignSchemaStatement</span><br><span class="line">  <span class="operator">|</span>   createTableStatement</span><br><span class="line">  <span class="operator">|</span>   createTableLikeStatement</span><br><span class="line">  <span class="operator">|</span>   createViewStatement</span><br><span class="line">  <span class="operator">|</span>   createMaterializedViewStatement</span><br><span class="line">  <span class="operator">|</span>   createTypeStatement</span><br><span class="line">  <span class="operator">|</span>   createFunctionStatement</span><br><span class="line">  <span class="operator">|</span>   dropSchemaStatement</span><br><span class="line">  <span class="operator">|</span>   dropForeignSchemaStatement</span><br><span class="line">  <span class="operator">|</span>   dropTableStatement</span><br><span class="line">  <span class="operator">|</span>   dropViewStatement</span><br><span class="line">  <span class="operator">|</span>   dropMaterializedViewStatement</span><br><span class="line">  <span class="operator">|</span>   dropTypeStatement</span><br><span class="line">  <span class="operator">|</span>   dropFunctionStatement</span><br><span class="line"></span><br><span class="line">createSchemaStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] SCHEMA [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">createForeignSchemaStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">FOREIGN</span> SCHEMA [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name</span><br><span class="line">      (</span><br><span class="line">          TYPE <span class="string">&#x27;type&#x27;</span></span><br><span class="line">      <span class="operator">|</span>   LIBRARY <span class="string">&#x27;com.example.calcite.ExampleSchemaFactory&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      [ OPTIONS <span class="string">&#x27;(&#x27;</span> option [, option ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">option:</span><br><span class="line">      name literal</span><br><span class="line"></span><br><span class="line">createTableStatement:</span><br><span class="line">      <span class="keyword">CREATE TABLE</span> [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name</span><br><span class="line">      [ <span class="string">&#x27;(&#x27;</span> tableElement [, tableElement ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      [ <span class="keyword">AS</span> query ]</span><br><span class="line"></span><br><span class="line">createTableLikeStatement:</span><br><span class="line">      <span class="keyword">CREATE TABLE</span> [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name <span class="keyword">LIKE</span> sourceTable</span><br><span class="line">      [ likeOption [, likeOption ]<span class="operator">*</span> ]</span><br><span class="line"></span><br><span class="line">likeOption:</span><br><span class="line">      &#123; INCLUDING <span class="operator">|</span> EXCLUDING &#125; &#123; DEFAULTS <span class="operator">|</span> GENERATED <span class="operator">|</span> <span class="keyword">ALL</span> &#125;</span><br><span class="line"></span><br><span class="line">createTypeStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] TYPE name <span class="keyword">AS</span></span><br><span class="line">      &#123;</span><br><span class="line">          baseType</span><br><span class="line">      <span class="operator">|</span>   <span class="string">&#x27;(&#x27;</span> attributeDef [, attributeDef ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">attributeDef:</span><br><span class="line">      attributeName type</span><br><span class="line">      [ <span class="keyword">COLLATE</span> <span class="keyword">collation</span> ]</span><br><span class="line">      [ <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NOT NULL</span> ]</span><br><span class="line">      [ <span class="keyword">DEFAULT</span> expression ]</span><br><span class="line"></span><br><span class="line">tableElement:</span><br><span class="line">      columnName type [ columnGenerator ] [ columnConstraint ]</span><br><span class="line">  <span class="operator">|</span>   columnName</span><br><span class="line">  <span class="operator">|</span>   tableConstraint</span><br><span class="line"></span><br><span class="line">columnGenerator:</span><br><span class="line">      <span class="keyword">DEFAULT</span> expression</span><br><span class="line">  <span class="operator">|</span>   [ GENERATED ALWAYS ] <span class="keyword">AS</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      &#123; VIRTUAL <span class="operator">|</span> STORED &#125;</span><br><span class="line"></span><br><span class="line">columnConstraint:</span><br><span class="line">      [ <span class="keyword">CONSTRAINT</span> name ]</span><br><span class="line">      [ <span class="keyword">NOT</span> ] <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">tableConstraint:</span><br><span class="line">      [ <span class="keyword">CONSTRAINT</span> name ]</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">CHECK</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      <span class="operator">|</span>   <span class="keyword">PRIMARY KEY</span> <span class="string">&#x27;(&#x27;</span> columnName [, columnName ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      <span class="operator">|</span>   <span class="keyword">UNIQUE</span> <span class="string">&#x27;(&#x27;</span> columnName [, columnName ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">createViewStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">VIEW</span> name</span><br><span class="line">      [ <span class="string">&#x27;(&#x27;</span> columnName [, columnName ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      <span class="keyword">AS</span> query</span><br><span class="line"></span><br><span class="line">createMaterializedViewStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name</span><br><span class="line">      [ <span class="string">&#x27;(&#x27;</span> columnName [, columnName ]<span class="operator">*</span> <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">      <span class="keyword">AS</span> query</span><br><span class="line"></span><br><span class="line">createFunctionStatement:</span><br><span class="line">      <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">FUNCTION</span> [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] name</span><br><span class="line">      <span class="keyword">AS</span> classNameLiteral</span><br><span class="line">      [ <span class="keyword">USING</span>  usingFile [, usingFile ]<span class="operator">*</span> ]</span><br><span class="line"></span><br><span class="line">usingFile:</span><br><span class="line">      &#123; JAR <span class="operator">|</span> FILE <span class="operator">|</span> ARCHIVE &#125; filePathLiteral</span><br><span class="line"></span><br><span class="line">dropSchemaStatement:</span><br><span class="line">      <span class="keyword">DROP</span> SCHEMA [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropForeignSchemaStatement:</span><br><span class="line">      <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> SCHEMA [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropTableStatement:</span><br><span class="line">      <span class="keyword">DROP</span> <span class="keyword">TABLE</span> [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropViewStatement:</span><br><span class="line">      <span class="keyword">DROP</span> <span class="keyword">VIEW</span> [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropMaterializedViewStatement:</span><br><span class="line">      <span class="keyword">DROP</span> MATERIALIZED <span class="keyword">VIEW</span> [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropTypeStatement:</span><br><span class="line">      <span class="keyword">DROP</span> TYPE [ IF <span class="keyword">EXISTS</span> ] name</span><br><span class="line"></span><br><span class="line">dropFunctionStatement:</span><br><span class="line">      <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [ IF <span class="keyword">EXISTS</span> ] name</span><br></pre></td></tr></table></figure><p>在 <em>createTableStatement</em> 中，如果指定 <em>AS query</em>，则可以省略 <em>tableElement</em> 列表，也可以省略任何 <em>tableElement</em> 的数据类型，在这种情况下，它只会重命名基础列。</p><p>在 <em>columnGenerator</em> 中，如果没有为生成的列指定 <code>VIRTUAL</code> 或 <code>STORED</code>，则 <code>VIRTUAL</code> 为默认值。</p><p>在 <em>createFunctionStatement</em> 和 <em>usingFile</em> 中，<em>classNameLiteral</em> 和 <em>filePathLiteral</em> 是字符文字。</p><h3 id="为用户定义类型声明对象"><a class="markdownIt-Anchor" href="#为用户定义类型声明对象"></a> 为用户定义类型声明对象</h3><p>在架构中定义并安装对象类型后，您可以使用它在任何 SQL 块中声明对象。例如，您可以使用对象类型指定属性、列、变量、绑定变量、记录字段、表元素、形式参数或函数结果的数据类型。在运行时，将创建对象类型的实例；也就是说，实例化该类型的对象。每个对象可以保存不同的值。</p><p>例如，我们可以声明类型 <code>address_typ</code> 和 <code>employee_typ</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE address_typ <span class="keyword">AS</span> (</span><br><span class="line">   street          <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">   city            <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">   state           <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">   postal_code     <span class="type">VARCHAR</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TYPE employee_typ <span class="keyword">AS</span> (</span><br><span class="line">  employee_id       <span class="type">DECIMAL</span>(<span class="number">6</span>),</span><br><span class="line">  first_name        <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  last_name         <span class="type">VARCHAR</span>(<span class="number">25</span>),</span><br><span class="line">  email             <span class="type">VARCHAR</span>(<span class="number">25</span>),</span><br><span class="line">  phone_number      <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  hire_date         <span class="type">DATE</span>,</span><br><span class="line">  job_id            <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">  salary            <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">  commission_pct    <span class="type">DECIMAL</span>(<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">  manager_id        <span class="type">DECIMAL</span>(<span class="number">6</span>),</span><br><span class="line">  department_id     <span class="type">DECIMAL</span>(<span class="number">4</span>),</span><br><span class="line">  address           address_typ);</span><br></pre></td></tr></table></figure><p>使用这些类型，您可以按如下方式实例化对象：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">employee_typ(<span class="number">315</span>, <span class="string">&#x27;Francis&#x27;</span>, <span class="string">&#x27;Logan&#x27;</span>, <span class="string">&#x27;FLOGAN&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;555.777.2222&#x27;</span>, <span class="type">DATE</span> <span class="string">&#x27;2004-05-01&#x27;</span>, <span class="string">&#x27;SA_MAN&#x27;</span>, <span class="number">11000</span>, <span class="number">.15</span>, <span class="number">101</span>, <span class="number">110</span>,</span><br><span class="line">     address_typ(<span class="string">&#x27;376 Mission&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>, <span class="string">&#x27;CA&#x27;</span>, <span class="string">&#x27;94222&#x27;</span>))</span><br></pre></td></tr></table></figure><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">写在最后</span><span class="empty"></span></p></div><p>笔者因为工作原因接触到 Calcite，前期学习过程中，深感 Calcite 学习资料之匮乏，因此创建了 <a target="_blank" rel="noopener" href="https://wx.zsxq.com/dweb2/index/group/51128414222814">Calcite 从入门到精通知识星球</a>，希望能够将学习过程中的资料和经验沉淀下来，为更多想要学习 Calcite 的朋友提供一些帮助。</p><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/blog/blog/202309210909027.png" alt="Calcite 从入门到精通"></p><div class="article-footer fs14"></div></article><div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/calcite/kafka-adapter.html">Kafka 适配器</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/calcite/model.html">JSON/YAML 模型</a></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body giscus"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg><div id="giscus" src="https://giscus.app/client.js" data-repo="strongduanmu/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkzNzQwMDk3Njg=" data-category="Announcements" data-category-id="DIC_kwDOFkrvqM4CZIsa" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div></section></div><footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs15">文档</span><a href="/wiki/calcite/background.html">Calcite</a><a href="/wiki/cmu_15_445/index.html">CMU 15-445</a><a href="/wiki/cmu_15_721/index.html">CMU 15-721</a></div><div class="sitemap-group"><span class="fs15">便笺</span><a href="/notes/">Common</a><a href="/notes/docker.html">Docker</a><a href="/notes/git.html">Git</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/more/">关于</a><a href="/more/news/">动态</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://github.com/strongduanmu">@strongduanmu</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建，使用 <a target="_blank" rel="noopener" href="https://vercel.com/">Vercel</a> 网站部署。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br>本站总访问量 <span id="vercount_value_site_pv"></span> 次，本站访客数 <span id="vercount_value_site_uv"></span> 人次。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper tagcloud"><div class="widget-header dis-select"><span class="name">标签云</span></div><div class="widget-body fs14"><a href="/tags/Antlr/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">Antlr</a> <a href="/tags/Calcite/" style="font-size:20px;color:#6f86d6" class="tag -10">Calcite</a> <a href="/tags/CentOS/" style="font-size:12px;color:#48c6ef" class="tag -0">CentOS</a> <a href="/tags/Charles/" style="font-size:12px;color:#48c6ef" class="tag -0">Charles</a> <a href="/tags/Distributed-Transaction/" style="font-size:12px;color:#48c6ef" class="tag -0">Distributed Transaction</a> <a href="/tags/Docker/" style="font-size:12px;color:#48c6ef" class="tag -0">Docker</a> <a href="/tags/FFmpeg/" style="font-size:12px;color:#48c6ef" class="tag -0">FFmpeg</a> <a href="/tags/GraalVM/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">GraalVM</a> <a href="/tags/In-Action/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">In Action</a> <a href="/tags/JVM/" style="font-size:17.33px;color:#629bde" class="tag -7">JVM</a> <a href="/tags/Java/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">Java</a> <a href="/tags/Java8/" style="font-size:12px;color:#48c6ef" class="tag -0">Java8</a> <a href="/tags/JavaCC/" style="font-size:12px;color:#48c6ef" class="tag -0">JavaCC</a> <a href="/tags/Kernel/" style="font-size:14.67px;color:#55b1e7" class="tag -3">Kernel</a> <a href="/tags/Linux/" style="font-size:12px;color:#48c6ef" class="tag -0">Linux</a> <a href="/tags/MySQL/" style="font-size:16px;color:#5ca6e3" class="tag -5">MySQL</a> <a href="/tags/Paper/" style="font-size:12px;color:#48c6ef" class="tag -0">Paper</a> <a href="/tags/PolarDB-X/" style="font-size:12px;color:#48c6ef" class="tag -0">PolarDB-X</a> <a href="/tags/Query-Optimization/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">Query Optimization</a> <a href="/tags/Remote-Debugging/" style="font-size:13.33px;color:#4fbbeb" class="tag -2">Remote Debugging</a> <a href="/tags/SQLLine/" style="font-size:12px;color:#48c6ef" class="tag -0">SQLLine</a> <a href="/tags/SQLancer/" style="font-size:12px;color:#48c6ef" class="tag -0">SQLancer</a> <a href="/tags/ShardingSphere/" style="font-size:18.67px;color:#6991da" class="tag -8">ShardingSphere</a> <a href="/tags/Transaction/" style="font-size:12px;color:#48c6ef" class="tag -0">Transaction</a> <a href="/tags/VirtualBox/" style="font-size:12px;color:#48c6ef" class="tag -0">VirtualBox</a> <a href="/tags/Wireshark/" style="font-size:12px;color:#48c6ef" class="tag -0">Wireshark</a></div></widget><widget class="widget-wrapper markdown"><div class="widget-header dis-select"><span class="name">赞助商</span></div><div class="widget-body fs14"><p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9880881761323734" data-ad-slot="1987141063" data-ad-format="auto" data-full-width-responsive="true"></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></widget></div></aside><div class="float-panel blur"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script>let ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",tag_plugins:{chat:Object.assign({api:"https://siteinfo.listentothewind.cn/api/v1"})},search:{}};if((ctx.search.service="local_search")==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"skip_search":null,"codeblock":true,"sort":"-date"}');ctx.search[ctx.search.service]=e}let def={avatar:"/assets/placeholder/avatar.svg",cover:"/assets/placeholder/cover.svg"},deps={jquery:"https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js",marked:"https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js"}</script><script>function RunItem(){function n(e,t){this.name=t||e.name,this.run=()=>{try{e()}catch(e){console.log(e)}}}this.list=[],this.start=()=>{for(var e=0;e<this.list.length;e++)this.list[e].run()},this.push=(e,t,r=!0)=>{let s=e,i=new n(s=r?()=>{utils.requestAnimationFrame(e)}:s,t);this.list.push(i)},this.remove=t=>{for(let e=0;e<this.list.length;e++)this.list[e].name==t&&this.list.splice(e,1)}}let utils={css:(e,t,r,s)=>{var i,n,a=window.document,o=a.createElement("link"),d=(n=t||(i=(a.body||a.getElementsByTagName("head")[0]).childNodes)[i.length-1],a.styleSheets);if(s)for(var l in s)s.hasOwnProperty(l)&&o.setAttribute(l,s[l]);o.rel="stylesheet",o.href=e,o.media="only x",function e(t){if(a.body)return t();setTimeout(function(){e(t)})}(function(){n.parentNode.insertBefore(o,t?n:n.nextSibling)});function u(e){for(var t=o.href,r=d.length;r--;)if(d[r].href===t)return e();setTimeout(function(){u(e)})}function h(){o.addEventListener&&o.removeEventListener("load",h),o.media=r||"all"}return o.addEventListener&&o.addEventListener("load",h),o.onloadcssdefined=u,u(h),o},js:(i,n)=>new Promise((t,e)=>{var r=document.createElement("script");if(i.startsWith("/")&&(i=ctx.root+i.substring(1)),r.src=i,n)for(var s of Object.keys(n))r[s]=n[s];else r.async=!0;r.onerror=e,r.onload=r.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(r.onload=r.onreadystatechange=null,t())},document.head.appendChild(r)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(n,a,o,d)=>{let l=3;utils.onLoading(n),function i(){new Promise((t,e)=>{let r=0,s=setTimeout(()=>{0===r&&(r=2,s=null,e("请求超时"),0==l)&&d()},5e3);fetch(a).then(function(e){if(2!==r&&(clearTimeout(s),t(e),s=null,r=1),e.ok)return e.json();throw new Error("Network response was not ok.")}).then(function(e){l=0,utils.onLoadSuccess(n),o(e)}).catch(function(e){0<l?(--l,setTimeout(()=>{i()},5e3)):(utils.onLoadFailure(n),d())})})}()},requestAnimationFrame:e=>{window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame),window.requestAnimationFrame(e)},dark:{}};utils.dark.method={toggle:new RunItem},utils.dark=Object.assign(utils.dark,{push:utils.dark.method.toggle.push})</script><script>let sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script>(()=>{var e;for(e of document.querySelectorAll(".tag-subtree.parent-tag > a > .tag-switcher-wrapper"))e.addEventListener("click",e=>{e.target.closest(".tag-subtree.parent-tag").classList.toggle("expanded"),e.preventDefault()});var t=new URLSearchParams(window.location.search).get("tag");if(t){let e=document.querySelector(`.tag-subtree[data-tag="${t}"]`);if(e)for(e.querySelector("a").classList.add("active");e;)e.classList.add("expanded"),e=e.parentElement.closest(".tag-subtree.parent-tag")}})()</script><script src="/js/main.js?v=1.30.1" defer></script><script>let applyTheme=e=>{"auto"===e?document.documentElement.removeAttribute("data-theme"):document.documentElement.setAttribute("data-theme",e),applyThemeToGiscus(e)},applyThemeToGiscus=e=>{e="auto"===e?"preferred_color_scheme":e;var t=document.getElementById("giscus"),t=(t&&t.setAttribute("data-theme",e),document.querySelector("#comments > section.giscus > iframe"));t&&(e=t.src.replace(/theme=[\w]+/,"theme="+e),t.src=e)},switchTheme=()=>{let e;switch(document.documentElement.getAttribute("data-theme")){case"light":e="dark";break;case"dark":e="auto";break;default:e="light"}applyTheme(e),window.localStorage.setItem("Stellar.theme",e),utils.dark.mode="auto"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e,utils.dark.method.toggle.start(),hud?.toast?.({light:"切换到浅色模式",dark:"切换到深色模式",auto:"切换到跟随系统配色"}[e])};(()=>{var e=window.localStorage.getItem("Stellar.theme");null!==e?applyTheme(e):utils.dark.mode=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",utils.dark.method.toggle.start()})()</script><script type="module">const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }</script><script defer>window.addEventListener("DOMContentLoaded",e=>{ctx.services=Object.assign({},JSON.parse('{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"}}'));for(let s of Object.keys(ctx.services)){let e=ctx.services[s].js;"siteinfo"==s?(ctx.cardlinks=document.querySelectorAll("a.link-card[cardlink]"),0<ctx.cardlinks?.length&&utils.js(e,{defer:!0}).then(function(){setCardLink(ctx.cardlinks)})):"voice"==s?(ctx.voiceAudios=document.querySelectorAll(".voice>audio"),0<ctx.voiceAudios?.length&&utils.js(e,{defer:!0}).then(function(){createVoiceDom(ctx.voiceAudios)})):"video"==s?(ctx.videos=document.querySelectorAll(".video>video"),0<ctx.videos?.length&&utils.js(e,{defer:!0}).then(function(){videoEvents(ctx.videos)})):"download-file"==s?(ctx.files=document.querySelectorAll(".file"),0<ctx.files?.length&&utils.js(e,{defer:!0}).then(function(){downloadFileEvent(ctx.files)})):0<document.getElementsByClassName("ds-"+s)?.length&&utils.jq(()=>{s,utils.js(deps.marked).then(function(){utils.js(e,{defer:!0})})})}let n=document.querySelectorAll(".chat .status-bar .time");var s,t;function i(){for(let e=0;e<n.length;++e){var s=n[e],t=new Date,i=t.getHours(),t=t.getMinutes();s.innerHTML=o(i)+":"+o(t)}}function o(e){return e<10?"0"+e:e}0<n.length&&(i(),s=(new Date).getSeconds(),t=setInterval(function(){i(),clearInterval(t),setInterval(i,6e4)},1e3*(60-s)));let c=new IntersectionObserver((e,t)=>{e.filter(e=>e.isIntersecting).sort((e,s)=>e.intersectionRect.y!==s.intersectionRect.y?e.intersectionRect.y-s.intersectionRect.y:e.intersectionRect.x-s.intersectionRect.x).forEach((e,s)=>{t.unobserve(e.target),setTimeout(()=>{e.target.classList.add("quote-blink"),setTimeout(()=>{e.target.classList.remove("quote-blink")},1e3)},Math.max(100,16)*(s+1))})}),r=document.querySelectorAll(".chat .talk .quote");r.forEach(i=>{i.addEventListener("click",function(){var e,s,t=document.getElementById("quote-"+i.getAttribute("quotedCellTag"));t&&(s=(e=t.parentElement).clientHeight/2,t.offsetTop>s-t.clientHeight/2?e.scrollTo({top:t.offsetTop-s+t.clientHeight/2,behavior:"smooth"}):e.scrollTo({top:0,behavior:"smooth"}),c.observe(t))})})})</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="/js/flying-pages.min.js"></script><script defer src="/js/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy"},window.addEventListener("LazyLoad::Initialized",function(n){window.lazyLoadInstance=n.detail.instance},!1),document.addEventListener("DOMContentLoaded",function(){window.lazyLoadInstance?.update()})</script><script>ctx.fancybox={selector:"article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)",css:"/css/fancybox.min.css",js:"/js/fancybox.umd.min.js"};var selector="[data-fancybox]:not(.error)",needFancybox=(ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector),0!==document.querySelectorAll(selector).length);if(!needFancybox){let e=document.getElementsByClassName("ds-memos");null!=e&&0<e.length&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then(function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(e,t)=>t.triggerEl.alt||t.triggerEl.dataset.caption||null})}))</script><script>window.addEventListener("DOMContentLoaded",e=>{let i=document.getElementById("swiper-api");null!=i&&(utils.css("/css/swiper-bundle.min.css"),utils.js("/js/swiper-bundle.min.js",{defer:!0}).then(function(){var e=i.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,rewind:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})}))})</script><script>document.addEventListener("DOMContentLoaded",function(){window.codeElements=document.querySelectorAll(".code"),0<window.codeElements.length&&(ctx.copycode={default_text:"复制代码",success_text:"复制成功",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))})</script><script async>((a,t,c)=>{t.ChatraID="PHWnu7Bamcwtbnx2d";var h=a.createElement("script");t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},h.async=!0,h.src="https://call.chatra.io/chatra.js",a.head&&a.head.appendChild(h)})(document,window,"Chatra")</script><script defer src="https://cn.vercount.one/js"></script><link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"></noscript><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>window.va=window.va||function(){(window.vaq=window.vaq||[]).push(arguments)}</script><script defer src="/_vercel/insights/script.js"></script><script>window.si=window.si||function(){(window.siq=window.siq||[]).push(arguments)}</script><script defer src="/_vercel/speed-insights/script.js"></script><script>function change_banner(){$(".banner img.bg").attr("src","/assets/banner/banner_"+Math.floor(20*Math.random()+1)+".jpg")}setTimeout("change_banner()",250)</script><script>function add_page_pv(){$("#post-meta").after('<div class="flex-row" id="post-meta"><span class="text created">本文总阅读量 <span id="vercount_value_page_pv"></span> 次</span></div>')}setTimeout("add_page_pv()",500)</script><script>function change_img_alt(){$("article.md-text img:not(.post-cover img):not(.cover img):not(.card-link img):not(.image-bg img):not(.social img):not(.preview img)").each(function(t){$(this).after("<div class='image-meta' style='text-align:center;'><span class='image-caption center' style='display:inline-block;font-size:.8125rem;color:var(--text-p2);line-height:1.5;text-align:justify;'>"+($(this).attr("title")||$(this).attr("alt"))+"</span></div>")})}setTimeout("change_img_alt()",1e3)</script></div></body></html>